<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android源码(8)-Binder</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(8)-Binder/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(8)-Binder/</url>
      
        <content type="html"><![CDATA[<p>这是关于Android Binder机制的一篇文章，Binder是Android里面非常重要的组成，也是最难理解的一块知识点，学习Binder最好的方法是深入源码阅读，因为Binder相关的知识错综复杂，一般初学者也很容易迷失在源码的汪洋里，本文旨在梳理Binder的架构和流程，并且试着以实用的角度来看待Binder。</p><h1 id="一、为什么需要Binder机制？"><a href="#一、为什么需要Binder机制？" class="headerlink" title="一、为什么需要Binder机制？"></a>一、为什么需要Binder机制？</h1><p>Android系统中，每个应用程序是由Android的Activity，Service，Broadcast，ContentProvider这四剑客的中一个或多个组合而成，这四剑客所涉及的多进程间的通信底层都是依赖于Binder IPC机制。例如当进程A中的Activity要向进程B中的Service通信，这便需要依赖于Binder IPC。<br>如果熟悉Android源码，其实可以知道整个Android系统架构中，也大量采用了Binder机制作为IPC（进程间通信）方案。<br>Android是在Linux内核的基础上设计的。而在Linux中，已经拥有”管道&#x2F;消息队列&#x2F;共享内存&#x2F;信号量&#x2F;Socket等等”众多的IPC通信手段；但是，Google为什么单单选择了Binder，可见Binder肯定有自己独特的优势：</p><h3 id="1-1-Binder能很好的实现C-S架构"><a href="#1-1-Binder能很好的实现C-S架构" class="headerlink" title="1.1 Binder能很好的实现C&#x2F;S架构"></a>1.1 Binder能很好的实现C&#x2F;S架构</h3><p>Android系统，很大一部分都是居于Client-Server架构的设计。Client端有什么需求，直接发送给Server端去完成，Server处理完毕再将反馈内容发送给Client。Server端与Client端相对独立，稳定性较好。传统的CS架构只有Socket，但是Socket通信效率相对于其他IPC来说又太低效，而Binder正是基于C&#x2F;S架构设计的。</p><h3 id="1-2-Binder传输效率高"><a href="#1-2-Binder传输效率高" class="headerlink" title="1.2 Binder传输效率高"></a>1.2 Binder传输效率高</h3><p>Binder只需要进行一次拷贝，把Client端的用户空间的数据即copy_from_user()到内核空间，然后将内核空间的数据映射到Server端的用户空间。<br>Binder性能上仅仅次于Linux 共享内存的方式，但是共享内存的方式，进程间同步又是一个难题。</p><h3 id="1-3-Binder安全性极高"><a href="#1-3-Binder安全性极高" class="headerlink" title="1.3 Binder安全性极高"></a>1.3 Binder安全性极高</h3><p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID&#x2F;PID是否满足访问权限。<br>Client-Server通信过程中，Binder内核会为每个Client进程分配了UID&#x2F;PID来作为鉴别身份的标示，并且在Binder通信时会根据UID&#x2F;PID进行有效性检测。<br>而如果是传统的IPC只能由在数据包当中填入UID&#x2F;PID，这个并不是一个可靠的方法。</p><p>知乎上有一位答主讲得很好，可以看看:</p><p>为什么 Android 要采用 Binder 作为 IPC 机制?(<a href="https://www.zhihu.com/question/39440766">https://www.zhihu.com/question/39440766</a>)</p><h1 id="二、Binder原理"><a href="#二、Binder原理" class="headerlink" title="二、Binder原理"></a>二、Binder原理</h1><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/binder-01.jpg" alt="binder1"></p><ol><li>Binder采用Client-Server架构，包含Client,Server,ServiceManager,Binder驱动四个组件</li><li>应用程序都运行在用户控件，每个应用程序都有它自己独立的内存空间，若不同的应用程序之间涉及到通讯，需要通过内核进行中转，因为要用到内核的copy_from_user()和copy_to_user()等函数</li><li>Server进程要先注册Service 到ServiceManager,Client进程使用Server的Service前，需先向ServiceManager中获取相应的Service,然后使用Service</li></ol><h1 id="三、Binder驱动层"><a href="#三、Binder驱动层" class="headerlink" title="三、Binder驱动层"></a>三、Binder驱动层</h1><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/binder-02.png" alt="binder2"></p><p>当用户空间调用open()方法，最终会调用binder驱动的binder_open()方法；mmap()&#x2F;ioctl()方法也是同理，从用户态进入内核态，都依赖于系统调用过程。</p><h4 id="3-1-binder-init"><a href="#3-1-binder-init" class="headerlink" title="3.1 binder_init"></a>3.1 binder_init</h4><p>注册misc设备，指定相应文件操作方法</p><h4 id="3-2-binder-open"><a href="#3-2-binder-open" class="headerlink" title="3.2 binder_open"></a>3.2 binder_open</h4><p>创建binder_proc对象，并把当前进程等信息保存bind_proc对象，改对象管理IPC所需的各种信息并拥有其他结构体的根结构体，再把bind_proc对象保存到文件filp,以及把bind_proc加入到全局链表binder_procs</p><h4 id="3-3-binder-mmap"><a href="#3-3-binder-mmap" class="headerlink" title="3.3 binder_mmap"></a>3.3 binder_mmap</h4><p>在内核虚拟地址空间，申请一块于用户虚拟内存相同大小的内存；然后再申请1个page大小的物理内存，再将同一块物理内存映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的buffer和内核空间的buffer同步操作的功能</p><h4 id="3-4-binder-ioctl"><a href="#3-4-binder-ioctl" class="headerlink" title="3.4 binder_ioctl"></a>3.4 binder_ioctl</h4><p>负责在两个进程间收发IPC数据和IPC reply数据，调用流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//step 1:</span><br><span class="line">binder_write_read bwr;</span><br><span class="line">ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) </span><br><span class="line">    // step 2:</span><br><span class="line">    binder_ioctl(filp, BINDER_WRITE_READ, &amp;bwr)</span><br><span class="line">        // step 3:</span><br><span class="line">        binder_ioctl_write_read(filp, BINDER_WRITE_READ, &amp;bwr, thread)</span><br><span class="line">            // step 4:</span><br><span class="line">            copy_from_user(&amp;bwr, ubuf, sizeof(bwr))</span><br><span class="line">            binder_thread_write(proc, thread, bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            copy_to_user(...)</span><br></pre></td></tr></table></figure><h5 id="binder-thread-write-处理binder请求码，以“BC-”开头，建成后bc码，用于IPC层传递到Binder-Driver层；"><a href="#binder-thread-write-处理binder请求码，以“BC-”开头，建成后bc码，用于IPC层传递到Binder-Driver层；" class="headerlink" title="binder_thread_write(): 处理binder请求码，以“BC_”开头，建成后bc码，用于IPC层传递到Binder Driver层；"></a>binder_thread_write(): 处理binder请求码，以“BC_”开头，建成后bc码，用于IPC层传递到Binder Driver层；</h5><h5 id="binder-thread-read-生成Binder响应吗，以“BR-”开头，简称BR码，用于Binder-Driver层传递到IPC层"><a href="#binder-thread-read-生成Binder响应吗，以“BR-”开头，简称BR码，用于Binder-Driver层传递到IPC层" class="headerlink" title="binder_thread_read(): 生成Binder响应吗，以“BR_”开头，简称BR码，用于Binder Driver层传递到IPC层"></a>binder_thread_read(): 生成Binder响应吗，以“BR_”开头，简称BR码，用于Binder Driver层传递到IPC层</h5><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/binder-04.jpg" alt="binder4"></p><h1 id="四-Binder通信流程"><a href="#四-Binder通信流程" class="headerlink" title="四. Binder通信流程"></a>四. Binder通信流程</h1><p>例如当名为BatteryStatsService的Client向ServiceManager注册服务的过程中，IPC层的数据组成为：<br>Handle&#x3D;0，RPC代码为ADD_SERVICE_TRANSACTION，RPC数据为BatteryStatsService，Binder协议为BC_TRANSACTION。<br>整个流程图大致如下：</p><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/binder-05.png" alt="binder5"></p><p>handle为0正是指向ServiceManager。</p><h1 id="五、启动ServiceManager"><a href="#五、启动ServiceManager" class="headerlink" title="五、启动ServiceManager"></a>五、启动ServiceManager</h1><p>ServiceManager启动时序图：</p><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/create_servicemanager.jpg" alt="binder5"></p><ol><li>打开binder驱动，并调用mmap()方法分配128k内存映射空间: binder_open()</li><li>通知binder驱动使其成为守护进程: binder_become_context_manager()</li><li>验证selinux权限，判断进程是否有注册或查看指定服务</li><li>进入循环状态，等待client端的请求：binder_loop()</li></ol><h1 id="六、获取ServiceManager"><a href="#六、获取ServiceManager" class="headerlink" title="六、获取ServiceManager"></a>六、获取ServiceManager</h1><p>获取Service Manager是通过defaultServiceManager()方法来完成，当进程注册服务(addService)或 获取服务(getService)的过程之前，都需要先调用defaultServiceManager()方法来获取gDefaultServiceManager对象。</p><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/get_servicemanager.jpg" alt="binder5"></p><ol><li>获取ProcessState对象，在其构造函数中调用open_driver函数打开binder驱动，并将句柄保存到mDriverFD;</li><li>调用gProcess-&gt;getContextObject函数来获得一个句柄值为0得binder引用，即BpBinder</li><li>通过interface_cast构造一个BpServiceManger对象，所以gDefaultServiceManager最终为new BpServicemanager(new BpBinder(0))</li></ol><h1 id="七、addService"><a href="#七、addService" class="headerlink" title="七、addService"></a>七、addService</h1><p>以Native层的服务以media服务为例，注册MediaPlayerService的时序图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/add-service.jpg" alt="binder5"></p><ol><li>defaultServiceManager()返回的是BpServiceManager，会调用BpServiceManager.addService方法</li><li>addService()通过remote()中保存的BpBinder调用到IPCThreadState的transact方法；</li><li>IPCThreadState::transact会调用writeTransactionData()传输数据传输数据，然后和驱动交互，驱动把请求转发给ServiceManager执行真正的注册服务；</li><li>得到驱动的返回后，调用BBinder，最终调用到BnMediaPlayerService的onTransact方法；</li><li>开启两个线程不断和Binder进行交互，获取Client请求。</li></ol><p>获取服务的流程基本也是差不多的，不再累述。</p><h1 id="八、Binder架构"><a href="#八、Binder架构" class="headerlink" title="八、Binder架构"></a>八、Binder架构</h1><p>binder在framework层，采用JNI技术来调用native(C&#x2F;C++)层的binder架构，从而为上层应用程序提供服务。 我们知道native层中，binder是C&#x2F;S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。</p><ol><li>BinderProxy类代表Client端，Binder类代表Server端</li><li>framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑是交予Native层方法来处理</li></ol><h5 id="比如addService流程："><a href="#比如addService流程：" class="headerlink" title="比如addService流程："></a>比如addService流程：</h5><ol><li>java层通过getIServiceManager获得ServiceManagerProxy对象，通过该对象BinderProxy,最终会调用BpBinder对象，由BpBinder来完成通讯。</li><li>Binder驱动将Client端的请求转发给BBinder的transact方法，然后由其子类JavaBBinder调用。后者调用指定Service的方法，并返回给驱动</li></ol><h1 id="九、Binder类图"><a href="#九、Binder类图" class="headerlink" title="九、Binder类图"></a>九、Binder类图</h1><h5 id="9-1-Native-Binder类图"><a href="#9-1-Native-Binder类图" class="headerlink" title="9.1 Native Binder类图"></a>9.1 Native Binder类图</h5><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/binder_native_class.jpg" alt="binder5"></p><h5 id="9-2-Framework-Binder类图"><a href="#9-2-Framework-Binder类图" class="headerlink" title="9.2 Framework Binder类图"></a>9.2 Framework Binder类图</h5><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/class_ServiceManager.jpg" alt="binder5"></p><h1 id="十、Binder其他"><a href="#十、Binder其他" class="headerlink" title="十、Binder其他"></a>十、Binder其他</h1><p>介绍一些Binder其他比较重要的点，方便理清Binder的一些疑问。比如Binder实体和引用，比如ProcessState和IPCThreadState，比如数据结构怎么传递等。</p><h4 id="10-1-Binder中各个角色的关系"><a href="#10-1-Binder中各个角色的关系" class="headerlink" title="10.1 Binder中各个角色的关系"></a>10.1 Binder中各个角色的关系</h4><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/binder_relationship.jpg" alt="binder5"></p><h5 id="1-Binder实体-binder-node"><a href="#1-Binder实体-binder-node" class="headerlink" title="1. Binder实体 : binder_node"></a>1. Binder实体 : binder_node</h5><p>Binder实体，是各个Server以及ServiceManager在内核中的存在形式。<br>Binder实体实际上是内核中 binder_node 结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。<br>在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。</p><h5 id="2-Binder引用-binder-ref"><a href="#2-Binder引用-binder-ref" class="headerlink" title="2. Binder引用 : binder_ref"></a>2. Binder引用 : binder_ref</h5><p>所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。<br>如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。<br>Binder实体和Binder引用都是内核(即Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。</p><h5 id="3-远程服务"><a href="#3-远程服务" class="headerlink" title="3. 远程服务"></a>3. 远程服务</h5><p>Server都是以服务的形式注册到ServiceManager中进行管理的。如果将Server本身看作是”本地服务”的话，那么Client中的”远程服务”就是本地服务的代理。如果你对代理模式比较熟悉的话，就很容易理解了，远程服务就是本地服务的一个代理，通过该远程服务Client就能和Server进行通信。</p><h4 id="10-2-进程和线程的关系"><a href="#10-2-进程和线程的关系" class="headerlink" title="10.2 进程和线程的关系"></a>10.2 进程和线程的关系</h4><p>图解：<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/binder-proc-relation.png" alt="binder5"></p><ol><li>Binder驱动通过binder_procs链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应。</li><li>每个进程有且只有一个ProcessState对象，这是通过单例模式来保证的。</li><li>每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是Binder_thread结构体。在binder_proc结构体中通过成员变量rb_root threads，来记录当前进程内所有的binder_thread。</li></ol><h5 id="Binder线程池："><a href="#Binder线程池：" class="headerlink" title="Binder线程池："></a>Binder线程池：</h5><p>每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。</p><h4 id="10-3-Binder数据传输"><a href="#10-3-Binder数据传输" class="headerlink" title="10.3 Binder数据传输"></a>10.3 Binder数据传输</h4><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/binder_data.jpg" alt="binder5"></p><ol><li>用户空间的进程调用ioctl(fd,BINDER_WRITE_READ,&amp;bwr)时传递给Binder驱动的信息。fd是Binder驱动的文件句柄，BINDER_WRITE_READ是ioctl()的一个标识，而bwr是传递的数据，write_buffer是请求数据的内容，而write_consumed是用来记录请求数据中已经被Binder驱动处理过的数据的大小。</li><li>ioctl会走到binder_thread_write和binder_thread_read。这层的数据是”事务指令”+”binder_transaction_data结构体”组成的。data是保存事务中具体数据的内存地址。具体调用流程可以参考#3.4章节</li><li>这层是有效数据。如果该请求是传递给ServiceManager进行处理的，则有效数据是：消息头+”Server的相关信息”。消息头是用来进行有效性检查的，而”Server的相关信息”则是请求要处理的信息。</li></ol><h1 id="十一、源码目录"><a href="#十一、源码目录" class="headerlink" title="十一、源码目录"></a>十一、源码目录</h1><p>从上之下, 整个Binder架构所涉及的总共有以下5个目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/framework/base/core/java/               (Java)</span><br><span class="line">/framework/base/core/jni/                (JNI)</span><br><span class="line">/framework/native/libs/binder            (Native)</span><br><span class="line">/framework/native/cmds/servicemanager/   (Native)</span><br><span class="line">/kernel/drivers/staging/android          (Driver)</span><br></pre></td></tr></table></figure><p>11.1 Java framework</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/framework/base/core/java/android/os/  </span><br><span class="line">    - IInterface.java</span><br><span class="line">    - IBinder.java</span><br><span class="line">    - Parcel.java</span><br><span class="line">    - IServiceManager.java</span><br><span class="line">    - ServiceManager.java</span><br><span class="line">    - ServiceManagerNative.java</span><br><span class="line">    - Binder.java  </span><br><span class="line">    </span><br><span class="line">/framework/base/core/jni/    </span><br><span class="line">    - android_os_Parcel.cpp</span><br><span class="line">    - AndroidRuntime.cpp</span><br><span class="line">    - android_util_Binder.cpp (核心类)</span><br></pre></td></tr></table></figure><p>11.2 Native framework</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/framework/native/libs/binder         </span><br><span class="line">    - IServiceManager.cpp</span><br><span class="line">    - BpBinder.cpp</span><br><span class="line">    - Binder.cpp</span><br><span class="line">    - IPCThreadState.cpp (核心类)</span><br><span class="line">    - ProcessState.cpp  (核心类)</span><br><span class="line">/framework/native/include/binder/ </span><br><span class="line">    - IServiceManager.h</span><br><span class="line">    - IInterface.h</span><br><span class="line">/framework/native/cmds/servicemanager/ </span><br><span class="line">    - service_manager.c</span><br><span class="line">    - binder.c</span><br></pre></td></tr></table></figure><p>11.3 Kernel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/kernel/drivers/staging/android/</span><br><span class="line">    - binder.c</span><br><span class="line">    - uapi/binder.h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-机器学习—数学基础一（统计学与概率论）</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%80%EF%BC%88%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B8%8E%E6%A6%82%E7%8E%87%E8%AE%BA%EF%BC%89/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%80%EF%BC%88%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B8%8E%E6%A6%82%E7%8E%87%E8%AE%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>注：随机变量分离散型随机变量和非离散型随机变量，非离散型随机变量中只讨论连续型随机变量</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://wx3.sinaimg.cn/mw690/005EpKr8ly1g1e77lxfjfj30tf0jkwom.jpg" alt="总结"></p><h3 id="条件概率，全概率，贝叶斯三者关系"><a href="#条件概率，全概率，贝叶斯三者关系" class="headerlink" title="条件概率，全概率，贝叶斯三者关系"></a>条件概率，全概率，贝叶斯三者关系</h3><p><img src="https://wx4.sinaimg.cn/mw690/005EpKr8ly1g1e77lufcpj30oy0ebadb.jpg" alt="概率"></p><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p><img src="https://wx3.sinaimg.cn/mw690/005EpKr8ly1g1e77lutxyj30oi0f6goz.jpg" alt="二项分布"></p><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p><img src="https://wx1.sinaimg.cn/mw690/005EpKr8ly1g1e77ltlmcj30on0eyq5l.jpg" alt="柏松分布"></p><h3 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h3><p><img src="https://wx3.sinaimg.cn/mw690/005EpKr8ly1g1e77lvooej30op0f7q6a.jpg" alt="概率分布"></p><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p><img src="https://wx3.sinaimg.cn/mw690/005EpKr8ly1g1e77luwhvj30p00exgqi.jpg" alt="正态分布"></p>]]></content>
      
      
      <categories>
          
          <category> 算法-机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-机器学习—数学基础二（线性代数）</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BA%8C%EF%BC%88%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%89/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BA%8C%EF%BC%88%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="1-矩阵的行几何意义：行构成的方程有解"><a href="#1-矩阵的行几何意义：行构成的方程有解" class="headerlink" title="1.矩阵的行几何意义：行构成的方程有解"></a>1.矩阵的行几何意义：行构成的方程有解</h3><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3451200-aad6b63ee43b423c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="行视图"></p></blockquote><h3 id="2-矩阵列的几何意义：列构成的向量求和"><a href="#2-矩阵列的几何意义：列构成的向量求和" class="headerlink" title="2.矩阵列的几何意义：列构成的向量求和"></a>2.矩阵列的几何意义：列构成的向量求和</h3><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3451200-6872873a1e4da15c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="列视图"></p></blockquote><h3 id="3-https-blog-csdn-net-u010182633-article-details-52335565"><a href="#3-https-blog-csdn-net-u010182633-article-details-52335565" class="headerlink" title="3. https://blog.csdn.net/u010182633/article/details/52335565"></a>3. <a href="https://blog.csdn.net/u010182633/article/details/52335565">https://blog.csdn.net/u010182633/article/details/52335565</a></h3><p>基组成子空间&#x3D;最大的线性无关组</p><h3 id="4-四个空间"><a href="#4-四个空间" class="headerlink" title="4.四个空间"></a>4.四个空间</h3><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3451200-193393ebf24b7a26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="定义"></p></blockquote><h3 id="5-四个空间关系图"><a href="#5-四个空间关系图" class="headerlink" title="5.四个空间关系图"></a>5.四个空间关系图</h3><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3451200-89a1235e6048d1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关系图"></p></blockquote><h3 id="6-矩阵的分解"><a href="#6-矩阵的分解" class="headerlink" title="6.矩阵的分解"></a>6.矩阵的分解</h3><blockquote><p>学会求解：<br> a. <a href="https://jingyan.baidu.com/article/9989c746d5af17f648ecfefd.html">https://jingyan.baidu.com/article/9989c746d5af17f648ecfefd.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法-机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-机器学习—数学知识点清单</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B8%85%E5%8D%95/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="深度学习数学知识点清单"><a href="#深度学习数学知识点清单" class="headerlink" title="深度学习数学知识点清单"></a>深度学习数学知识点清单</h2><p>根据原文：<a href="https://www.toutiao.com/a6512350234847216131/?tt_from=weixin&utm_campaign=client_share&timestamp=1526260721&app=news_article_lite&utm_source=weixin&iid=32124935768&utm_medium=toutiao_android&wxshare_count=1">机器学习数学篇—基础数学知识清单</a> 进行修改和补充</p><hr><p>说明：字体加粗表示该知识点很重要，需要重点掌握</p><h3 id="一-线性代数"><a href="#一-线性代数" class="headerlink" title="一. 线性代数"></a><a href="https://github.com/huxiaoman7/learningdl/blob/master/Chapter2/notes/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.md#%E4%B8%80-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"></a>一. 线性代数</h3><ul><li><p>向量</p></li><li><p>矩阵</p></li><li><p>集合</p></li><li><p>标量</p></li><li><p>张量</p></li><li><p>范数</p></li><li><p>内积</p></li><li><p>向量正交</p></li><li><p>正交基</p></li><li><p><strong>特征值分解</strong></p></li><li><p><strong>奇异值分解</strong></p></li><li><p><strong>矩阵分解</strong></p></li><li><p>总结:前面的都是基础概念性的内容，后面的三个分解很重要，奇异值分解也属于矩阵分解里的一种，在很多应用中其实都会用到，譬如推荐系统，主题模型等。在一些其他的算法思想里其实也有用到，我们求特征向量的时候，其实也是在做特征值分解，主成分分析&#x2F;因子分析 其实都用到了矩阵分解。尤其是当数据量比较小的时候，可以先不上深度学习，先用简单又基础的方法试一下，看看效果怎么样，作为baseline，加大数据集后，再采取更深层次的算法来做。</p></li></ul><h3 id="二-概率论"><a href="#二-概率论" class="headerlink" title="二. 概率论"></a><a href="https://github.com/huxiaoman7/learningdl/blob/master/Chapter2/notes/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.md#%E4%BA%8C-%E6%A6%82%E7%8E%87%E8%AE%BA"></a>二. 概率论</h3><ul><li><p><strong>条件概率</strong></p></li><li><p><strong>联合概率</strong></p></li><li><p><strong>全概率公式</strong></p></li><li><p>逆概率</p></li><li><p><strong>贝叶斯公式</strong></p></li><li><p><strong>贝叶斯定理</strong></p></li><li><p>先验概率</p></li><li><p>后验概率</p></li><li><p><strong>似然概率</strong></p></li><li><p><strong>最大似然估计法</strong></p></li><li><p>最大后验概率法</p></li><li><p>离散型随机变量</p></li><li><p>连续型随机变量</p></li><li><p>概率质量函数</p></li><li><p>概率密度函数</p></li><li><p>两点分布</p></li><li><p>二项分布</p></li><li><p><strong>泊松分布</strong></p></li><li><p>均匀分布</p></li><li><p>指数分布</p></li><li><p>正态分布</p></li><li><p>数字特征</p></li><li><p>数学期望</p></li><li><p>方差</p></li><li><p>协方差</p></li><li><p>总结:概率论的内容也非常重要，掌握好了才能理解我们在机器学习&#x2F;深度学习里经常出现的一些概念。它包含在我们算法的很多方面，譬如，数据是否符合正态分布&#x2F;泊松分布，什么情况下可以用最大似然估计法等等，贝叶斯的定理除了运用在贝叶斯算法中，还有没有其他的算法有运用到这个思想的，条件概率个联合概率等，在后续的信息论出现的作用是什么？都需要我们队每个知识点好好掌握。重点掌握我加粗的知识点。</p></li></ul><h3 id="三-数理统计"><a href="#三-数理统计" class="headerlink" title="三. 数理统计"></a><a href="https://github.com/huxiaoman7/learningdl/blob/master/Chapter2/notes/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.md#%E4%B8%89-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1"></a>三. 数理统计</h3><ul><li><p>样本</p></li><li><p>总体</p></li><li><p>统计量</p></li><li><p>参数估计</p></li><li><p>假设检验</p></li><li><p>置信区间</p></li><li><p>区间估计</p></li><li><p><strong>泛化能力</strong></p></li><li><p><strong>泛化误差</strong></p></li><li><p><strong>欠拟合</strong></p></li><li><p><strong>过拟合</strong></p></li><li><p><strong>噪声</strong></p></li><li><p><strong>偏差</strong></p></li><li><p>总结:同样，前面是基础知识，后面的几点更为关键。泛化能力和泛化误差是我们衡量这个模型跑完了能否拿到实际场景中去应用的一个重要指标;欠拟合 or 过拟合 也是我们在模型训练的过程中需要注意和解决的两点;偏差方差等也属于评价指标，我们需要达到一个trade-off，所以如何平衡也是需要关注的。其实也可以这样看，如果数据中出现了噪音，迭代次数过少（或者一些其他原因），导致模型欠拟合，那么它的偏差大，方差小，如果过拟合，则偏差小，方差大，不管哪种情况，这个模型的泛化能力都不行，没法拿到真实场景中去用，所以我们需要对其进行调整，这个时候我们就会关注到数据本身和模型调参上。数据本身如果有噪音和异常点应该如何找到并去除，模型跳槽应该如何避免欠拟合和过拟合，都是我们在掌握这些知识点时需要重点关注的点。</p></li></ul><h3 id="四-优化相关"><a href="#四-优化相关" class="headerlink" title="四. 优化相关"></a><a href="https://github.com/huxiaoman7/learningdl/blob/master/Chapter2/notes/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.md#%E5%9B%9B-%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3"></a>四. 优化相关</h3><ul><li><p><strong>目标函数</strong></p></li><li><p><strong>全局最小值</strong></p></li><li><p><strong>局部极小值</strong></p></li><li><p><strong>无约束优化</strong></p></li><li><p><strong>约束优化</strong></p></li><li><p><strong>拉格朗日函数</strong></p></li><li><p><strong>KKT条件与对偶函数</strong></p></li><li><p><strong>梯度下降法</strong></p></li><li><p><strong>一阶导数</strong></p></li><li><p>二阶导数</p></li><li><p><strong>牛顿法</strong></p></li><li><p><strong>泰勒展开</strong></p></li><li><p>线性搜索方法</p></li><li><p>置信域方法</p></li><li><p>启发式算法</p></li><li><p>总结:优化部分的内容也是非常重要的一环。当我们设定了目标函数后，就会采取各种优化算法来去优化目标函数的值，使目标函数的值最小(&#x2F;最大，一般是最小，根据具体情况而定)，如何使目标函数的值下降的最快，这时我们就引出了梯度下降，因为沿着负梯度下降的方向是函数值减小的最快方向，由此我们可以引出多种梯度下降的方法，包括批梯度，随机梯度，mini-batch等等。当然，这是针对一阶函数优化来说的，如果是二阶函数，我们就会考虑到用牛顿法，什么时候会出现二阶函数呢？在xgboost里针对目标函数的优化我们就会涉及到二阶函数的优化。而在这些优化函数的计算中，都会涉及到泰勒展开，在SVM里又会因为要求支持向量所以会引出拉格朗日乘子法和KKT条件，从一点去发散，我们可以发现很多知识点。所以在针对具体的算法学习过程中再去掌握这些数学知识点，高效而且有用。在深度学习中涉及到的优化算法相对就少一些，没有机器学习里的那么多，但是这些基础性的东西还是需要掌握的。</p></li></ul><h3 id="五-信息论"><a href="#五-信息论" class="headerlink" title="五.信息论"></a><a href="https://github.com/huxiaoman7/learningdl/blob/master/Chapter2/notes/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86.md#%E4%BA%94%E4%BF%A1%E6%81%AF%E8%AE%BA"></a>五.信息论</h3><ul><li><p><strong>信息熵</strong></p></li><li><p><strong>互信息</strong></p></li><li><p><strong>信息增益</strong></p></li><li><p><strong>KL 散度</strong></p></li><li><p><strong>最大熵原理</strong></p></li><li><p><strong>交叉熵和相对熵的对比</strong></p></li><li><p><strong>各种熵之间的关系</strong></p></li><li><p>总结：信息论这一章非常重要，基本上每个知识点都是重点，因为很多情况下我们都会使用交叉熵作为损失函数，所以得弄明白它的原理和为什么我们经常使用它做损失函数的原因。对于一些特殊的情况，可以做出哪些变型，也是在掌握了这些基础上才会做的，所以大家要好好掌握。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法-机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-机器学习—特征工程</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>详细pdf:<br>链接：<a href="https://pan.baidu.com/s/1pUWhb_y7kK7_fU0Gjqfe0Q">https://pan.baidu.com/s/1pUWhb_y7kK7_fU0Gjqfe0Q</a> 密码：602l<br>sklearn中的特征工程：<a href="https://www.cnblogs.com/jasonfreak/p/5619260.html">https://www.cnblogs.com/jasonfreak/p/5619260.html</a></p><p>特征工程实则是数据深度清洗过程</p><h1 id="1-数据清洗"><a href="#1-数据清洗" class="headerlink" title="1.数据清洗"></a>1.数据清洗</h1><blockquote><p>a. 数据格式化（日期，数值格式化）<br>b. 脏数据清洗（不合理数据）<br>c. 缺失值处理方案<br> 方案一 : 如果缺失值的样本占总数比例行高，可直接舍弃该字段，反倒成为噪声<br> 方案二 : 如果缺失值的样本占总数比例适中，且该字段是离散型值，将缺失值作为新的一类<br> 方案三：如果缺失值的样本占总数比例适中，且该字段是连续型数值，将数值离散化处理，将缺失值作为新的一类<br> 方案四: 如果缺失值得样本占总数比例较少，可根据已有的值，拟合一定的数据补充上</p></blockquote><h1 id="2-数据采样"><a href="#2-数据采样" class="headerlink" title="2.数据采样"></a>2.数据采样</h1><blockquote><p> . 采样方式<br> 1.随机采样<br> 2.分层采样<br>. 正负样本不平衡处理办法<br> 1.上采样（量大）<br> 2.下采样（量小）</p></blockquote><h1 id="3-特征处理"><a href="#3-特征处理" class="headerlink" title="3.特征处理"></a>3.特征处理</h1><p>1.数值型</p><blockquote><p> <img src="https://upload-images.jianshu.io/upload_images/3451200-c7203c891b7749fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>2. 类别型<br> <img src="https://upload-images.jianshu.io/upload_images/3451200-164c64b89d26e767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>3. 时间型<br> <img src="https://upload-images.jianshu.io/upload_images/3451200-be26a1935676715a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>4. 文本型<br> <img src="https://upload-images.jianshu.io/upload_images/3451200-f83c278792976004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br> <img src="https://upload-images.jianshu.io/upload_images/3451200-4054787dade388a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>5. 统计型<br> <img src="https://upload-images.jianshu.io/upload_images/3451200-5aa5f1ca2542f505.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>6. 组合类型<br> <img src="https://upload-images.jianshu.io/upload_images/3451200-60441cc3ee2ac07e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><h1 id="4-特征选择"><a href="#4-特征选择" class="headerlink" title="4.特征选择"></a>4.特征选择</h1><blockquote><p>过滤型<br>包裹型<br>嵌入型</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法-机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-机器学习—路线图</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>机器学习数据处理步骤：</p><h1 id="机器学习基础与实践（一）—-数据清洗"><a href="#机器学习基础与实践（一）—-数据清洗" class="headerlink" title="机器学习基础与实践（一）—-数据清洗"></a><a href="https://www.cnblogs.com/charlotte77/p/5606926.html">机器学习基础与实践（一）—-数据清洗</a></h1><h1 id="机器学习基础与实践（二）—-数据转换"><a href="#机器学习基础与实践（二）—-数据转换" class="headerlink" title="机器学习基础与实践（二）—-数据转换"></a><a href="https://www.cnblogs.com/charlotte77/p/5622325.html">机器学习基础与实践（二）—-数据转换</a></h1><h1 id="机器学习基础与实践（三）—-数据降维之PCA"><a href="#机器学习基础与实践（三）—-数据降维之PCA" class="headerlink" title="机器学习基础与实践（三）—-数据降维之PCA"></a><a href="https://www.cnblogs.com/charlotte77/p/5625984.html">机器学习基础与实践（三）—-数据降维之PCA</a></h1><p>基本机器学习算法推导：<br>决策树：<a href="https://blog.csdn.net/yen_csdn/article/details/79012871">https://blog.csdn.net/yen_csdn/article/details/79012871</a><br>KNN分类：<a href="http://www.cnblogs.com/bahcelor/p/7239997.html">http://www.cnblogs.com/bahcelor/p/7239997.html</a><br>SVM:<a href="https://blog.csdn.net/zxllll8898/article/details/53404484">https://blog.csdn.net/zxllll8898/article/details/53404484</a><br>神经网络：<a href="https://www.cnblogs.com/bahcelor/p/7252394.html">https://www.cnblogs.com/bahcelor/p/7252394.html</a><br>K-means：<a href="https://blog.csdn.net/loveliuzz/article/details/78052711">https://blog.csdn.net/loveliuzz/article/details/78052711</a><br>卷积神经网络：<a href="https://www.cnblogs.com/skyfsm/p/6790245.html">https://www.cnblogs.com/skyfsm/p/6790245.html</a></p><p>深度学习推导：<br><a href="https://www.zybuluo.com/hanbingtao/note/433855">零基础入门深度学习(1) - 感知器</a> <br><a href="https://www.zybuluo.com/hanbingtao/note/448086">零基础入门深度学习(2) - 线性单元和梯度下降</a> <br><a href="https://www.zybuluo.com/hanbingtao/note/476663">零基础入门深度学习(3) - 神经网络和反向传播算法</a> <br><a href="https://www.zybuluo.com/hanbingtao/note/485480">零基础入门深度学习(4) - 卷积神经网络</a> <br><a href="https://zybuluo.com/hanbingtao/note/541458">零基础入门深度学习(5) - 循环神经网络</a> <br><a href="https://zybuluo.com/hanbingtao/note/581764">零基础入门深度学习(6) - 长短时记忆网络(LSTM)</a> <br><a href="https://zybuluo.com/hanbingtao/note/626300">零基础入门深度学习(7) - 递归神经网络</a></p><p>难点：<br>pca降维推导：<a href="https://www.cnblogs.com/tbiiann/p/6259459.html">https://www.cnblogs.com/tbiiann/p/6259459.html</a><br>svd分解推导：<a href="https://www.cnblogs.com/tbiiann/p/6262397.html">https://www.cnblogs.com/tbiiann/p/6262397.html</a><br>机器学习中的距离：<a href="https://www.cnblogs.com/tbiiann/p/5968784.html">https://www.cnblogs.com/tbiiann/p/5968784.html</a><br>最小二乘法法推导：<a href="https://www.cnblogs.com/paiandlu/p/7843236.html">https://www.cnblogs.com/paiandlu/p/7843236.html</a><br>svm手推：<a href="https://blog.csdn.net/v_july_v/article/details/7624837">https://blog.csdn.net/v_july_v/article/details/7624837</a><br>kkt条件解释：<a href="https://www.cnblogs.com/liaohuiqiang/p/7805954.html">https://www.cnblogs.com/liaohuiqiang/p/7805954.html</a><br>gbdt：<a href="https://blog.csdn.net/lyzmyy/article/details/45665105?utm_source=blogxgwz3">https://blog.csdn.net/lyzmyy/article/details/45665105?utm_source=blogxgwz3</a><br>或者 <a href="https://blog.csdn.net/v_july_v/article/details/40718799">https://blog.csdn.net/v_july_v/article/details/40718799</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法-机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++指针</title>
      <link href="/2025/05/18/%E8%AF%AD%E8%A8%80-cpp-%E6%8C%87%E9%92%88/"/>
      <url>/2025/05/18/%E8%AF%AD%E8%A8%80-cpp-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="c-指针"><a href="#c-指针" class="headerlink" title="c++指针"></a>c++指针</h2><h3 id="Gerneral"><a href="#Gerneral" class="headerlink" title="Gerneral"></a>Gerneral</h3><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><ol><li>先定义函数</li><li>再定义函数指针 &#x3D;&gt; 返回值 （<em>）(参数类型1,参数类型2, …) 或者 返回值 （</em>ptrFunc）(参数类型1,参数类型2, …)</li></ol><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><ol><li>在函数申明加 inline</li><li>或在函数定义加 inline</li></ol><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><ol><li>#define S(num) num*num <ul><li>int result&#x3D;S(10+5) &#x3D;&#x3D;&gt; int result&#x3D;10+5*10+5  (结果65，和预期不一样)</li></ul></li></ol><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ol><li>不可以直接引用常量,可以使用常量的引用  const double&amp; d&#x3D;12.3</li><li>引用并非对象，只是已存在对象的一个别名</li><li>引用更接近const指针，一旦与某变量关联起来，就将一直效忠与它</li><li>将引用变量用作参数，函数将使用原始数据，而非副本</li><li>当数据所在内存比较大，建议使用引用</li><li>返回引用1：函数中不要返回局部变量的引用，因为局部变量回回收，可能被别人使用</li><li>返回引用2: 函数可以不返回值，默认返回传入的应用对象本身（最后一个计算）</li><li>返回引用3: 要求函数参数中包含返回的引用对象</li><li>引用bug<ul><li>解决办法是将返回类型改为const int&amp; （int &amp;num1,&amp;num2） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num=10</span><br><span class="line">int&amp; result=sum(num);</span><br><span class="line">sum(num)=55;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="默认的参数"><a href="#默认的参数" class="headerlink" title="默认的参数"></a>默认的参数</h4><ol><li>默认参数和参数不能交替出现</li></ol><h4 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h4><ol><li>函数定义时不指定具体的数据类型（用虚拟类型代替）</li><li>函数被调用时编译器根据实参反推数据类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename arg1,typename arg2,...&gt;</span><br><span class="line">返回值类型 函数名称()&#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="c-中的类"><a href="#c-中的类" class="headerlink" title="c++中的类"></a>c++中的类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Land&#123;</span><br><span class="line">public:</span><br><span class="line">    Land();</span><br><span class="line">    ~Land();</span><br><span class="line">    String name;</span><br><span class="line">    long score;</span><br><span class="line">    int cards[10];</span><br><span class="line"></span><br><span class="line">    void TouchCard(int[]);</span><br><span class="line">    bool PlayCard(int[]);</span><br><span class="line">    void ShowScore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>访问修饰符，默认是private</li><li>构造函数</li><li>this返回当前对象的引用 return *this</li></ol><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><ol><li>使用operator 修饰符修饰</li></ol><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ol><li>const 修饰谁，谁就不能被修改</li><li>const返回值，如果返回局部变量，返回值就不能是&amp; 引用。若要是返回引用，就不能返回局部变量</li></ol><h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><ol><li>对象复制 str2&#x3D;str1 是浅复制，str对象有指针，只是复制了指针，修改指针的内容，两个都会变</li><li>因此需要重载赋值运算</li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li>自动类型转换</li><li>强制类型转换</li><li>其他类型转换为当前类型</li><li>当前类型转化为其他类型 operator type(){return XXX}</li></ol><h4 id="继承多态"><a href="#继承多态" class="headerlink" title="继承多态"></a>继承多态</h4><ol><li>基类引用指向派生类 People&amp; people&#x3D; peo</li><li>基类指针指向派生类 People* people&#x3D; &amp;peo</li><li>父类引用&#x2F;指针指向子类  Man&amp; man&#x3D;(Man&amp;)people</li></ol>]]></content>
      
      
      <categories>
          
          <category> code-c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存调优</title>
      <link href="/2025/05/18/%E8%AF%AD%E8%A8%80-java-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/"/>
      <url>/2025/05/18/%E8%AF%AD%E8%A8%80-java-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p>常见配置汇总</p><p>堆设置</p><p>   -Xmn:新生代大小 占堆大小1&#x2F;3或1&#x2F;4</p><p>   -Xms:初始堆大小</p><p>   -Xmx:最大堆大小</p><p>   -XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4</p><p>   -XX:SurvivorRatio&#x3D;n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor&#x3D;3：2，一个Survivor区占整个年轻代的1&#x2F;5</p><p>   -XX:MaxPermSize&#x3D;n:设置持久代大小</p><p>栈设置<br>    -Xss1m 栈大小</p><p>收集器设置</p><p>-XX:+UseSerialGC:设置串行收集器</p><p>-XX:+UseParallelGC:设置并行收集器</p><p>-XX:+UseParalledlOldGC:设置并行年老代收集器</p><p>-XX:+UseConcMarkSweepGC:设置并发收集器</p><p>垃圾回收统计信息</p><p>-XX:+PrintGC</p><p>-XX:+PrintGCDetails</p><p>-XX:+PrintGCTimeStamps</p><p>-Xloggc:filename</p><p>并行收集器设置</p><p>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数。</p><p>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大暂停时间</p><p>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</p><p>并发收集器设置</p><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p><p>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p><p>OOM<br>    -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath&#x3D;${目录}。溢出分析</p>]]></content>
      
      
      <categories>
          
          <category> code-java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 虚拟机</title>
      <link href="/2025/05/18/%E8%AF%AD%E8%A8%80-java-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2025/05/18/%E8%AF%AD%E8%A8%80-java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-虚拟机"><a href="#JVM-虚拟机" class="headerlink" title="JVM 虚拟机"></a>JVM 虚拟机</h1><!-- TOC --><ul><li><ol><li>General</li></ol></li><li><ol start="2"><li>jvm架构</li></ol><ul><li>2.1. 类装载流程</li><li>2.2. 安全性<ul><li>2.2.1. 双亲委派机制</li><li>2.2.2. 沙箱机制</li></ul></li><li>2.3. 栈<ul><li>2.3.1. 方法栈</li><li>2.3.2. 本地方法栈</li></ul></li><li>2.4. 堆 （重GC&#x2F;fullGC;发生在新生区和年老区）<ul><li>2.4.1. 新生代 （轻GC&#x2F;minorGC）<ul><li>2.4.1.1. Eden区</li><li>2.4.1.2. 存活区</li></ul></li><li>2.4.2. 年老代 （MojorGC）</li><li>2.4.3. 元空间</li></ul></li><li>2.5. jvm调优<ul><li>2.5.1. 调优基础知识</li></ul></li><li>2.6. 内存溢出异常</li></ul></li><li><ol start="3"><li>垃圾收集</li></ol><ul><li>3.1. 垃圾判断方法<ul><li>3.1.1. 引用计数法</li><li>3.1.2. 可达性分析</li></ul></li><li>3.2. 垃圾回收算法<ul><li>3.2.1. 复制算法</li><li>3.2.2. 标记清除法</li><li>3.2.3. 标记整理</li></ul></li><li>3.3. 垃圾回收算法总结</li></ul></li></ul><!-- /TOC --><h2 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h2><ul><li>双亲委派机制</li><li>jvm体系结构</li><li>堆的组成</li><li>垃圾回收机制</li><li>jvm调优</li></ul><h2 id="2-jvm架构"><a href="#2-jvm架构" class="headerlink" title="2. jvm架构"></a>2. jvm架构</h2><p>processon jvm架构图 <a href="https://www.processon.com/view/5ea7a1b9e401fd21c196eb17">https://www.processon.com/view/5ea7a1b9e401fd21c196eb17</a></p><h3 id="2-1-类装载流程"><a href="#2-1-类装载流程" class="headerlink" title="2.1. 类装载流程"></a>2.1. 类装载流程</h3><blockquote><ul><li>核心：加载 &gt; 链接 &gt; 初始化</li></ul></blockquote><h3 id="2-2-安全性"><a href="#2-2-安全性" class="headerlink" title="2.2. 安全性"></a>2.2. 安全性</h3><h4 id="2-2-1-双亲委派机制"><a href="#2-2-1-双亲委派机制" class="headerlink" title="2.2.1. 双亲委派机制"></a>2.2.1. 双亲委派机制</h4><p><img src="https://wx3.sinaimg.cn/mw690/005EpKr8ly1g3w3bn8f69j30gs0bpq47.jpg" alt="类加载器"></p><blockquote><ol><li>引导类加载器 rt.jar</li><li>扩展类加载器 ext目录下</li><li>应用程序类加载器 classpath</li><li>自定义类加载器 extend classloader</li></ol></blockquote><h4 id="2-2-2-沙箱机制"><a href="#2-2-2-沙箱机制" class="headerlink" title="2.2.2. 沙箱机制"></a>2.2.2. 沙箱机制</h4><blockquote><ul><li>字节码校验：确保java类文件准守java语言规范</li><li>类加载器：双亲委派机制 （虚拟机为不同的类加载器载入的类提供不同的命名空间，每个空间都是独立的）</li><li>存取控制器： 控制核心api对操作系统的存取权限</li><li>安全管理器： 是核心api和操作系统之间的主要接口</li><li>完全软件包： 包含安全提供者，消息摘要，数字签名，加密，鉴别</li></ul></blockquote><h3 id="2-3-栈"><a href="#2-3-栈" class="headerlink" title="2.3. 栈"></a>2.3. 栈</h3><h4 id="2-3-1-方法栈"><a href="#2-3-1-方法栈" class="headerlink" title="2.3.1. 方法栈"></a>2.3.1. 方法栈</h4><blockquote><ul><li>栈是由栈帧构成，每一个栈帧就可以看作一个函数</li><li>栈帧里主要包含里引用，8大基本类型，父栈引用，子栈引用</li></ul></blockquote><h4 id="2-3-2-本地方法栈"><a href="#2-3-2-本地方法栈" class="headerlink" title="2.3.2. 本地方法栈"></a>2.3.2. 本地方法栈</h4><blockquote><ul><li>本地方法栈指native修饰的方法，它直接调用本地方法接口，接着调用本地方法库</li></ul></blockquote><h3 id="2-4-堆-（重GC-fullGC-发生在新生区和年老区）"><a href="#2-4-堆-（重GC-fullGC-发生在新生区和年老区）" class="headerlink" title="2.4. 堆 （重GC&#x2F;fullGC;发生在新生区和年老区）"></a>2.4. 堆 （重GC&#x2F;fullGC;发生在新生区和年老区）</h3><p>年轻代：年老代 &#x3D; 1:2<br>Eden : from: to &#x3D; 8: 1: 1</p><h4 id="2-4-1-新生代-（轻GC-minorGC）"><a href="#2-4-1-新生代-（轻GC-minorGC）" class="headerlink" title="2.4.1. 新生代 （轻GC&#x2F;minorGC）"></a>2.4.1. 新生代 （轻GC&#x2F;minorGC）</h4><h5 id="2-4-1-1-Eden区"><a href="#2-4-1-1-Eden区" class="headerlink" title="2.4.1.1. Eden区"></a>2.4.1.1. Eden区</h5><blockquote><ul><li>Eden区是创建对象最开始存放的区间 如：new Student()</li></ul></blockquote><h5 id="2-4-1-2-存活区"><a href="#2-4-1-2-存活区" class="headerlink" title="2.4.1.2. 存活区"></a>2.4.1.2. 存活区</h5><blockquote><ul><li>存活区有两个，一个0和1区</li><li>这两个区的大小比例&#x3D;1:1</li></ul></blockquote><h4 id="2-4-2-年老代-（MojorGC）"><a href="#2-4-2-年老代-（MojorGC）" class="headerlink" title="2.4.2. 年老代 （MojorGC）"></a>2.4.2. 年老代 （MojorGC）</h4><h4 id="2-4-3-元空间"><a href="#2-4-3-元空间" class="headerlink" title="2.4.3. 元空间"></a>2.4.3. 元空间</h4><blockquote><ul><li>1.8以前都叫永久代，存放的java运行时的环境等等</li><li>存放的是方法区（方法区里有常量池）</li></ul></blockquote><h3 id="2-5-jvm调优"><a href="#2-5-jvm调优" class="headerlink" title="2.5. jvm调优"></a>2.5. jvm调优</h3><p>jvm调优发生在堆中，只有堆中才存在垃圾</p><h4 id="2-5-1-调优基础知识"><a href="#2-5-1-调优基础知识" class="headerlink" title="2.5.1. 调优基础知识"></a>2.5.1. 调优基础知识</h4><blockquote><ol><li>总分配的内存是电脑内存（Xmx） &#x3D; 1:4 （默认）</li><li>初始化内存是电脑内存（Xms） &#x3D; 1:64 （默认）</li><li>OOM解决思路（尝试扩大堆大小，其次分析代码）或 （-Xms8m -Xmx8m -XX:+printGCDetails）</li><li>初始化堆 &#x3D; 新生代 + 年老代 + （元空间?:逻辑上存在，物理上不存在,也叫非堆）</li></ol></blockquote><h3 id="2-6-内存溢出异常"><a href="#2-6-内存溢出异常" class="headerlink" title="2.6. 内存溢出异常"></a>2.6. 内存溢出异常</h3><blockquote><ol><li>线程请求的最大深度 &gt; 虚拟机中所允许的最大深度 StackOverflowError（包含虚拟机栈，本地方法栈）</li><li>方法区和运行常量池溢出 java.lang.OutOfMemoryError: PermGen space </li><li>Java堆溢出 java.lang.OutOfMemoryError: Java heap space </li><li>本机直接内存溢出  java.lang.OutOfMemoryError</li></ol></blockquote><h2 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3. 垃圾收集"></a>3. 垃圾收集</h2><h3 id="3-1-垃圾判断方法"><a href="#3-1-垃圾判断方法" class="headerlink" title="3.1. 垃圾判断方法"></a>3.1. 垃圾判断方法</h3><h4 id="3-1-1-引用计数法"><a href="#3-1-1-引用计数法" class="headerlink" title="3.1.1. 引用计数法"></a>3.1.1. 引用计数法</h4><h4 id="3-1-2-可达性分析"><a href="#3-1-2-可达性分析" class="headerlink" title="3.1.2. 可达性分析"></a>3.1.2. 可达性分析</h4><h3 id="3-2-垃圾回收算法"><a href="#3-2-垃圾回收算法" class="headerlink" title="3.2. 垃圾回收算法"></a>3.2. 垃圾回收算法</h3><h4 id="3-2-1-复制算法"><a href="#3-2-1-复制算法" class="headerlink" title="3.2.1. 复制算法"></a>3.2.1. 复制算法</h4><blockquote><ul><li>Eden区进过GC后，对象会移动到存活to区</li><li>jvm复制算法主要指存活from区将对象移动复制到to区</li><li>经过15次GC都没有被回收的对象会进入到年老区</li></ul></blockquote><h4 id="3-2-2-标记清除法"><a href="#3-2-2-标记清除法" class="headerlink" title="3.2.2. 标记清除法"></a>3.2.2. 标记清除法</h4><blockquote><ol><li>循环每一块内存，对象在使用设个标志</li><li>循环每一块内存，清空没有使用的对象</li></ol></blockquote><h4 id="3-2-3-标记整理"><a href="#3-2-3-标记整理" class="headerlink" title="3.2.3. 标记整理"></a>3.2.3. 标记整理</h4><blockquote><ol><li>循环每一块内存，对象在使用设个标志</li><li>循环每一块内存，清空没有使用的对象</li><li>将内存对象移动到一起，空的内存也整理到一起</li></ol></blockquote><h3 id="3-3-垃圾回收算法总结"><a href="#3-3-垃圾回收算法总结" class="headerlink" title="3.3. 垃圾回收算法总结"></a>3.3. 垃圾回收算法总结</h3><p>时间复杂度：复制算法 &gt; 标记清除法 &gt; 标记整理<br>空间复杂度：标记清除法 &#x3D; 标记整理 &gt; 复制算法</p><p>垃圾回收目前是采用分代回收最合适，年轻代采用复制算法，年老代采用标记整理</p>]]></content>
      
      
      <categories>
          
          <category> code-java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的锁</title>
      <link href="/2025/05/18/%E8%AF%AD%E8%A8%80-java-%E9%94%81/"/>
      <url>/2025/05/18/%E8%AF%AD%E8%A8%80-java-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="锁宏观与微观"><a href="#锁宏观与微观" class="headerlink" title="锁宏观与微观"></a>锁宏观与微观</h1><ol><li>悲观锁<br> 重量级锁</li><li>乐观锁<br> 自旋锁<br> 避免用户线程和内核的切换的消耗,无需进入阻塞状态挂起<br> 参数设置：<br>     JDK1.6中-XX:+UseSpinning开启；<br>     -XX:PreBlockSpin&#x3D;10 为自旋次数；<br>     JDK1.7后，去掉此参数，由jvm控制；<br> 轻量级锁<br> 轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；<br> 偏向锁<br> 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁</li></ol><p>总结：</p><pre><code>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；偏向锁是在无锁争用的情况下使用的，也就是同步开在当前线程没有执行完之前，没有其它线程会执行该同步块，一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，如果轻量级锁自旋到达阈值后，没有获取到锁，就会升级为重量级锁；</code></pre><h1 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a>java锁</h1><ol><li>synchronized 重量级锁</li><li>ReentranteLock 重入锁</li><li>ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写；</li></ol><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>解释：当多线程访问容器里不同数据段的数据时，线程间锁竞争压力小，从而可以有效的提高并发访问效率</p>]]></content>
      
      
      <categories>
          
          <category> code-java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-ios-工具说明</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-IOS-%E5%B7%A5%E5%85%B7%E8%AF%B4%E6%98%8E/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-IOS-%E5%B7%A5%E5%85%B7%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>逆向-ios-工具说明</del></p></blockquote><h1 id="IOS逆向工具说明"><a href="#IOS逆向工具说明" class="headerlink" title="IOS逆向工具说明"></a>IOS逆向工具说明</h1><!-- TOC --><ul><li><ol><li>General</li></ol><ul><li>1.1. 查看是否加固 （otool -l XXX | grep crypt）</li><li>1.2. 查看CPU架构 （lipo -info XXX）</li><li>1.3. 砸壳工具<ul><li>1.3.1. Dumpdecrypted砸壳</li><li>1.3.2. Clutch</li><li>1.3.3. frida-ios-dump</li></ul></li></ul></li><li><ol start="2"><li>首次IOS逆向<ul><li>2.1. 刷机工具</li><li>2.2. 越狱后常用的工具</li><li>2.3. mac端常用工具</li><li>2.4. 抖音越狱案例</li><li>2.5. debugserver 动态调试</li></ul></li></ol></li><li><ol start="3"><li>IOS 逆向流程总结</li></ol></li><li><ol start="4"><li>批量刷机经历</li></ol><ul><li>4.1. uncOver (12 到 13.5)</li><li>4.2. checkra1n 最新版 （13.5及以后）</li><li>4.3. cd &#x2F;private&#x2F;var&#x2F;mobile&#x2F;Media&#x2F;general_storage&#x2F;iOS13&#x2F;</li><li>4.4. chmod +x install.sh</li></ul></li></ul><!-- /TOC --><h2 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h2><p>常用工具命令积累</p><h3 id="1-1-查看是否加固-（otool-l-XXX-grep-crypt）"><a href="#1-1-查看是否加固-（otool-l-XXX-grep-crypt）" class="headerlink" title="1.1. 查看是否加固 （otool -l XXX | grep crypt）"></a>1.1. 查看是否加固 （otool -l XXX | grep crypt）</h3><h3 id="1-2-查看CPU架构-（lipo-info-XXX）"><a href="#1-2-查看CPU架构-（lipo-info-XXX）" class="headerlink" title="1.2. 查看CPU架构 （lipo -info XXX）"></a>1.2. 查看CPU架构 （lipo -info XXX）</h3><h3 id="1-3-砸壳工具"><a href="#1-3-砸壳工具" class="headerlink" title="1.3. 砸壳工具"></a>1.3. 砸壳工具</h3><h4 id="1-3-1-Dumpdecrypted砸壳"><a href="#1-3-1-Dumpdecrypted砸壳" class="headerlink" title="1.3.1. Dumpdecrypted砸壳"></a>1.3.1. Dumpdecrypted砸壳</h4><ol><li>下载编译dumpdecrypted</li><li>找到Documents目录,拷贝到其下<ul><li>cycript -p pid</li></ul></li><li>注入dylib</li><li>指定Bundle id注入</li></ol><h4 id="1-3-2-Clutch"><a href="#1-3-2-Clutch" class="headerlink" title="1.3.2. Clutch"></a>1.3.2. Clutch</h4><p>clutch -b BundleId</p><ol><li>scp Clutch-2.0.4 <a href="mailto:&#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#46;&#x31;&#x2e;&#49;&#54;&#x38;">&#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#46;&#x31;&#x2e;&#49;&#54;&#x38;</a>:&#x2F;usr&#x2F;bin&#x2F;</li><li>chmod +x Clutch-2.0.4</li><li>Clutch-2.0.4 -i</li><li>Clutch-2.0.4 -d 2</li><li>Clutch-2.0.4 -b com.ss.iphone.ugc.Aweme</li></ol><h4 id="1-3-3-frida-ios-dump"><a href="#1-3-3-frida-ios-dump" class="headerlink" title="1.3.3. frida-ios-dump"></a>1.3.3. frida-ios-dump</h4><ol><li>准备好安装好frida的手机，这一步比较坑，系统，越狱工具，Frida版本都要考虑</li><li>iproxy 2222 22 (brew install usbmuxd)</li><li>python dump.py -l （咋壳ipa）</li></ol><h2 id="2-首次IOS逆向"><a href="#2-首次IOS逆向" class="headerlink" title="2. 首次IOS逆向"></a>2. 首次IOS逆向</h2><h4 id="2-1-刷机工具"><a href="#2-1-刷机工具" class="headerlink" title="2.1. 刷机工具"></a>2.1. 刷机工具</h4><blockquote><p>checkra1n (注意版本) 目前我的手机是12.4.8系统 用的checkra1n version beta 0.9.7</p></blockquote><h4 id="2-2-越狱后常用的工具"><a href="#2-2-越狱后常用的工具" class="headerlink" title="2.2. 越狱后常用的工具"></a>2.2. 越狱后常用的工具</h4><blockquote><p>OpenSSH<br>APPStroe++ 应用降级 (可以安装低版本软件) 注意要关闭app store 的自动跟新，不然会失效<br>Substrate Safe Mode (越狱手机下动态库位置)<br>Cycript (动态调试相关)<br>    * cycript -p pid<br>    * [[NSBundle mainBundle] bundleIdentifier]<br>    *<br>frida 安装（注意：我的12.4.8手机安装frida 是12.6.16. 安装命令是：dpkg -i xxx.deb）</p></blockquote><h4 id="2-3-mac端常用工具"><a href="#2-3-mac端常用工具" class="headerlink" title="2.3. mac端常用工具"></a>2.3. mac端常用工具</h4><blockquote><p>Transmit</p></blockquote><h4 id="2-4-抖音越狱案例"><a href="#2-4-抖音越狱案例" class="headerlink" title="2.4. 抖音越狱案例"></a>2.4. 抖音越狱案例</h4><ol><li>代码编译 需要证书和秘要(注意秘要时间)</li><li>找到aweme.dylib 放入到手机&#x2F;Library&#x2F;MobileSubstrate下</li><li>&#x2F;Library&#x2F;MobileSubstrate 同目录下编写aweme.plist 文件</li><li>下载 * external_identifier: “834078818”,   &#x2F;&#x2F;9.2.1 这个版本抖音安装（APPStroe++ 协助完成  manual instal）</li></ol><h4 id="2-5-debugserver-动态调试"><a href="#2-5-debugserver-动态调试" class="headerlink" title="2.5. debugserver 动态调试"></a>2.5. debugserver 动态调试</h4><ol><li>随便使用xcode运行应用，会在ios 端 &#x2F;Developer&#x2F;usr&#x2F;bin 下生成一个debugserver</li><li>拷贝出debugserver 重新签名<ul><li>ldid -e debugserver &gt; debuger.entitlements</li><li>使用Xcode添加权限  get-task-allow，task_for_pid-allow 为yes</li><li>ldid -Sdebuger.entitlements debugserver 使权限生效</li><li>scp -r debugserver <a href="mailto:&#x72;&#111;&#111;&#x74;&#64;&#49;&#48;&#x2e;&#49;&#x35;&#46;&#51;&#x32;&#x2e;&#x34;&#x35;">&#x72;&#111;&#111;&#x74;&#64;&#49;&#48;&#x2e;&#49;&#x35;&#46;&#51;&#x32;&#x2e;&#x34;&#x35;</a>:&#x2F;usr&#x2F;bin&#x2F;</li><li>注意剔除某些多余的权限 com.apple.security.network.server com.apple.security.network.client seatbelt-profiles</li></ul></li><li>ps -A</li><li>debugserver 127.0.0.1:1234 -a Aweme</li><li>proxy 12343 1234</li><li>lldb (process connect connect:&#x2F;&#x2F;127.0.0.1:12343)</li><li>po [AWEIMMessageConversation _shortMethodDescription]  打印header</li><li>br s -a 0x105cbdcf4 下断点</li><li>c 继续执行，点击触发</li></ol><h2 id="3-IOS-逆向流程总结"><a href="#3-IOS-逆向流程总结" class="headerlink" title="3. IOS 逆向流程总结"></a>3. IOS 逆向流程总结</h2><blockquote><p>应用砸壳 dumpdecrypted cluth frida-ios-dump<br>用class-dump 导出头文件 .&#x2F;..&#x2F;..&#x2F;class-dump-3.5&#x2F;class-dump Aweme -H -o Header<br>用cycript定位广告view<br>用lldb调试，找出 调用位置<br>追溯跳用逻辑，理清广告加载逻辑<br>用hook插件改变逻辑</p></blockquote><h2 id="4-批量刷机经历"><a href="#4-批量刷机经历" class="headerlink" title="4. 批量刷机经历"></a>4. 批量刷机经历</h2><h3 id="4-1-uncOver-12-到-13-5"><a href="#4-1-uncOver-12-到-13-5" class="headerlink" title="4.1. uncOver (12 到 13.5)"></a>4.1. uncOver (12 到 13.5)</h3><h3 id="4-2-checkra1n-最新版-（13-5及以后）"><a href="#4-2-checkra1n-最新版-（13-5及以后）" class="headerlink" title="4.2. checkra1n 最新版 （13.5及以后）"></a>4.2. checkra1n 最新版 （13.5及以后）</h3><h3 id="4-3-cd-private-var-mobile-Media-general-storage-iOS13"><a href="#4-3-cd-private-var-mobile-Media-general-storage-iOS13" class="headerlink" title="4.3. cd &#x2F;private&#x2F;var&#x2F;mobile&#x2F;Media&#x2F;general_storage&#x2F;iOS13&#x2F;"></a>4.3. cd &#x2F;private&#x2F;var&#x2F;mobile&#x2F;Media&#x2F;general_storage&#x2F;iOS13&#x2F;</h3><h3 id="4-4-chmod-x-install-sh"><a href="#4-4-chmod-x-install-sh" class="headerlink" title="4.4. chmod +x install.sh"></a>4.4. chmod +x install.sh</h3>]]></content>
      
      
      <categories>
          
          <category> 逆向-ios-工具说明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向-ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xposed攻防</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-anit-xposed/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-anit-xposed/</url>
      
        <content type="html"><![CDATA[<h1 id="xposed攻防"><a href="#xposed攻防" class="headerlink" title="xposed攻防"></a>xposed攻防</h1><p>check: <a href="https://github.com/w568w/XposedChecker">https://github.com/w568w/XposedChecker</a><br>hider: <a href="https://github.com/Yaerin/XposedHider">https://github.com/Yaerin/XposedHider</a></p><h3 id="常用检查xposed方式"><a href="#常用检查xposed方式" class="headerlink" title="常用检查xposed方式"></a>常用检查xposed方式</h3><ol><li>直接加载xposed类</li><li>读取加载后的动态链接库 </li><li>主动抛出异常检查xposed关键字</li><li>获取安装的应用程序</li><li>…</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line">//直接加载xposed类</span><br><span class="line">XC_MethodHook hookClass = new XC_MethodHook() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void beforeHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">        Log.i(&quot;xposed&quot;,&quot;xposed1&quot;);</span><br><span class="line">        String packageName = (String) param.args[0];</span><br><span class="line">        if (packageName.matches(&quot;de\\.robv\\.android\\.xposed\\.Xposed+.+&quot;)) &#123;</span><br><span class="line">            Log.i(&quot;xposed&quot;,&quot;de\\.robv\\.android\\.xposed\\.Xposed+.+&quot;);</span><br><span class="line">            param.setThrowable(new ClassNotFoundException(packageName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// FIXME: 18-6-23 w568w: It&#x27;s very dangerous to hook these methods, thinking to replace them.</span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        ClassLoader.class,</span><br><span class="line">        &quot;loadClass&quot;,</span><br><span class="line">        String.class,</span><br><span class="line">        boolean.class,</span><br><span class="line">        hookClass</span><br><span class="line">);</span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        Class.class,</span><br><span class="line">        &quot;forName&quot;,</span><br><span class="line">        String.class,</span><br><span class="line">        boolean.class,</span><br><span class="line">        ClassLoader.class,</span><br><span class="line">        hookClass</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//读取加载后的动态链接库 </span><br><span class="line">XposedHelpers.findAndHookMethod(BufferedReader.class, &quot;readLine&quot;, new XC_MethodHook() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">        String result = (String) param.getResult();</span><br><span class="line">        if(result != null) &#123;</span><br><span class="line">            if (result.contains(&quot;XposedBridge&quot;)) &#123;</span><br><span class="line">                param.setResult(&quot;&quot;);new File(&quot;&quot;).lastModified();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//主动抛出异常检查xposed关键字</span><br><span class="line">XC_MethodHook hookStack = new XC_MethodHook() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">        Log.i(&quot;xposed&quot;,&quot;xposed3&quot;);</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] elements = (StackTraceElement[]) param.getResult();</span><br><span class="line">        List&lt;StackTraceElement&gt; clone = new ArrayList&lt;&gt;();</span><br><span class="line">        for (StackTraceElement element : elements) &#123;</span><br><span class="line">            if (!element.getClassName().toLowerCase().contains(C.KW_XPOSED)) &#123;</span><br><span class="line">                clone.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        param.setResult(clone.toArray(new StackTraceElement[0]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        Throwable.class,</span><br><span class="line">        &quot;getStackTrace&quot;,</span><br><span class="line">        hookStack</span><br><span class="line">);</span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        Thread.class,</span><br><span class="line">        &quot;getStackTrace&quot;,</span><br><span class="line">        hookStack</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//获取安装的应用程序</span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        &quot;android.app.ApplicationPackageManager&quot;,</span><br><span class="line">        lpparam.classLoader,</span><br><span class="line">        &quot;getInstalledPackages&quot;,</span><br><span class="line">        int.class,</span><br><span class="line">        new XC_MethodHook() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                Log.i(&quot;xposed&quot;,&quot;xposed4&quot;);</span><br><span class="line"></span><br><span class="line">                List&lt;PackageInfo&gt; apps = (List&lt;PackageInfo&gt;) param.getResult();</span><br><span class="line">                List&lt;PackageInfo&gt; clone = new ArrayList&lt;&gt;();</span><br><span class="line">                // foreach is very slow.</span><br><span class="line">                final int len = apps.size();</span><br><span class="line">                for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                    PackageInfo app = apps.get(i);</span><br><span class="line">                    if (!app.packageName.toLowerCase().contains(C.KW_XPOSED)) &#123;</span><br><span class="line">                        clone.add(app);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                param.setResult(clone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        &quot;android.app.ApplicationPackageManager&quot;,</span><br><span class="line">        lpparam.classLoader,</span><br><span class="line">        &quot;getInstalledApplications&quot;,</span><br><span class="line">        int.class,</span><br><span class="line">        new XC_MethodHook() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                Log.i(&quot;xposed&quot;,&quot;xposed5&quot;);</span><br><span class="line"></span><br><span class="line">                List&lt;ApplicationInfo&gt; apps = (List&lt;ApplicationInfo&gt;) param.getResult();</span><br><span class="line">                List&lt;ApplicationInfo&gt; clone = new ArrayList&lt;&gt;();</span><br><span class="line">                final int len = apps.size();</span><br><span class="line">                for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                    ApplicationInfo app = apps.get(i);</span><br><span class="line">                    boolean shouldRemove = app.metaData != null &amp;&amp; app.metaData.getBoolean(&quot;xposedmodule&quot;) ||</span><br><span class="line">                            app.packageName != null &amp;&amp; app.packageName.toLowerCase().contains(C.KW_XPOSED) ||</span><br><span class="line">                            app.className != null &amp;&amp; app.className.toLowerCase().contains(C.KW_XPOSED) ||</span><br><span class="line">                            app.processName != null &amp;&amp; app.processName.toLowerCase().contains(C.KW_XPOSED);</span><br><span class="line">                    if (!shouldRemove) &#123;</span><br><span class="line">                        clone.add(app);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                param.setResult(clone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//查看某些函数是否是native</span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        Modifier.class,</span><br><span class="line">        &quot;isNative&quot;,</span><br><span class="line">        int.class,</span><br><span class="line">        new XC_MethodHook() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                Log.i(&quot;xposed&quot;,&quot;xposed6&quot;);</span><br><span class="line"></span><br><span class="line">                param.setResult(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        System.class,</span><br><span class="line">        &quot;getProperty&quot;,</span><br><span class="line">        String.class,</span><br><span class="line">        new XC_MethodHook() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                Log.i(&quot;xposed&quot;,&quot;xposed7&quot;);</span><br><span class="line"></span><br><span class="line">                if (&quot;vxp&quot;.equals(param.args[0])) &#123;</span><br><span class="line">                    param.setResult(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">        File.class,</span><br><span class="line">        &quot;list&quot;,</span><br><span class="line">        new XC_MethodHook() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                Log.i(&quot;xposed&quot;,&quot;xposed8&quot;);</span><br><span class="line"></span><br><span class="line">                String[] fs = (String[]) param.getResult();</span><br><span class="line">                if (fs == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                for (String f : fs) &#123;</span><br><span class="line">                    if (!f.toLowerCase().contains(C.KW_XPOSED) &amp;&amp; !f.equals(&quot;su&quot;)) &#123;</span><br><span class="line">                        list.add(f);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                param.setResult(list.toArray(new String[0]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz = null;</span><br><span class="line">try &#123;</span><br><span class="line">    clazz = Runtime.getRuntime().exec(&quot;echo&quot;).getClass();</span><br><span class="line">&#125; catch (IOException ignore) &#123;</span><br><span class="line">    XposedBridge.log(&quot;[W/XposedHider] Cannot hook Process#getInputStream&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (clazz != null) &#123;</span><br><span class="line">    XposedHelpers.findAndHookMethod(</span><br><span class="line">            clazz,</span><br><span class="line">            &quot;getInputStream&quot;,</span><br><span class="line">            new XC_MethodHook() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                    Log.i(&quot;xposed&quot;,&quot;xposed9&quot;);</span><br><span class="line"></span><br><span class="line">                    InputStream is = (InputStream) param.getResult();</span><br><span class="line">                    if (is instanceof FilterXpInputStream) &#123;</span><br><span class="line">                        param.setResult(is);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        param.setResult(new FilterXpInputStream(is));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XposedBridge.hookAllMethods(System.class, &quot;getenv&quot;,</span><br><span class="line">        new XC_MethodHook() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                Log.i(&quot;xposed&quot;,&quot;xposed10&quot;);</span><br><span class="line"></span><br><span class="line">                if (param.args.length == 0) &#123;</span><br><span class="line">                    Map&lt;String, String&gt; res = (Map&lt;String, String&gt;) param.getResult();</span><br><span class="line">                    String classpath = res.get(&quot;CLASSPATH&quot;);</span><br><span class="line">                    param.setResult(filter(classpath));</span><br><span class="line">                &#125; else if (&quot;CLASSPATH&quot;.equals(param.args[0])) &#123;</span><br><span class="line">                    String classpath = (String) param.getResult();</span><br><span class="line">                    param.setResult(filter(classpath));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            private String filter(String s) &#123;</span><br><span class="line">                List&lt;String&gt; list = Arrays.asList(s.split(&quot;:&quot;));</span><br><span class="line">                List&lt;String&gt; clone = new ArrayList&lt;&gt;();</span><br><span class="line">                for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    if (!list.get(i).toLowerCase().contains(C.KW_XPOSED)) &#123;</span><br><span class="line">                        clone.add(list.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder res = new StringBuilder();</span><br><span class="line">                for (int i = 0; i &lt; clone.size(); i++) &#123;</span><br><span class="line">                    res.append(clone);</span><br><span class="line">                    if (i != clone.size() - 1) &#123;</span><br><span class="line">                        res.append(&quot;:&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return res.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">XposedHelpers.findAndHookMethod(&quot;android.app.ApplicationPackageManager&quot;, lpparam.classLoader, &quot;getPackageInfo&quot;, String.class, int.class, new XC_MethodHook() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">        String packageName = (String) param.args[0];</span><br><span class="line">        XposedBridge.log(&quot;ApplicationPackageManager: &quot; + packageName);</span><br><span class="line">        if(packageName.equals(&quot;de.robv.android.xposed.installer&quot;))&#123;</span><br><span class="line">            param.args[0]=&quot;de.robv.android.Xposed.installer&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">XposedHelpers.findAndHookMethod(&quot;android.app.ApplicationPackageManager&quot;, lpparam.classLoader, &quot;getApplicationInfo&quot;, String.class, int.class, new XC_MethodHook() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">        String packageName = (String) param.args[0];</span><br><span class="line">        if (isTarget(packageName)) &#123;</span><br><span class="line">            XposedBridge.log(&quot;packageName: &quot; + packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">XposedHelpers.findAndHookMethod(&quot;android.app.ActivityManager&quot;, lpparam.classLoader, &quot;getRunningServices&quot;, int.class, new XC_MethodHook() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">        List&lt;ActivityManager.RunningServiceInfo&gt; serviceInfoList = (List) param.getResult();</span><br><span class="line">        List&lt;ActivityManager.RunningServiceInfo&gt; resultList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (ActivityManager.RunningServiceInfo runningServiceInfo : serviceInfoList) &#123;</span><br><span class="line">            String serviceName = runningServiceInfo.process;</span><br><span class="line">            if (isTarget(serviceName)) &#123;</span><br><span class="line">                XposedBridge.log(&quot;serviceName: &quot; + serviceName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resultList.add(runningServiceInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        param.setResult(resultList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">XposedHelpers.findAndHookMethod(&quot;android.app.ActivityManager&quot;, lpparam.classLoader, &quot;getRunningTasks&quot;, int.class, new XC_MethodHook() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">        List&lt;ActivityManager.RunningTaskInfo&gt; serviceInfoList = (List) param.getResult();</span><br><span class="line">        List&lt;ActivityManager.RunningTaskInfo&gt; resultList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (ActivityManager.RunningTaskInfo runningTaskInfo : serviceInfoList) &#123;</span><br><span class="line">            String taskName = runningTaskInfo.baseActivity.flattenToString();</span><br><span class="line">            if (isTarget(taskName)) &#123;</span><br><span class="line">                XposedBridge.log(&quot;taskName: &quot; + taskName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resultList.add(runningTaskInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        param.setResult(resultList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">XposedHelpers.findAndHookMethod(&quot;android.app.ActivityManager&quot;, lpparam.classLoader, &quot;getRunningAppProcesses&quot;, new XC_MethodHook() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">        List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcessInfos = (List) param.getResult();</span><br><span class="line">        List&lt;ActivityManager.RunningAppProcessInfo&gt; resultList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (ActivityManager.RunningAppProcessInfo runningAppProcessInfo : runningAppProcessInfos) &#123;</span><br><span class="line">            String processName = runningAppProcessInfo.processName;</span><br><span class="line">            if (isTarget(processName)) &#123;</span><br><span class="line">                XposedBridge.log(&quot;processName: &quot; + processName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resultList.add(runningAppProcessInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        param.setResult(resultList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">private static boolean isTarget(String name) &#123;</span><br><span class="line">    return name.contains(&quot;Hu&quot;) || name.contains(&quot;xposed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-hook-xposed</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-hook-xposed/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-hook-xposed/</url>
      
        <content type="html"><![CDATA[<h3 id="Xposd-app步骤"><a href="#Xposd-app步骤" class="headerlink" title="Xposd app步骤"></a>Xposd app步骤</h3><ol><li>一部root后的手机 安装xposed install </li><li>android app开发</li></ol><ul><li>assets目录 下xposed_init文件: xposed所在类 </li><li>AndroidManifest.xml 中添加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;xposedmodule&quot;</span><br><span class="line">    android:value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;xposeddescription&quot;</span><br><span class="line">    android:value=&quot;蚂蚁森林自动收取好友能量&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;xposedminversion&quot;</span><br><span class="line">    android:value=&quot;30&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li>lib下添加 api-82.jar</li></ul><ol start="3"><li>编写hook代码</li></ol><h3 id="fuck-this"><a href="#fuck-this" class="headerlink" title="fuck this"></a>fuck this</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. compileOnly &#x27;de.robv.android.xposed:api:82&#x27;</span><br><span class="line">2. 请确保禁用Instant Run（File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run），否则您的类不会直接包含在APK中，而是通过Xposed无法处理的存根应用程序加载。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 逆向-hook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向-hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-ios-应用砸壳</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-ios-%E5%BA%94%E7%94%A8%E7%A0%B8%E5%A3%B3/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-ios-%E5%BA%94%E7%94%A8%E7%A0%B8%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>逆向-ios-应用砸壳</del></p></blockquote><h3 id="砸壳原理"><a href="#砸壳原理" class="headerlink" title="砸壳原理"></a>砸壳原理</h3><ol><li>加密（appStore加密app）</li><li>解密<ul><li>静态砸壳：<br>  Clutch<ul><li>github下载Clutch <a href="https://github.com/KJCracks/Clutch.git">https://github.com/KJCracks/Clutch.git</a></li><li>拷贝$scp -P 12345 Clutch-2.0.4 root@localhost:&#x2F;usr&#x2F;bin</li><li>重命名$mv Clutch-2.0.4 Clutch</li><li>修改权限$chmod +x Clutch</li><li>查看砸壳状态$Clutch -i；砸壳$Clutch -d 2，其中“2”为查看的标示。系统应用不加壳</li><li>用iFunBox查找砸壳包，拷贝到电脑桌面解压，找到应用砸壳后的MachO文件</li><li>ida64查看MachO文件的加密情况,或者$otool -l WeChat | grep crypt</li><li>砸壳后的MachO文件即可以class-dump$class-dump -H WeChat -o .&#x2F;Headers&#x2F;</li></ul></li></ul></li></ol><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>购买10.2版本一下手机，刷机越狱</li><li>通过cydia 下载openssh,</li><li>链接wifi保证手机和电脑在同一局域网 ssh <a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#x37;&#50;&#46;&#49;&#x37;&#x2e;&#50;&#x2e;&#49;&#x37;&#56;">&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#x37;&#50;&#46;&#49;&#x37;&#x2e;&#50;&#x2e;&#49;&#x37;&#56;</a> <a href="https://www.jianshu.com/p/9fb62c24effc">https://www.jianshu.com/p/9fb62c24effc</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向-ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向-ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-js-调试</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-js-%E8%B0%83%E8%AF%95/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-js-%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="js调试技巧"><a href="#js调试技巧" class="headerlink" title="js调试技巧"></a>js调试技巧</h1><ol><li>巧用debugger，可以是代码可以是断点</li><li>查看Event Listeners事件监听</li><li>hook xhr (赚到js hook)</li><li>chrome source板块下 XHR&#x2F;fetch Breakpoints真的很nice。输入URL运行即刻即可下断</li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向-js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向-js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty-learn</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-netty-learn/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-netty-learn/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Netty-learn"><a href="#1-Netty-learn" class="headerlink" title=".1. Netty-learn"></a>.1. Netty-learn</h2><!-- TOC --><ul><li><a href="#netty-learn">Netty-learn</a><ul><li><a href="#gerneral">Gerneral</a><ul><li><a href="#nio-buffer">Nio buffer</a></li><li><a href="#nio%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B">Nio网络基本流程</a></li><li><a href="#zero-copy">Zero copy</a></li><li><a href="#reactor%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">Reactor设计模式</a></li><li><a href="#nioeventloopgroup">NioEventLoopGroup</a></li><li><a href="#netty-%E7%BB%84%E4%BB%B6%E9%97%B4%E5%85%B3%E7%B3%BB">Netty 组件间关系</a></li><li><a href="#netty%E5%A4%84%E7%90%86%E5%99%A8">Netty处理器</a></li><li><a href="#tcp%E7%9A%84%E9%BB%8F%E5%8C%85%E6%8B%86%E5%8C%85">Tcp的黏包，拆包</a></li><li><a href="#future">Future</a></li></ul></li></ul></li></ul><!-- /TOC --><h3 id="1-1-Gerneral"><a href="#1-1-Gerneral" class="headerlink" title=".1.1. Gerneral"></a>.1.1. Gerneral</h3><h4 id="1-1-1-Nio-buffer"><a href="#1-1-1-Nio-buffer" class="headerlink" title=".1.1.1. Nio buffer"></a>.1.1.1. Nio buffer</h4><ol><li>capacity 总数量</li><li>limit 用于限制读写</li><li>position 下一个读写位置</li><li><a href="https://www.bilibili.com/video/av33707223?p=37">https://www.bilibili.com/video/av33707223?p=37</a> 节 去掉buffer.clear()注释掉后分析</li><li>position&lt;limit&lt;capacity</li></ol><h4 id="1-1-2-Nio网络基本流程"><a href="#1-1-2-Nio网络基本流程" class="headerlink" title=".1.1.2. Nio网络基本流程"></a>.1.1.2. Nio网络基本流程</h4><ol><li>selector 办事大厅</li><li>获取ServerSocketChannel</li><li>设置ServerSocketChannel 属性（是否阻塞）</li><li>获取ServerSocket</li><li>给ServerSocket绑定端口</li><li>将通道注册到selector</li><li>循环selecor</li><li>获取selectorKey</li><li>判断selectorKey类型返回channel</li><li>处理</li><li>移除selectorKey</li></ol><h4 id="1-1-3-Zero-copy"><a href="#1-1-3-Zero-copy" class="headerlink" title=".1.1.3. Zero copy"></a>.1.1.3. Zero copy</h4><ol><li>缺少由user model缓存到system kernel缓存；由system kernel缓存到user model缓存下内容拷贝<B>2</B>次 (用户态优化)</li><li>System kernel下kernel buffer到socket buffer内容拷贝改为文件描述符拷贝</li><li>FileChannel transferto transferFrom 使用零拷贝</li></ol><h4 id="1-1-4-Reactor设计模式"><a href="#1-1-4-Reactor设计模式" class="headerlink" title=".1.1.4. Reactor设计模式"></a>.1.1.4. Reactor设计模式</h4><ol><li>Handle(句柄和描述符，产生事件)：本质表示一种资源，该资源（如何写入，写出）可表示一个个事件。</li><li>Synchronous Evnet demultiplexer(同步事件分离器)：它本身是一个系统调用，用于等待事件的发生（事件可能一个，多个），调用方在调用它的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止，位于linux来说，同步事件分离器就是常用的I&#x2F;O多路复用机制，比如说select,poll,epoll等，在Java NIO中，同步事件分离器对于组件selector,对于的阻塞方法select。</li><li>Event Handler（事件处理器）：本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。java NIO中没有，netty中有（比如SimpleChannelInBand,SimpleChanneloutBand）</li><li>Concrete Event Handler（具体事件处理器）：它是事件处理器的实现 ，从而实现特定的逻辑（比如自己写的MyHandler）</li><li>Initation Dispatcher(初始分发器)：实际上就是Reactor角色，它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又是提供了应用进行事件处理器的注册，删除等，它本身是整个事件处理器的核心所在，initiaion dispathcer会通过同步事件分离器来等待事件的发生，一旦事件发生，Initation Dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调函数来处理这些事件。</li></ol><h4 id="1-1-5-NioEventLoopGroup"><a href="#1-1-5-NioEventLoopGroup" class="headerlink" title=".1.1.5. NioEventLoopGroup"></a>.1.1.5. NioEventLoopGroup</h4><ol><li>NioEventLoopGroup extends MultithreadEventLoopGroup ,初始化时需要传入线程数（defalt&#x3D;Math.max(1, SystemPropertyUtil.getInt(<br>         “io.netty.eventLoopThreads”, Runtime.getRuntime().availableProcessors() * 2))）</li><li>线程数大小极为EventExecutor 数组大小</li><li>EventLoopGoup包含多个EventLoop</li><li>一个EventLoop在他整个生命周期中都只会与唯一的一个Thread进行绑定</li><li>所有的EventLoop所处理的各种I&#x2F;O事件都将在它所关联的Thread上处理</li><li>一个channel在它的整个生命周期中只会注册在一个EventLoop上</li><li>一个EventLoop在运行过程中，会被分配给一个或多个channel（多个channel会被注册到一个Selector上）</li><li>handler中业务是单线程执行，不需要并发控制，因此不能做耗时操作</li><li>Channel的实现一定是线程安全的，因此，我们可以存储一个channel 引用，并且在需要向远端发送数据时，通过这个引用来调用channel相关的方法，即使当时有很多线程都在使用它也不会出现多线程问题，而且。消息一定会按照顺序发送出去</li><li>在业务开发中，不要将长时间执行的耗时任务放置到EventLoop的执行队列中，因此它会一直阻塞该线程所对于的所有channel上的其他执行任务，如果我们需要阻塞调用或耗时操作，那么我们需要使用一个专门的EventExcutor（业务线程池）</li></ol><ul><li>使用 java eventExcutor</li><li>借助pipeline中添加channelHandler调用的addLast(group , handler)</li></ul><h4 id="1-1-6-Netty-组件间关系"><a href="#1-1-6-Netty-组件间关系" class="headerlink" title=".1.1.6. Netty 组件间关系"></a>.1.1.6. Netty 组件间关系</h4><ol><li>main Reactor 和 sub Reactor分别对于netty 中的bossGroup 和workGroup，selector 对于EventLoop</li><li>ChannelInitializer（采用模板模式） 继承 ChannelInboundHandlerAdapter 继承 ChannelHandlerAdapter并且实现了ChannelInboundHandler接口，这里采用适配器模式（将ChannelHandlerContext（两空） 转化成ChannelInboundHandler（三空）接口）。以上是ChannelHandler接口转换</li><li>ChannelPipline 中存放ChannelHandler，包含InBoundHandler和OutBoundHandler</li><li>Channel中可以获取其对于的ChannelPipline ，ChannelPipline 也关联着唯一的Channel</li><li>ChannelHandlerContext 何以获取channel  ChannelHandler ChannelPipline ，自身通过双向链表存储</li><li>对于netty消息发送方式，写入到channel中的消息会从末尾开始流动，写入ChannelHandlerContext将会从ChannelPipeline中下一个ChannelHandler开始流动</li></ol><h4 id="1-1-7-Netty处理器"><a href="#1-1-7-Netty处理器" class="headerlink" title=".1.1.7. Netty处理器"></a>.1.1.7. Netty处理器</h4><ol><li>netty处理器包含入栈处理器和出栈处理器</li><li>入栈处理器顶层ChannelInboundHandler 出栈处理器顶层ChannelOutboundHandler</li><li>编码：message -&gt; byte（ChannelOutboundHandler）  解码：byte -&gt; message（ChannelInboundHandler）</li><li>ReplayingDecoder extends ByteToMessageDecoder 会不断重试判断读取是否满足，因此不需要数据读取大小判断</li></ol><h4 id="1-1-8-Tcp的黏包，拆包"><a href="#1-1-8-Tcp的黏包，拆包" class="headerlink" title=".1.1.8. Tcp的黏包，拆包"></a>.1.1.8. Tcp的黏包，拆包</h4><ol><li>黏包：tcp 在传输消息时，可能数据不够发送条件，需要合并消息</li><li>拆包：tcp 在数据接受时候，可能会收到多个消息合并后的数据包</li><li>netty 提供前一条消息与下一条消息分割的分割符号识别</li></ol><h4 id="1-1-9-Future"><a href="#1-1-9-Future" class="headerlink" title=".1.1.9. Future"></a>.1.1.9. Future</h4><ol><li>JDK提供的Future只能通过手工方式检查结果，而这个操作是会阻塞的；Netty则对ChannelFuture进行了增强，通过ChannelFutrueListener以回调方式来获取执行结果，去除了手工检查阻塞的操作，值得注意的是：ChannelFutureListener的OperationComplete方法是由I&#x2F;O线程执行的，因此要注意的是不要在这里执行耗时操作，否则需要通过另外的线程或线程池来执行</li></ol>]]></content>
      
      
      <categories>
          
          <category> code-java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty-sekiro</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-netty-sekiro/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-netty-sekiro/</url>
      
        <content type="html"><![CDATA[<h2 id="1-netty-sekiro"><a href="#1-netty-sekiro" class="headerlink" title=".1. netty-sekiro"></a>.1. netty-sekiro</h2><!-- TOC --><ul><li><a href="#netty-sekiro">netty-sekiro</a><ul><li><a href="#gerneral">Gerneral</a><ul><li><a href="#sekiro%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84">sekiro组织架构</a></li><li><a href="#%E4%BA%BA%E8%A7%82%E6%B5%81%E7%A8%8B">人观流程</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E5%89%8D%E4%B8%80%E7%89%88%E6%9C%ACbug">解决前一版本bug</a></li><li><a href="#sekiro-%E5%9F%BA%E4%BA%8Exposed%E4%B8%BB%E5%8A%A8hook-demo">sekiro 基于xposed主动hook demo</a></li></ul></li></ul></li></ul><!-- /TOC --><h3 id="1-1-Gerneral"><a href="#1-1-Gerneral" class="headerlink" title=".1.1. Gerneral"></a>.1.1. Gerneral</h3><p>SEKIRO 是一个android下的API服务暴露框架，可以用在app逆向、app数据抓取、android群控等场景。</p><ol><li>sekiro 是用springboot,和netty（nio）开发的高效通讯框架</li><li>sekiro 不仅支持短连接，也支持长链接，能实时返回手机是否在线的技术</li><li>sekiro 中使用了netty代表异步请求，服务器资源使用少</li><li>sekiro 不依赖xposed架构，能与一切hook框架解耦合</li></ol><h4 id="1-1-1-sekiro组织架构"><a href="#1-1-1-sekiro组织架构" class="headerlink" title=".1.1.1. sekiro组织架构"></a>.1.1.1. sekiro组织架构</h4><p><img src="/img/Sekiro%E6%9E%B6%E6%9E%84.png" alt="sekiro组织架构"></p><ol><li>sekiro包含移动端开发和服务器端开发</li><li>服务器端是用Springboot管理各种组件，在Springboot bean（InitializingBean）初始化 afterPropertiesSet完成会启动两个nio服务，分别监听5600，5601端口.</li><li>5601 端口的nio服务器用于处理http请求，即处理调用接口处理。<ul><li>RBHttpRequestDecoder 用于http解码</li><li>HttpResponseEncoder 用于http编码</li><li>HttpObjectAggregator 最大报文处理</li><li>HttpRequestDispatcher 对拿到的http请求处理</li></ul></li><li>HttpRequestDispatcher 中接受request请求，封装成SekiroNatMessage 发送给移动端，并且生成一个新任务设置事件回调接口并保存到concurrentmap中.</li><li>5600 端口的nio服务器用于处理tcp请求，与移动端数据交互<ul><li>SekiroMessageEncoder tcp编码</li><li>SekiroMessageDecoder tcp解码</li><li>ServerIdleCheckHandler 服务器空闲检查 读空闲，写空闲</li><li>NatServerChannelHandler 自定义处理与移动端数据交互</li></ul></li><li>pipeline中的handler是依次执行，符合条件执行</li><li>SekiroNatMessage 是移动端与服务器交互数据的对象</li><li>SekiroNatMessage 目前包含3中类型<ul><li>SekiroNatMessage.TYPE_HEARTBEAT 用于处理心跳检查</li><li>SekiroNatMessage.C_TYPE_REGISTER 用于移动端action注册</li><li>SekiroNatMessage.TYPE_INVOKE 用于服务器介绍到客户端hook信息，并将信息返回给调用者</li></ul></li><li>SekiroNatMessage.C_TYPE_REGISTER 实际是将NatClient（封装移动端与服务端的channel，clietid,group信息）保存到natClientMap，poolQueue中</li><li>SekiroNatMessage.TYPE_INVOKE 从channel中获取clientid，group，换取task任务，调用回调函数。即sekiroResponseEvent.onSekiroResponse(sekiroNatMessage);是将移动端hook后的返回信息（是否注册手机号）传递给回调函数，回调函数会返回response给调用者</li><li>移动端即client客户端包含一下handler<ul><li>SekiroMessageDecoder</li><li>SekiroMessageEncoder</li><li>ClientIdleCheckHandler 与服务器连接空闲检查</li><li>ClientChannelHandler 自定义处理服务器端发来的数据</li></ul></li><li>ClientChannelHandler将服务器端发来的hook请求取出对于的action 调用</li><li>sekiroResponse.success  触发channel.writeAndFlush(sekiroNatMessage); 将hook信息发送到服务端</li></ol><h4 id="1-1-2-人观流程"><a href="#1-1-2-人观流程" class="headerlink" title=".1.1.2. 人观流程"></a>.1.1.2. 人观流程</h4><p>总结：4（调用者的request）-&gt;7（发送hook请求注册回调）-&gt; 12（移动端寻找action调用） -&gt; 13（返回hook到的信息） -&gt; 10（服务器端收到hook消息回调给调用者）</p><ol><li>其中7，10步骤都是异步，不断发送和接受</li><li>如何确保同一任务 这里采用 clientId + “—“ + group + “—“ + seq; 代表唯一id</li></ol><h4 id="1-1-3-解决前一版本bug"><a href="#1-1-3-解决前一版本bug" class="headerlink" title=".1.1.3. 解决前一版本bug"></a>.1.1.3. 解决前一版本bug</h4><p>SekiroMessageDecoder 代替原理啊的SekiroNatMessageDecoder（更名为SekiroNatMessageDecoderError）</p><h4 id="1-1-4-sekiro-基于xposed主动hook-demo"><a href="#1-1-4-sekiro-基于xposed主动hook-demo" class="headerlink" title=".1.1.4. sekiro 基于xposed主动hook demo"></a>.1.1.4. sekiro 基于xposed主动hook demo</h4><p><a href="https://github.com/langgithub/hello">https://github.com/langgithub/hello</a></p>]]></content>
      
      
      <categories>
          
          <category> code-java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-netty-sekiro%E8%AF%B4%E6%98%8E/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-netty-sekiro%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>一. 提供接口文档信息（swagger地址），需包含接口-参数-请求示例</p><ol><li><p>BIO（同步）接口: &#x2F;invoke<br>参数：group（自定义的分组）,action（自定义的接口名称）,bindClient（指定手机id）,invoke_timeOut（设置超时时间）<br>案例： <a href="http://sekiro.virjar.com/invoke?group=sekiro-demo&action=clientTime&param1=%E5%8F%82%E6%95%B0">http://sekiro.virjar.com/invoke?group=sekiro-demo&amp;action=clientTime&amp;param1=参数</a></p></li><li><p>NIO（异步）接口：&#x2F;asyncInvoke<br>参数：group（自定义的分组）,action（自定义的接口名称）,bindClient（指定手机id）,invoke_timeOut（设置超时时间）<br>案例：<a href="http://sekiro.virjar.com/asyncInvoke?group=sekiro-demo&action=clientTime&param1=%E5%8F%82%E6%95%B0">http://sekiro.virjar.com/asyncInvoke?group=sekiro-demo&amp;action=clientTime&amp;param1=参数</a></p></li><li><p>分组枚举接口：&#x2F;groupList<br>参数：无<br>案例：<a href="http://sekiro.virjar.com/groupList">http://sekiro.virjar.com/groupList</a></p></li><li><p>设备枚举接口：&#x2F;natChannelStatus<br>参数：无<br>案例：<a href="https://sekiro.virjar.com/natChannelStatus?group=xingxing">https://sekiro.virjar.com/natChannelStatus?group=xingxing</a></p></li></ol><p>二. 版本更新内容：（列出涉及的功能内容，如果比较复杂，可以在附件中补充下需求文档，接口文档，或其他文档）</p><ol><li>以tcp为底层协议提供一套客户端，服务器通信的交互协议</li><li>提供接口解析映射成sekiro通讯协议，完成与客户端的交互</li><li>这里的客户端指Android，ios,python,java等夸语言实现一套sekiro协议通讯的终端</li><li>sekiro主要是接口信息转发，统一管理终端</li><li>sekiro协议报文字段说明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct SekiroPacket &#123;</span><br><span class="line">    //数据包长度，</span><br><span class="line">    __int32_t packet_length;</span><br><span class="line">    //消息类型，</span><br><span class="line">    int8_t message_type;</span><br><span class="line">    //消息id，每次递增，作为请求和响应关联使用。这个id是服务器端产生，客户端只需要使用</span><br><span class="line">    int64_t serial_number;</span><br><span class="line">    //扩展数据长度</span><br><span class="line">    int8_t ext_length;</span><br><span class="line">    //扩展数据,UTF8的字符串编码</span><br><span class="line">    char *ext;</span><br><span class="line">    //body,</span><br><span class="line">    char *payload;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>三. 基础信息：（脚步语言的类型，服务器的类型，目录的结构，使用的开源软件，数据库类型，所有的连接页面，用到的框架等）</p><ol><li>开发语言： java</li><li>开发用到的框架： springBoot(版本： 2.2.2.RELEASE) + netty（版本：4.1.43.Final）</li><li>数据库： 无</li><li>服务器： Linux操作系统</li></ol><p>四. 安全评审证明：如涉及框架变更，数据安全（敏感信息展示）的业务需求实现，请提供安全评审通过的附件证明</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js hook</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-js-hook/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-js-hook/</url>
      
        <content type="html"><![CDATA[<h1 id="js-hook"><a href="#js-hook" class="headerlink" title="js hook"></a>js hook</h1><ol><li><p>jquery hook 这是我的油猴插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    //console.log(&quot;hook my xhr&quot;)</span><br><span class="line">    !function(t)&#123;function r(n)&#123;if(e[n])return e[n].exports;var o=e[n]=&#123;exports:&#123;&#125;,id:n,loaded:!1&#125;;return t[n].call(o.exports,o,o.exports,r),o.loaded=!0,o.exports&#125;var e=&#123;&#125;;return r.m=t,r.c=e,r.p=&quot;&quot;,r(0)&#125;([function(t,r,e)&#123;e(1)(window)&#125;,function(t,r)&#123;t.exports=function(t)&#123;t.hookAjax=function(t)&#123;function r(r)&#123;return function()&#123;var e=this.hasOwnProperty(r+&quot;_&quot;)?this[r+&quot;_&quot;]:this.xhr[r],n=(t[r]||&#123;&#125;).getter;return n&amp;&amp;n(e,this)||e&#125;&#125;function e(r)&#123;return function(e)&#123;var n=this.xhr,o=this,i=t[r];if(&quot;function&quot;==typeof i)n[r]=function()&#123;t[r](o)||e.apply(n,arguments)&#125;;else&#123;var a=(i||&#123;&#125;).setter;e=a&amp;&amp;a(e,o)||e;try&#123;n[r]=e&#125;catch(t)&#123;this[r+&quot;_&quot;]=e&#125;&#125;&#125;&#125;function n(r)&#123;return function()&#123;var e=[].slice.call(arguments);if(!t[r]||!t[r].call(this,e,this.xhr))return this.xhr[r].apply(this.xhr,e)&#125;&#125;window._ahrealxhr=window._ahrealxhr||XMLHttpRequest,XMLHttpRequest=function()&#123;var t=new window._ahrealxhr;Object.defineProperty(this,&quot;xhr&quot;,&#123;value:t&#125;)&#125;;var o=window._ahrealxhr.prototype;for(var i in o)&#123;var a=&quot;&quot;;try&#123;a=typeof o[i]&#125;catch(t)&#123;&#125;&quot;function&quot;===a?XMLHttpRequest.prototype[i]=n(i):Object.defineProperty(XMLHttpRequest.prototype,i,&#123;get:r(i),set:e(i),enumerable:!0&#125;)&#125;return window._ahrealxhr&#125;,t.unHookAjax=function()&#123;window._ahrealxhr&amp;&amp;(XMLHttpRequest=window._ahrealxhr),window._ahrealxhr=void 0&#125;,t.default=t&#125;&#125;]);</span><br><span class="line">    //js加载完成执行</span><br><span class="line">    //console.log(hookAjax)</span><br><span class="line">    hookAjax(&#123;</span><br><span class="line">        //拦截回调</span><br><span class="line">        onreadystatechange:function(xhr)&#123;</span><br><span class="line">            console.log(&quot;onreadystatechange called: %O&quot;,xhr)</span><br><span class="line">        &#125;,</span><br><span class="line">        onload:function(xhr)&#123;</span><br><span class="line">            console.log(&quot;onload called: %O&quot;,xhr)</span><br><span class="line">        &#125;,</span><br><span class="line">        //拦截方法</span><br><span class="line">        open:function(arg,xhr)&#123;</span><br><span class="line">            console.log(&quot;open called: method:%s,url:%s,async:%s&quot;,arg[0],arg[1],arg[2])</span><br><span class="line">        &#125;,</span><br><span class="line">        setRequestHeader:function(arg,xhr)&#123;</span><br><span class="line">            console.log(&quot;setRequestHeader called: method:%s,name:%s,value:%s&quot;,arg[0],arg[1],arg[2])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(&quot;hook xhr&quot;)</span><br><span class="line">    // Your code here...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>hook window 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">orig = window.eval;</span><br><span class="line">window.eval=function(str)&#123;debugger;orig(str);&#125;</span><br><span class="line">// 这段代码防止反hook的检测</span><br><span class="line">window.eval.toString = function ()&#123;return orig.toString();&#125;</span><br></pre></td></tr></table></figure></li><li><p>hook 节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dom_get_element = document.getElementById;</span><br><span class="line">document.getElementById = function(id)&#123;if(id==&quot;9DhefwqGPrzGxEp9hPaoag&quot;) debugger; dom_get_element(id);&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫-js逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>so 文件加载过程</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-so-%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-so-%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="so文件加载流程"><a href="#so文件加载流程" class="headerlink" title="so文件加载流程"></a>so文件加载流程</h3><p><img src="https://shuwoom.com/wp-content/uploads/2017/12/%E5%9B%BE%E7%89%874-4.png" alt="image"></p><h3 id="记载步骤"><a href="#记载步骤" class="headerlink" title="记载步骤"></a>记载步骤</h3><ol><li><p>java 加载<br>loadLibrary&#x3D;&gt;doLoad&#x3D;&gt;nativeLoad</p></li><li><p>native 加载</p></li></ol><ul><li>初始化阶段</li><li>加载到内存<ol><li>打开so文件</li><li>映射so到内存空间</li><li>解析 dynamic section</li></ol></li><li>链接阶段</li></ul><p>3.so加载关键函数<br>dlopen -&gt; 打开so文件<br>dlsym  -&gt; 获取JNI_Onload函数地址,调用该函数<br>dlerror -&gt; 处理错误</p><p>4.初始化<br>init<br>init_array</p><p>5.常用类<br>log</p><p>6.root权限<br>读写内存数据-》内存页属性的修改 -〉 r&#x2F;w&#x2F;x chmod 777</p><p>7.下断点时机 (init init_array) JNI_OnLoad </p><p>注意：so加载了program header 没有加载session header</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> so </tag>
            
            <tag> ndk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android文件-so</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-so-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-so-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="android文件-so"><a href="#android文件-so" class="headerlink" title="android文件-so"></a>android文件-so</h1><ul><li>archives&#x2F;559.html</li><li>archives&#x2F;849.html</li><li>清华大学so文件分析 (<a href="https://langgithub.github.io/file/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90.pdf">https://langgithub.github.io/file/ELF文件格式分析.pdf</a>)</li></ul><h3 id="寄存器接受参数在-R0-R3-返回值在R0"><a href="#寄存器接受参数在-R0-R3-返回值在R0" class="headerlink" title="寄存器接受参数在 R0 - R3 ,返回值在R0"></a>寄存器接受参数在 R0 - R3 ,返回值在R0</h3><h3 id="so文件结构"><a href="#so文件结构" class="headerlink" title="so文件结构"></a>so文件结构</h3><ol><li>header<br> ELF文件头是ELF文件中唯一一个固定位置的文件结构，保存段头表和节头表位置和大小信息</li><li>section</li><li>program<ul><li>段头表保存了ELF文件的加载过程中各节头表的内存映射，依赖库等信息</li><li>.dynstr .text .dynamic<br>相同flg section 放在一起组成program load 段才会被加载到内存</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1、.text段</span><br><span class="line"></span><br><span class="line">一般C语言编译后的执行语句都编译成机器代码，保存在.text段。</span><br><span class="line"></span><br><span class="line">2、.data段</span><br><span class="line">已经初始化的全局变量和局部静态变量（虽然默认会初始化为0,或者手动初始化为0，都没有必要在数据段分配空间，直接放在.bss段，就默认值为0了）都保存在.data段。</span><br><span class="line">大体来说，该section包含了在内存中的程序的初始化数据；data段包含三个部分：heap(堆)、stack(栈)和静态数据区。即.data还会存放其他类型的数据，比如局部变量。</span><br><span class="line">数据段只是存放数据，变量名存放在字符串表中。</span><br><span class="line"></span><br><span class="line">3、.bss段</span><br><span class="line">未初始化的全局变量和局部静态变量都保存在.bss段。</span><br><span class="line">大体来说该section包含了在内存中的程序的未初始化的数据。</span><br><span class="line">由于程序加载（一般是指main之前）时，bss会被操作系统清零，所以未赋初值或初值为0的全局变量都在bss。.bss段只是为未初始化的全局变量和局部静态变量预留位置而已，它并没有内容，所以它在文件中也不占据空间，这样可减少目标文件体积。</span><br><span class="line">但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。</span><br><span class="line"></span><br><span class="line">4、.rodata段</span><br><span class="line">存放只读数据，一般是程序里面的只读变量（如const修饰的变量），以及字符串常量（不一定，也可能放在.data中）。</span><br><span class="line"></span><br><span class="line">5、.got段</span><br><span class="line"></span><br><span class="line">GOT（Global Offset Table）表中每一项都是本运行模块要引用的一个全局变量或函数的地址。可以用GOT表来间接引用全局变量、函数，也可以把GOT表的首地址作为一个基 准，用相对于该基准的偏移量来引用静态变量、静态函数。由于加载器不会把运行模块加载到固定地址，在不同进程的地址空间中，各运行模块的绝对地址、相对位 置都不同。这种不同反映到GOT表上，就是每个进程的每个运行模块都有独立的GOT表，所以进程间不能共享GOT表。</span><br><span class="line"></span><br><span class="line">6、.plt段</span><br><span class="line"></span><br><span class="line">过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。</span><br><span class="line">每个 PLT 入口项对应一个 GOT 项，执行函数实际上就是跳转到相应 GOT 项存储的地址，该 GOT 项初始值为 PLTn项中的 push 指令地址(即 jmp 的下一条指令，所以第 1 次跳转没有任何作用)，待符号解析完成后存放符号的真正地址。动态链接器在装载映射共享库时在 GOT 里设置 2 个特殊值：在 GOT+4( 即 GOT[1]) 设置动态库映射信息数据结构link_map 地址；在 GOT+8(即 GOT[2])设置动态链接器符号解析函数的地址_dl_runtime_resolve。</span><br><span class="line"></span><br><span class="line">每一个外部定义的符号在全局偏移表 (Global Offset Table GOT)中有相应的条目,如果符号是函数则在过程连接表(Procedure Linkage Table PLT)中也有相应的条目</span><br><span class="line"></span><br><span class="line">下面来看张图就了解了.got段和.plt段的关系：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个在我们之前说到Hook技术就是用着两个段来实现的。只要修改需要hook的函数地址，插入我们hook的函数，执行之后，再回来就可以了，这里只要修改.got和.plt表就可以了，相关知识大家去网上搜一下吧。这里就不在解释了。</span><br></pre></td></tr></table></figure><h3 id="readelf-使用"><a href="#readelf-使用" class="headerlink" title="readelf 使用"></a>readelf 使用</h3><ol><li>readelf -h xxx.so (查看so文件的头部信息)</li><li>readelf -S xxx.so (查看so文件的节(Section)头的信息)</li><li>readelf -l xxx.so (查看so文件的程序段头信息(Program))</li><li>readelf -a xxx.so (查看so文件所有信息)</li></ol><h3 id="010-Editor-运用"><a href="#010-Editor-运用" class="headerlink" title="010 Editor 运用"></a>010 Editor 运用</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> so </tag>
            
            <tag> 文件结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-指令-ARM</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-%E6%8C%87%E4%BB%A4-ARM/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-%E6%8C%87%E4%BB%A4-ARM/</url>
      
        <content type="html"><![CDATA[<h1 id="ARM指令"><a href="#ARM指令" class="headerlink" title="ARM指令"></a>ARM指令</h1><h3 id="用户模式"><a href="#用户模式" class="headerlink" title="用户模式"></a>用户模式</h3><ol><li>不分组寄存器（R0-R7）</li><li>分组寄存器（R8-R14）</li><li>程序计数器pc（R15）</li><li>状态寄存器CPSR</li></ol><h3 id="ARM处理器"><a href="#ARM处理器" class="headerlink" title="ARM处理器"></a>ARM处理器</h3><ol><li>ARM状态（32位对齐指令的ARM指令）</li><li>Thumb状态（16位对齐指令的Thump指令）</li></ol><h3 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h3><ol><li>跳转指令</li></ol><ul><li>B 无条件跳转</li><li>BL 带链接的无条件跳转</li><li>BX 带状态切换的无条件跳转</li><li>BLX 带链接和状态的无条件跳转</li><li>B loc_地址</li><li>BNE 不相等跳转地址；BEQ 相等跳转地址</li></ul><ol start="2"><li>存储器和寄存器交互数据指令</li></ol><ul><li><p>存储器（主存，内存）</p></li><li><p>寄存器中的数据（字符串，数，地址，各种类型数据）</p></li><li><p>LDR 从存储器中加载数据到寄存器 &lt;- load</p></li><li><p>LDR R8,[R9,#04] R8为寄存器，加载值为R9+#04所指向的存储单元</p></li><li><p>STR 将寄存器的数据加载到存储器 -&gt; store</p></li><li><p>STR R8,[R9,#04] 将R8寄存器中数据存储到R9+#04所指向的存储单元</p></li><li><p>LDM 将存储器的数据加载到一个寄存器列表 -&gt;</p></li><li><p>LDM R0, {R1-R3} 将R0指向的存储单元的数据依次加载到R1,R2,R3寄存器</p></li><li><p>STM 将一个寄存器列表的数据存储到指定存储器 &lt;-</p></li><li><p>PUSH 将寄存器值推入堆栈</p></li><li><p>POP 将堆栈的值推出到寄存器</p></li><li><p>SWP 将寄存器与存储器之间的数据进行交换</p></li><li><p>SWP R1，R1 [R0] 将R1寄存器与R0指向存储单元内容进行交换</p></li></ul><ol start="3"><li>数据传送指令</li></ol><ul><li>MOV 立即数或寄存器的数据数据传送到目标寄存器</li><li>MOV R0,#8 R0&#x3D;#8</li></ul><ol start="4"><li>数据算术运算指令</li></ol><ul><li>ADD,SUB,MUL,DIV</li><li>有符号，无符号运算，带进位运算</li></ul><ol start="5"><li>数据逻辑运算指令</li></ol><ul><li><p>与 ADD</p></li><li><p>或 ORR</p></li><li><p>异或 EOR</p></li><li><p>LSL 逻辑左移</p></li><li><p>LSR 逻辑右移</p></li><li><p>LSL R0，R1，#2   R0&#x3D;R1*2</p></li></ul><ol start="6"><li>比较指令</li></ol><ul><li>CMP </li><li>CMP R0 #0   R0寄存器中值与0比较</li><li>标志位</li></ul><ol start="7"><li>其他指令</li></ol><ul><li>伪处理器指令 SWT （切换用户模式）</li><li>伪指令 DCB</li></ul><ol start="8"><li>寄存器寻址指令</li></ol><ul><li>7种，常见的5种</li><li>立即寻址 MOV R0,#1234</li><li>寄存器寻址 MOV R0 , R1</li><li>寄存器移位寻址 MOV R0, R1,LSL #2  R0&#x3D;R1*4</li><li>寄存器间接寻址 LDR R0 ,[R1] R1寄存器值作为地址赋R0</li><li>寄存器间接基址偏移寻址 LDR R0,[R1,#-4]将R1寄存家的值-0x4作为地址，取出地址中的值赋R0</li></ul><h3 id="ARM-指令收集"><a href="#ARM-指令收集" class="headerlink" title="ARM 指令收集"></a>ARM 指令收集</h3><ol><li><p>—SUB指令—</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">减法指令SUB (SUBtract) </span><br><span class="line">格式: SUB A,B //A=A-B;</span><br><span class="line">功能: 两个操作数的相减,即从A中减去B,其结果放在A中.</span><br></pre></td></tr></table></figure></li><li><p>—CMP指令—</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比较指令CMP</span><br><span class="line">格式: CMP A,B //  A-B;</span><br><span class="line">功能: 两个操作数的相减,即从A中减去B，其结果会影响标志位， 对标志位的影响与SUB指令相同。本条指令主要是用于配合条件转移指令使用。如JZ ZF=0时，跳转</span><br></pre></td></tr></table></figure></li><li><p>—条件转移指令 JE&#x2F;JZ— </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式: JE/JZ标号 //等于跳转</span><br><span class="line">功能: ZF＝1,转到指定地址执行</span><br><span class="line">说明:</span><br><span class="line">1. 指令JE与JZ等价,它们是根据标志位ZF进行转移的指令</span><br><span class="line">2. JE,JZ均为一条指令的两种助记符表示方法</span><br></pre></td></tr></table></figure></li><li><p>—str指令—</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式:str&#123;条件&#125;  源寄存器，&lt;存储器地址&gt;</span><br><span class="line">功能:将源寄存器中数据存到存储器地址中 </span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">str  r1,[r2]        ; 将r1中的值存到r2所指定的地址中</span><br><span class="line">str  r1,[r2,#4]     ;将r1中的值存到r2+4所指定的地址中</span><br><span class="line">str  r1,[r2],#4     ;将r1中的值存到r2所指定的地址中, 同时r2=r2+4</span><br></pre></td></tr></table></figure></li><li><p>—LDR LDM指令—</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">A.LDR加载指令 从右往左</span><br><span class="line">格式为:LDR&#123;条件&#125;  目的寄存器，&lt;存储器地址&gt;</span><br><span class="line">功能:LDR指令用亍从存储器中将一个32位的字数据传送到目的寄存器中</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">ldr r0，[r1]                ；将存储器地址为R1的字数据读入寄存器R0。</span><br><span class="line">ldr r0，[r1，r2]            ；将存储器地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line">ldr r0，[r1，＃8]           ；将存储器地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">ldr r0，[r1，r2]！          ；将存储器地址为R1+R2的字数据读入寄存器R0,幵将新地址R1＋R2写入R1。</span><br><span class="line">ldr r0，[r1，＃8]！         ；将存储器地址为R1+8的字数据读入寄存器R0，幵将新地址R1＋8写入R1。 </span><br><span class="line">ldr r0，[r1]，r2            ；将存储器地址为R1的字数据读入寄存器R0，幵将新地址R1＋R2写入R1。</span><br><span class="line">ldr r0，[r1，r2，lsl＃2]！  ；将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。</span><br><span class="line">ldr r0，[r1]，r2，lsL＃2    ；将存储器地址为R1的字数据读入寄存器R0，幵将新地址R1＋R2×4写入R1。”</span><br><span class="line">B.伪指令</span><br><span class="line">格式:LDR&#123;条件&#125;  目的寄存器，&lt;存储器地址&gt;</span><br><span class="line">功能:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明:将COUNT的值赋给R0</span><br><span class="line">LDR       R1,=COUNT</span><br><span class="line">LDR       R0,[R1]</span><br><span class="line">LDR       R1,=COUNT这条伪指令，是怎样完成将COUNT的地址赋给R1，有兴趣的可以看它编译后的结果。这条指令实际上会编译成一条LDR指令和一条DCD伪指令。</span><br><span class="line"></span><br><span class="line">B.LDM记载指令</span><br><span class="line">从左往右</span><br></pre></td></tr></table></figure></li><li><p>—B,BL,BX,BLX 指令—</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A.B跳转指令</span><br><span class="line">格式:B  addr</span><br><span class="line">功能:跳转指令B使程序跳转到指定的地址执行程序。</span><br><span class="line">说明:</span><br><span class="line">B  0x1234   ;跳转到绝对地址0x1234处。</span><br><span class="line"></span><br><span class="line">B.BL带返回的连接跳转</span><br><span class="line">格式:</span><br><span class="line">功能:BL指令用于实现子程序调用。子程序的返回可通过将LR寄存器的值复制到PC寄存器来实现。下面的指令可实现子程序返回：(1)、BX   R14   (2)、MOV   PC,R14</span><br><span class="line">说明:</span><br><span class="line">BL func    ;跳转到子程序func处执行，同时将当前pc值保存到LR中。</span><br><span class="line"></span><br><span class="line">C.BX跳转并切换状态</span><br><span class="line">格式:BX&#123;&lt;cond&gt;&#125;    &lt;Rm&gt;</span><br><span class="line">功能:带状态切换的跳转指令BX使程序跳转到指令中指定的参数Rm指定的地址执行程序。若 Rm 的 bit[0] 为1，切换到 Thumb 指令执行；若 Rm 的 bit[0] 为0，切换到 ARM 指令执行。</span><br><span class="line">说明:</span><br><span class="line">BX   R0    ;跳转到R0中的地址，如果R0[0]=1，则进入Thumb状态。</span><br><span class="line"></span><br><span class="line">D.BLX带返回的跳转并切换状态</span><br><span class="line">格式:</span><br><span class="line">功能:该指令为无条件执行指令</span><br></pre></td></tr></table></figure></li><li><p>—BEQ BNE指令—</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.BEQ指令</span><br><span class="line">格式: BEQ </span><br><span class="line">功能: 相等跳转</span><br><span class="line"></span><br><span class="line">b.BNE指令</span><br><span class="line">格式: BNE</span><br><span class="line">功能: 不想等跳转</span><br></pre></td></tr></table></figure></li><li><p>——-.w——</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代表32位</span><br></pre></td></tr></table></figure></li><li><p>——CHP——</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较指令</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-爬虫-日志收集</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>（一）flume1.6<br>1.1 flume配置（将日志上传到HDFS离线分析和kafka实时分析）<br>a1.sources &#x3D; r1</p><p>a1.sinks &#x3D; k2 k1</p><p>a1.channels &#x3D; c2 c1</p><h1 id="Describe-configure-the-source"><a href="#Describe-configure-the-source" class="headerlink" title="Describe&#x2F;configure the source"></a>Describe&#x2F;configure the source</h1><p>a1.sources.r1.type &#x3D; exec</p><p>a1.sources.r1.command&#x3D;tail -n +0 -f &#x2F;usr&#x2F;lang&#x2F;log.log</p><p>a1.sources.r1.channels &#x3D; c1</p><p>a1.sources.r1.channels &#x3D; c2</p><h1 id="Describe-the-sink"><a href="#Describe-the-sink" class="headerlink" title="Describe the sink"></a>Describe the sink</h1><p>a1.sinks.k1.type &#x3D; hdfs</p><p>a1.sinks.k1.channel &#x3D; c1</p><p>a1.sinks.k1.hdfs.path &#x3D; hdfs:&#x2F;&#x2F;lang:8020&#x2F;user&#x2F;flume</p><p>a1.sinks.k1.hdfs.filePrefix &#x3D; events-</p><p>a1.sinks.k1.hdfs.round &#x3D; true</p><p>a1.sinks.k1.hdfs.roundValue &#x3D; 10</p><p>a1.sinks.k1.hdfs.roundUnit &#x3D; minute</p><p>a1.sinks.k2.channel&#x3D;c2</p><p>a1.sinks.k2.type&#x3D;org.apache.flume.sink.kafka.KafkaSink</p><p>a1.sinks.k2.topic&#x3D;lang</p><p>a1.sinks.k2.brokerList&#x3D;node1:9092</p><p>a1.sinks.k2.requiredAcks&#x3D;1</p><p>a1.sinks.k2.batchSize&#x3D;20</p><h1 id="Use-a-channel-which-buffers-events-in-memory"><a href="#Use-a-channel-which-buffers-events-in-memory" class="headerlink" title="Use a channel which buffers events in memory"></a>Use a channel which buffers events in memory</h1><p>a1.channels.c1.type &#x3D; memory</p><p>a1.channels.c1.capacity &#x3D; 1000</p><p>a1.channels.c1.transactionCapacity &#x3D; 100</p><p>a1.channels.c2.type &#x3D; memory</p><p>a1.channels.c2.capacity &#x3D; 1000</p><p>a1.channels.c2.transactionCapacity &#x3D; 100</p><p>1.2 flume启动<br>bin&#x2F;flume-ng  agent -c conf -f conf&#x2F;flume-conf -n a1 -Dflume.root.logger&#x3D;DEBUG,console</p><p>（二）kafka 0.11集群<br>2.1重要配置文件<br>server.properties:</p><pre><code>    broker.id=0  (根据实际主机，分配0,1,2)    listeners=PLAINTEXT://:9092    zookeeper.connect=192.168.205.11:2181,192.168.205.12:2181,192.168.205.13:2181</code></pre><p>producer.properties</p><pre><code>    bootstrap.servers=192.168.205.11:9092,192.168.205.12:9092,192.168.205.13:9092</code></pre><p>consumer.properties</p><pre><code>     zookeeper.connect=192.168.205.11:2181,192.168.205.12:2181,192.168.205.13:2181</code></pre><p>2.2同步配置文件<br>2.3相关命令<br>先启动zookeeper</p><p>启动kafka   bin&#x2F;kafka-server-start.sh config&#x2F;server.properties &amp;</p><p>停止kafka    bin&#x2F;kafka-server-stop.sh</p><p>创建topic     bin&#x2F;kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic lang</p><p>展示topic     bin&#x2F;kafka-topics.sh –list –zookeeper localhost:2181</p><p>描述topic     bin&#x2F;kafka-topics.sh –describe –zookeeper localhost:2181 –topic lang</p><p>生产者：      bin&#x2F;kafka-console-producer.sh –broker-list node1:9092 –topic lang</p><p>消费者：      bin&#x2F;kafka-console-consumer.sh -bootstrap-server localhost:9092 –topic lang –from-beginning</p><p>删除topic:     bin&#x2F;kafka-topics.sh –delete –zookeeper 130.51.23.95:2181 –topic topicname</p><p>(三)logstash5.5.1<br>3.1配置（文件输入，es输出）<br>input {</p><p>file {</p><p>path &#x3D;&gt; [“&#x2F;usr&#x2F;lang&#x2F;log.log”]</p><p>start_position &#x3D;&gt; “beginning”</p><p>}</p><p>}</p><p>filter {</p><p>date {</p><p>match &#x3D;&gt; [ “timestamp” , “YYYY-MM-dd HH:mm:ss” ]</p><p>}</p><p>}</p><p>output {</p><p>elasticsearch {</p><p>hosts &#x3D;&gt; [“192.168.205.14:9200”]</p><p>}</p><p>stdout {</p><p>codec &#x3D;&gt; rubydebug</p><p>}</p><p>}</p><p>3.2配置（kafka输入，es输出）<br>input {</p><p>kafka {</p><p>#workers &#x3D;&gt;2</p><p>bootstrap_servers &#x3D;&gt; “node1:9092,node2:9092,node3:9092”    #zookeeper地址</p><p>topics &#x3D;&gt; “lang”    #kafka中topic名称，记得创建该topic</p><p>#group_id &#x3D;&gt; “logstash”    #默认为“logstash”</p><p>#consumer_threads &#x3D;&gt;2    #消费的线程数</p><p>#reset_beginning &#x3D;&gt; false</p><p>#reset_beginning&#x3D;&gt;true</p><p>#decorate_events &#x3D;&gt; true    #在输出消息的时候回输出自身的信息，包括：消费消息的大小、topic来源以及consumer的group信息。</p><p>#type &#x3D;&gt; “nginx-access-log”</p><p>}</p><p>}</p><p>filter {</p><p>date {</p><p>match &#x3D;&gt; [ “timestamp” , “YYYY-MM-dd HH:mm:ss” ]</p><p>}</p><p>}</p><p>output {</p><p>elasticsearch {</p><p>hosts &#x3D;&gt; [“192.168.205.14:9200”]</p><p>#index &#x3D;&gt; “kafakindex-%{+YYYY.MM.dd}”</p><p>}</p><p>stdout {</p><p>codec &#x3D;&gt; rubydebug</p><p>}</p><p>}</p><p>（四）elasticsearch<br>4.1内存配置   config&#x2F;jvm.properties<br>4.2配置文件   config&#x2F;elsticsearch<br>cluster.name: my-application</p><p>node.name: node-1(集群中名称不一样)</p><p>network.host: 192.168.205.14</p><p>http.port: 9200</p><p>bootstrap.system_call_filter: false</p><p>http.cors.enabled: true</p><p>http.cors.allow-origin: “*”</p><p>4.3注意事项：Java内存参数，配置文件中空格问题<br>4.4elasticsearch-head（索引UI管理界面）<br>（五）kibana<br>没啥，直接启动</p><p>有问题直接联系我 QQ：1146941596</p><p>参考资料</p><p>1.elk安装（参照官网）</p><p><a href="http://blog.csdn.net/onlylove_longshao/article/details/72765696">http://blog.csdn.net/onlylove_longshao/article/details/72765696</a></p><p>2.注意点：操作系统内存2G，系统某些参数配置</p><p>3.elasticsearch-head 安装</p><pre><code>    http://blog.csdn.net/napoay/article/details/53896348</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储-bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-爬虫-滑块验证码</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="滑块验证码破解"><a href="#滑块验证码破解" class="headerlink" title="滑块验证码破解"></a>滑块验证码破解</h1><h3 id="方式一-数据发包"><a href="#方式一-数据发包" class="headerlink" title="方式一 数据发包"></a>方式一 数据发包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如zhongguorenshou.py,思路</span><br><span class="line">1.请求背景图片</span><br><span class="line">2.两张图片滑动距离（有的需要图片还原）</span><br><span class="line">3.更具滑动距离模拟生成鼠标滑动参数和时间</span><br></pre></td></tr></table></figure><h3 id="方式二-driver"><a href="#方式二-driver" class="headerlink" title="方式二 driver"></a>方式二 driver</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ru industry.py</span><br><span class="line">基于selenium+phantomjs 原理</span><br><span class="line"></span><br><span class="line">1.phantomjs 是一款基于浏览器内核软件</span><br><span class="line">2.通过selenium模拟人为操作</span><br><span class="line">3.缺点：和浏览器操作一样，慢</span><br><span class="line">4.优势：不用模拟鼠标滑动，易过调</span><br></pre></td></tr></table></figure><h3 id="方式三-收集滑动轨迹，存放到数据库"><a href="#方式三-收集滑动轨迹，存放到数据库" class="headerlink" title="方式三  收集滑动轨迹，存放到数据库"></a>方式三  收集滑动轨迹，存放到数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.请求背景图片</span><br><span class="line">2.两张图片滑动距离（有的需要图片还原）</span><br><span class="line">3.采用js hook 方式手机滑动轨迹</span><br></pre></td></tr></table></figure><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><p>v1 是老版本工商滑块 （无法使用了）<br>v2 通过发包的方式过滑块 （滑块跟新块，基本不考虑，无法使用）<br>v3 推荐使用滑块方式</p><p>more: v3介绍<br>亮点一：v3中的滑动距离计算，采用计算两张图片差值进行灰度化，在二值化（采用类间方差）<br>亮点二：轨迹生成方面采用算法更高效</p><h3 id="介绍js-hook"><a href="#介绍js-hook" class="headerlink" title="介绍js hook"></a>介绍js hook</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//目标hook函数startRecord</span><br><span class="line">//添加自己的日志代码</span><br><span class="line">orig = window.startRecord;</span><br><span class="line">window.startRecord=function(str)&#123;</span><br><span class="line">    orig(str);</span><br><span class="line">    console.log(&#x27;-----------typeMouse------------&#x27;);</span><br><span class="line">    console.log(typeMouse);</span><br><span class="line">    console.log(&#x27;-----------pageXAxis------------&#x27;);</span><br><span class="line">    console.log(pageXAxis);</span><br><span class="line">    console.log(&#x27;-----------pageYAxis------------&#x27;);</span><br><span class="line">    console.log(pageYAxis);</span><br><span class="line">    console.log(&#x27;-----------mouseTime------------&#x27;);</span><br><span class="line">    console.log(mouseTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：个人博客 <a href="https://langgithub.github.io/">https://langgithub.github.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 验证码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 验证码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-爬虫-简单图形验证码</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 准备</span><br><span class="line">1. brew install tesseract</span><br><span class="line">2. pip install pytesseract</span><br><span class="line">3. 去往https://github.com/tesseract-ocr/tessdata下载中文数据集chi_sim.traineddata，把它放到这目录下： /usr/local/Cellar/tesseract/3.05.01/share/tessdata</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pytesseract</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line"># open image</span><br><span class="line">image = Image.open(&#x27;test.png&#x27;)</span><br><span class="line">code = pytesseract.image_to_string(image, lang=&#x27;chi_sim&#x27;)</span><br><span class="line">print(code)</span><br></pre></td></tr></table></figure><p>总结：验证码处理步骤</p><ol><li>灰度化</li><li>二值化（涉及到找阀值 类间方差）</li><li>去干扰线</li><li>降噪 （高斯降噪）</li><li>切割</li><li>识别</li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫-js逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单图形验证码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-爬虫-群控</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E7%BE%A4%E6%8E%A7/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E7%BE%A4%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="手机群控"><a href="#手机群控" class="headerlink" title="手机群控"></a>手机群控</h1><h3 id="github项目浏览"><a href="#github项目浏览" class="headerlink" title="github项目浏览"></a>github项目浏览</h3><table><thead><tr><th align="left">项目</th><th align="right">地址</th><th align="right">原理</th></tr></thead><tbody><tr><td align="left">weiqunkong</td><td align="right"><a href="https://github.com/zhongxia245/weiqunkong">https://github.com/zhongxia245/weiqunkong</a></td><td align="right">Java Swing+ddmlib （adb通信）+Android录屏</td></tr><tr><td align="left">pc-android-controller-pc</td><td align="right"><a href="https://github.com/kaixuanluo/-pc-android-controller-pc">https://github.com/kaixuanluo/-pc-android-controller-pc</a></td><td align="right">Java Swing+ddmlib （adb通信）+Android录屏</td></tr><tr><td align="left">AndroidControl</td><td align="right"><a href="https://github.com/imharryzhu/AndroidControl">https://github.com/imharryzhu/AndroidControl</a></td><td align="right">spring web+usb连接（上传安装minicap，minitouch）</td></tr><tr><td align="left">openstf</td><td align="right"><a href="https://github.com/langgithub/stf">https://github.com/langgithub/stf</a></td><td align="right">nodejs web+usb连接（上传安装minicap，minitouch）</td></tr><tr><td align="left">atx-server</td><td align="right"><a href="https://github.com/openatx/atx-server">https://github.com/openatx/atx-server</a></td><td align="right">go web+wifi（上传安装minicap，minitouch）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手机群控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试对比</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="自动化对比"><a href="#自动化对比" class="headerlink" title="自动化对比"></a>自动化对比</h2><table><thead><tr><th align="left">模块</th><th align="right">UIAutomation</th><th align="right">appium</th><th align="right">selenium</th><th align="right">pyppeteer</th><th align="right">终极武器(chrome-devtools-protocol)</th></tr></thead><tbody><tr><td align="left">跨平台</td><td align="right">否</td><td align="right">Android，ios</td><td align="right">是</td><td align="right">chrome 浏览器就行</td><td align="right">是</td></tr><tr><td align="left">缺点</td><td align="right">无法跨平台</td><td align="right">adb驱动</td><td align="right">太强大</td><td align="right">chrome 协议</td><td align="right">底层</td></tr><tr><td align="left">driver</td><td align="right">google原生</td><td align="right">UIAutomation</td><td align="right">#很多</td><td align="right">chrome</td><td align="right">all</td></tr></tbody></table><p>#很多：</p><ol><li><p>selenium可支持的PC浏览器驱动包括：</p><p> safari driver【包含在selenium server中】</p><p> ie driver</p><p> chrome driver 【第三方】</p><p> opera driver【第三方]</p></li><li><p>selenium可支持的伪浏览器驱动：</p><p> PhantomJS Driver【第三方,停止更新】</p><p> HtmlUnit Driver【包含在selenium server中】</p></li><li><p>selenium可支持的移动端驱动：</p><p> Windows Phone driver </p><p> Selendroid-Selenium for Android【第三方】</p><p> ios-driver【第三方】</p><p> Appium 支持iphone、ipad、android、FirefoxOS【第三方】</p></li></ol><h2 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h2><ul><li><h3 id="UIAutomation"><a href="#UIAutomation" class="headerlink" title="UIAutomation"></a>UIAutomation</h3></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">python 端安装 uiautomator2 client：</span><br><span class="line">pip install uiautomator2</span><br><span class="line">Android端安装 ATX server</span><br><span class="line">安装方法</span><br><span class="line">离线</span><br><span class="line">    将init_machine.sh,及android_package.zip上传至/data/local/tmp目录下</span><br><span class="line">    给手机安装termux，此为命令行工具，打开软件</span><br><span class="line">    输入su,切换至管理员账户</span><br><span class="line">    输入cd data/local/tmp,因为云手机不能打/符，所有用tab键来凑齐。</span><br><span class="line">    输入sh init_machine.sh,即可安装好软件和服务</span><br><span class="line">    </span><br><span class="line">usb线连</span><br><span class="line">    在电脑上输入python -m uiautomator2 init即可</span><br><span class="line">    ### 2、打开ATX</span><br><span class="line">    打开ATX 点击&quot;启动uiautomator&quot;</span><br><span class="line">    ### 3、打开QpythonL</span><br><span class="line">    一定要先打开这个软件，不然你python脚本会上传不成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import uiautomator2 as u2</span><br><span class="line"></span><br><span class="line"># 0.0.0.0 为本机，127.0.0.1这个也行，这个连接是在手机上运行的</span><br><span class="line">d = u2.connect(&#x27;http://0.0.0.0:7912&#x27;)</span><br><span class="line"># 如果远程操作，就填入手机ATX显示的ip，下面有图</span><br><span class="line"># d = u2.connect(&#x27;http://172.17.2.237:7912&#x27;)</span><br><span class="line"># 字符串为包名，下面有获取包名教程</span><br><span class="line">sess = d.session(&quot;com.tencent.wework&quot;)</span><br><span class="line"></span><br><span class="line">def my_click(sess, ele, timeout=3):</span><br><span class="line">    ele.wait(timeout=timeout) # 等待超时，因为可能此时界面动画，或者反映迟钝，该控件还没出现</span><br><span class="line">    x, y = ele.center() # 找到该空间的中间坐标</span><br><span class="line">    sess.touch.down(x, y) # 在此坐标按下</span><br><span class="line">    time.sleep(0.3)</span><br><span class="line">    sess.touch.up() #等待3秒后抬起</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def click_search_btn(sess):</span><br><span class="line">    ele = sess(resourceId=package_name+&quot;:id/e3g&quot;, #找到该空间的id</span><br><span class="line">               className=&quot;android.widget.TextView&quot;,# 找到该空间的类名</span><br><span class="line">               instance=0) #如果根据属性查找有多个控件，则找第一个</span><br><span class="line">    my_click(sess, ele, 20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">click_search_btn(sess)</span><br><span class="line">print(&#x27;begin to input&#x27;)</span><br><span class="line">ele = sess(resourceId=&quot;com.tencent.wework:id/dpu&quot;, className=&quot;android.widget.EditText&quot;)</span><br><span class="line">ele.set_text(phone) # 将手机号填入</span><br><span class="line">print(&#x27;end to input&#x27;)</span><br><span class="line">time.sleep(2)</span><br><span class="line"># print(u&quot;点击搜索&quot;)</span><br><span class="line"># 点击搜索</span><br><span class="line">sess(resourceId=&quot;com.tencent.wework:id/azq&quot;,</span><br><span class="line">           className=&quot;android.widget.RelativeLayout&quot;).child(className=&quot;android.widget.TextView&quot;).click() # 因为该控件没有id，所以先找它爹，再找它爹的儿子控件，.click()直接触发点击事件。</span><br><span class="line">ele1 = sess(resourceId=&quot;com.tencent.wework:id/sa&quot;,</span><br><span class="line">               className=&quot;android.widget.TextView&quot;)</span><br><span class="line">ele1.get_text() # 获取标签文本内容</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h3 id="Seleinum"><a href="#Seleinum" class="headerlink" title="Seleinum"></a>Seleinum</h3></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装：</span><br><span class="line">pip install selenium</span><br><span class="line">自行下载需要驱动的driver：如chromedriver</span><br><span class="line">实用executable_path 引入driver路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">drivers = [&#x27;HtmlUnit&#x27;, &#x27;PhantomJS&#x27;, &#x27;Chrome&#x27;, &#x27;FF&#x27;, &#x27;IE&#x27;] </span><br><span class="line"> </span><br><span class="line">dervers_time = &#123;</span><br><span class="line">&#x27;HtmlUnit&#x27; : 0,</span><br><span class="line">&#x27;PhantomJS&#x27; : 0,</span><br><span class="line">&#x27;Chrome&#x27; : 0,</span><br><span class="line">&#x27;FF&#x27; : 0,</span><br><span class="line">&#x27;IE&#x27; : 0,</span><br><span class="line">&#125;</span><br><span class="line">times = 50</span><br><span class="line">def run_with_Chrome():</span><br><span class="line">common_step(webdriver.Chrome())</span><br><span class="line"> </span><br><span class="line">def run_with_FF():</span><br><span class="line">common_step(webdriver.Firefox())</span><br><span class="line"></span><br><span class="line">def run_with_IE():</span><br><span class="line">common_step(webdriver.Ie())</span><br><span class="line"> </span><br><span class="line">def run_with_PhantomJS():</span><br><span class="line">common_step(webdriver.PhantomJS(executable_path=r&#x27;C:\Python27\Scripts\phantomjs.exe&#x27;))</span><br><span class="line"></span><br><span class="line">def run_with_HtmlUnit():</span><br><span class="line">driver = webdriver.Remote(&quot;http://localhost:4444/wd/hub&quot;, </span><br><span class="line">desired_capabilities=webdriver.DesiredCapabilities.HTMLUNIT)</span><br><span class="line">common_step(driver)</span><br><span class="line"></span><br><span class="line">def common_step(driver):</span><br><span class="line">driver.get(&#x27;http://www.baidu.com&#x27;)</span><br><span class="line">ele = driver.find_element_by_id(&#x27;su&#x27;)</span><br><span class="line">print ele.get_attribute(&#x27;value&#x27;)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><ul><li><h3 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h3></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.node.js 安装</span><br><span class="line">brew install node</span><br><span class="line">npm install -g appium  # get appium     </span><br><span class="line">npm install wd         # get appium client</span><br><span class="line"></span><br><span class="line">直接用npm下载往往不成功，这是需要通过代理来下载</span><br><span class="line">具体方法如下：</span><br><span class="line">npm i cnpm -g --registry=http://registry.npm.taobao.org</span><br><span class="line">cnpm i appium -g       # get appium</span><br><span class="line">cnpm i wd -g　　       # get appium client</span><br><span class="line">cnpm i appium-doctor 　# get appium-doctor</span><br><span class="line"></span><br><span class="line">2.检查Appium成功安装</span><br><span class="line">appium-doctor</span><br><span class="line">更具提示配置 xcode 和 Android SDK</span><br><span class="line"></span><br><span class="line">3.下载appium客户端更加方便地址 github</span><br><span class="line">4.python client 安装 pip install Appium_Python_Client</span><br><span class="line">5.启动appium server .用客户端appium 启动即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># encoding: utf-8</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">--------------------------------------</span><br><span class="line">@describe 自动化微信添加好友</span><br><span class="line">@version: 1.0</span><br><span class="line">@project: operator_spider</span><br><span class="line">@file: app_chrome.py</span><br><span class="line">@author: yuanlang </span><br><span class="line">@time: 2019-02-19 10:14</span><br><span class="line">---------------------------------------</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import unittest</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def setUp(self):</span><br><span class="line">        capabilities = &#123;</span><br><span class="line">            &#x27;platformName&#x27;: &#x27;Android&#x27;,</span><br><span class="line">            &#x27;platformVersion&#x27;: &quot;5.1&quot;,</span><br><span class="line">            &#x27;deviceName&#x27;: &quot;mx4&quot;,</span><br><span class="line">            &#x27;appPackage&#x27;: &#x27;com.tencent.mm&#x27;,</span><br><span class="line">            &#x27;appActivity&#x27;: &#x27;.ui.LauncherUI&#x27;,</span><br><span class="line">            &#x27;automationName&#x27;: &#x27;Uiautomator2&#x27;,</span><br><span class="line">            &#x27;unicodeKeyboard&#x27;: True,</span><br><span class="line">            &#x27;resetKeyboard&#x27;: True,</span><br><span class="line">            &#x27;noReset&#x27;: True,</span><br><span class="line">            &#x27;chromeOptions&#x27;: &#123;&#x27;androidProcess&#x27;: &#x27;com.tencent.mm:tools&#x27;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        self.driver = webdriver.Remote(&quot;http://127.0.0.1:4723/wd/hub&quot;, capabilities)</span><br><span class="line">        self.driver.implicitly_wait(30)</span><br><span class="line"></span><br><span class="line">        sleep(5)</span><br><span class="line"></span><br><span class="line">    def test_chromeApp(self):</span><br><span class="line">        # 点击加号</span><br><span class="line">        print(&quot;search&quot;)</span><br><span class="line">        driver = self.driver</span><br><span class="line">        el1 = driver.find_element_by_id(&quot;com.tencent.mm:id/gd&quot;)</span><br><span class="line">        el1.click()</span><br><span class="line">        sleep(5)</span><br><span class="line">        el2 = driver.find_element_by_xpath(</span><br><span class="line">            &quot;/hierarchy/android.widget.FrameLayout/android.widget.ListView/android.widget.LinearLayout[2]/android.widget.LinearLayout/android.widget.TextView&quot;)</span><br><span class="line">        el2.click()</span><br><span class="line">        sleep(5)</span><br><span class="line">        el3 = driver.find_element_by_id(&quot;com.tencent.mm:id/hx&quot;)</span><br><span class="line">        el3.click()</span><br><span class="line">        sleep(5)</span><br><span class="line">        driver.find_element_by_id(&quot;com.tencent.mm:id/hx&quot;).send_keys(&quot;15775691981&quot;)</span><br><span class="line">        sleep(5)</span><br><span class="line">        driver.find_element_by_id(&quot;com.tencent.mm:id/l4&quot;).click()</span><br><span class="line">        sleep(5)</span><br><span class="line">        print(driver.context)</span><br><span class="line">        name = driver.find_element_by_id(&quot;com.tencent.mm:id/ang&quot;).text</span><br><span class="line">        print(name)</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        self.driver.close_app()</span><br><span class="line">        self.driver.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    unittest.main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pyppeteer"><a href="#pyppeteer" class="headerlink" title="pyppeteer"></a>pyppeteer</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原生是node.js 开发基于chrome-devtools-protocol + websocket</span><br><span class="line">python也有对应改写版</span><br><span class="line">项目由google维护</span><br><span class="line"></span><br><span class="line">pip install pyppeteer</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># encoding: utf-8</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">--------------------------------------</span><br><span class="line">@describe </span><br><span class="line">@version: 1.0</span><br><span class="line">@project: operator_spider</span><br><span class="line">@file: dddd.py</span><br><span class="line">@author: yuanlang </span><br><span class="line">@time: 2019-02-21 19:11</span><br><span class="line">---------------------------------------</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import asyncio</span><br><span class="line">import pyppeteer</span><br><span class="line">from collections import namedtuple</span><br><span class="line"></span><br><span class="line">Response = namedtuple(&quot;rs&quot;, &quot;title url html cookies headers history status&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def get_html(url, timeout=30):</span><br><span class="line">    # 默认30s</span><br><span class="line">    #,executablePath=&quot;&quot;</span><br><span class="line">    browser = await pyppeteer.launch(headless=False, args=[&#x27;--no-sandbox&#x27;])</span><br><span class="line">    page = await  browser.newPage()</span><br><span class="line">    js=&quot;&quot;&quot;</span><br><span class="line">    function sniffDetector() &#123;</span><br><span class="line">    const userAgent = window.navigator.userAgent;</span><br><span class="line">    const platform = window.navigator.platform;</span><br><span class="line"></span><br><span class="line">    window.navigator.__defineGetter__(&#x27;userAgent&#x27;, function() &#123;</span><br><span class="line">      window.navigator.sniffed = true;</span><br><span class="line">      return userAgent;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    window.navigator.__defineGetter__(&#x27;platform&#x27;, function() &#123;</span><br><span class="line">      window.navigator.sniffed = true;</span><br><span class="line">      return platform;</span><br><span class="line">    &#125;);</span><br><span class="line">    //自动化反反爬虫，反自动化检测</span><br><span class="line">    Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;</span><br><span class="line">        get: () =&gt; false,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    await page.evaluateOnNewDocument(js)</span><br><span class="line">    res = await page.goto(url, options=&#123;&#x27;timeout&#x27;: int(timeout * 1000)&#125;)</span><br><span class="line">    await asyncio.sleep(5)</span><br><span class="line">    data = await page.content()</span><br><span class="line">    title = await page.title()</span><br><span class="line">    resp_cookies = await page.cookies()</span><br><span class="line">    resp_headers = res.headers</span><br><span class="line">    resp_history = None</span><br><span class="line">    resp_status = res.status</span><br><span class="line">    response = Response(title=title, url=url,</span><br><span class="line">                        html=data,</span><br><span class="line">                        cookies=resp_cookies,</span><br><span class="line">                        headers=resp_headers,</span><br><span class="line">                        history=resp_history,</span><br><span class="line">                        status=resp_status)</span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url_list = [&quot;https://jx.ac.10086.cn&quot;]</span><br><span class="line">    task = (get_html(url) for url in url_list)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    results = loop.run_until_complete(asyncio.gather(*task))</span><br><span class="line">    for res in results:</span><br><span class="line">        print(res)</span><br></pre></td></tr></table></figure><h2 id="chrome-devtools-protocol"><a href="#chrome-devtools-protocol" class="headerlink" title="chrome-devtools-protocol"></a>chrome-devtools-protocol</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">底层采用websocket 协议控制浏览器。[协议连接](https://chromedevtools.github.io/devtools-protocol/)</span><br><span class="line">安装</span><br><span class="line">1.pip install pychrom</span><br><span class="line">2./Chromium --remote-debugging-port=9222</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import pychrome</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser(url=&quot;http://127.0.0.1:9222&quot;)</span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">def request_will_be_sent(**kwargs):</span><br><span class="line">    print(&quot;loading: %s&quot; % kwargs.get(&#x27;request&#x27;).get(&#x27;url&#x27;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab.set_listener(&quot;Network.requestWillBeSent&quot;, request_will_be_sent)</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.call_method(&quot;Network.enable&quot;)</span><br><span class="line">tab.call_method(&quot;Page.navigate&quot;, url=&quot;https://jx.ac.10086.cn&quot;, _timeout=5)</span><br><span class="line">import time</span><br><span class="line"># print(&quot;ok&quot;)</span><br><span class="line">time.sleep(5)</span><br><span class="line">result=tab.call_method(&quot;Runtime.evaluate&quot;,expression=&quot;document.documentElement.outerHTML&quot;)</span><br><span class="line">print(result)</span><br><span class="line">tab.stop()</span><br></pre></td></tr></table></figure><h1 id="自动化反反爬虫"><a href="#自动化反反爬虫" class="headerlink" title="自动化反反爬虫"></a>自动化反反爬虫</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;</span><br><span class="line">        get: () =&gt; false,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">// overwrite the `languages` property to use a custom getter</span><br><span class="line">Object.defineProperty(navigator, &quot;languages&quot;, &#123;</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return [&quot;zh-CN&quot;,&quot;zh&quot;,&quot;zh-TW&quot;,&quot;en-US&quot;,&quot;en&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Overwrite the `plugins` property to use a custom getter.</span><br><span class="line">Object.defineProperty(navigator, &#x27;plugins&#x27;, &#123;</span><br><span class="line">  get: () =&gt; [1, 2, 3, 4, 5],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Pass the Webdriver test</span><br><span class="line">Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;</span><br><span class="line">  get: () =&gt; false,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Pass the Chrome Test.</span><br><span class="line">// We can mock this in as much depth as we need for the test.</span><br><span class="line">window.navigator.chrome = &#123;</span><br><span class="line">  runtime: &#123;&#125;,</span><br><span class="line">  // etc.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Pass the Permissions Test.</span><br><span class="line">const originalQuery = window.navigator.permissions.query;</span><br><span class="line">window.navigator.permissions.query = (parameters) =&gt; (</span><br><span class="line">  parameters.name === &#x27;notifications&#x27; ?</span><br><span class="line">    Promise.resolve(&#123; state: Notification.permission &#125;) :</span><br><span class="line">    originalQuery(parameters)</span><br><span class="line">);</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 修改chromedriver</span><br><span class="line">$ hexedit chromedriver </span><br><span class="line"></span><br><span class="line">        # 操作</span><br><span class="line">        1. tab 跳转到string栏</span><br><span class="line">        2. ctrl+S 查找 var key = &#x27;$cdc_asdjflasutopfhvcZLmcfl_&#x27;（对于2.40版本）</span><br><span class="line">        3. 替换&#x27;$cdc_asdjflasutopfhvcZLmcfl_&#x27;为任意值</span><br><span class="line">        4. ctrl+X 保存</span><br><span class="line"></span><br><span class="line"># 移动chromedriver 到 /usr/bin</span><br><span class="line">$ mv chromedriver /usr/bin</span><br><span class="line"></span><br><span class="line">[详细连接](&quot;https://zhuanlan.zhihu.com/p/43581988?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=32546582691840&amp;from=groupmessage&quot;)</span><br></pre></td></tr></table></figure><p>总结：seleium 是采用webdriver 协议 ,seleium server端也是使用chrome-devtools-protocol。只不过为了跨平台采用webdriver restful api 形式开发。chrome-devtools-protocol 可以使用 .&#x2F;chromium –remote-debug 自动化测试</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫-玄学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-爬虫-跨域实现</title>
      <link href="/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/05/18/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域实现"><a href="#跨域实现" class="headerlink" title="跨域实现"></a>跨域实现</h1><!-- TOC --><ul><li><ol><li>General</li></ol><ul><li>1.1. 跨域解决方案<ul><li>1.1.1. jsonp</li><li>1.1.2. cors跨域</li><li>1.1.3. 中间代理服务器跨域</li><li>1.1.4. iframe跨域</li><li>1.1.5. websocket跨域</li><li>1.1.6. 其他</li></ul></li></ul></li></ul><!-- /TOC --><h2 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h2><p>跨域实现总结 <a href="https://www.imooc.com/article/291931">https://www.imooc.com/article/291931</a></p><h3 id="1-1-跨域解决方案"><a href="#1-1-跨域解决方案" class="headerlink" title="1.1. 跨域解决方案"></a>1.1. 跨域解决方案</h3><h4 id="1-1-1-jsonp"><a href="#1-1-1-jsonp" class="headerlink" title="1.1.1. jsonp"></a>1.1.1. jsonp</h4><p>jsonp 是利用同源策略漏洞的一种实现跨域方式。script 标签是支持跨域的。只要script标签的src里携带要回调的函数名称，当服务器返回回调函数及数据就能被浏览器所解析执行<br>详细可看 <a href="http://www.nowamagic.net/librarys/veda/detail/224">http://www.nowamagic.net/librarys/veda/detail/224</a></p><h4 id="1-1-2-cors跨域"><a href="#1-1-2-cors跨域" class="headerlink" title="1.1.2. cors跨域"></a>1.1.2. cors跨域</h4><p>需要跨域的服务器添加cors 跨域参数<br>具体参数含义可见 <a href="https://javascript.ruanyifeng.com/bom/cors.html">https://javascript.ruanyifeng.com/bom/cors.html</a></p><h4 id="1-1-3-中间代理服务器跨域"><a href="#1-1-3-中间代理服务器跨域" class="headerlink" title="1.1.3. 中间代理服务器跨域"></a>1.1.3. 中间代理服务器跨域</h4><ol><li>B-&gt;C,A-&gt;B</li><li>if A-&gt;C</li><li>so A-&gt;B-&gt;C</li></ol><h4 id="1-1-4-iframe跨域"><a href="#1-1-4-iframe跨域" class="headerlink" title="1.1.4. iframe跨域"></a>1.1.4. iframe跨域</h4><h4 id="1-1-5-websocket跨域"><a href="#1-1-5-websocket跨域" class="headerlink" title="1.1.5. websocket跨域"></a>1.1.5. websocket跨域</h4><h4 id="1-1-6-其他"><a href="#1-1-6-其他" class="headerlink" title="1.1.6. 其他"></a>1.1.6. 其他</h4>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android IPC</title>
      <link href="/2025/05/18/Android-framwork-IPC/"/>
      <url>/2025/05/18/Android-framwork-IPC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android类加载</title>
      <link href="/2025/05/18/Android-framwork-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2025/05/18/Android-framwork-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="android中的classloader"><a href="#android中的classloader" class="headerlink" title="android中的classloader"></a>android中的classloader</h1><ol><li>BootClassLoader，Android系统启动时会使用BootClassLoader来预加载常用类，与Java中的Bootstrap ClassLoader不同的是，它并不是由C&#x2F;C++代码实现，而是由Java实现的。BootClassLoader是ClassLoader的一个内部类。</li><li>PathClassLoader，全名是dalvik&#x2F;system.PathClassLoader，可以加载已经安装的Apk，也就是&#x2F;data&#x2F;app&#x2F;package 下的apk文件，也可以加载&#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib下的nativeLibrary。</li><li>DexClassLoader，全名是dalvik&#x2F;system.DexClassLoader，可以加载一个未安装的apk文件。</li></ol><p>App系统类加载器是PathClassLoader，而BootClassLoader是其parent类加载器。</p><h1 id="android中class类加载过程"><a href="#android中class类加载过程" class="headerlink" title="android中class类加载过程"></a>android中class类加载过程</h1><ol><li>BaseDexClassLoader</li><li>DexPathList</li><li>makeDexElements</li><li>loadDexFile</li><li>loadDex</li><li>loadClassBinaryName</li><li>defineClass</li></ol><h1 id="android热修复问题"><a href="#android热修复问题" class="headerlink" title="android热修复问题"></a>android热修复问题</h1><p>因为存放dex是一个数组DexElements ，在加载class类对象是按顺序从dex中加载，所以将修复的dex放在数组前面可完成热修复问题</p>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件</title>
      <link href="/2025/05/18/Android-framwork-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
      <url>/2025/05/18/Android-framwork-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h2><!-- TOC --><ul><li><a href="#android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6">Android四大组件</a><ul><li><a href="#gerneral">Gerneral</a><ul><li><a href="#activity">Activity</a></li><li><a href="#service">Service</a></li><li><a href="#broadcastreceiver">BroadcastReceiver</a></li><li><a href="#contentprovider">ContentProvider</a></li></ul></li></ul></li></ul><!-- /TOC --><h3 id="Gerneral"><a href="#Gerneral" class="headerlink" title="Gerneral"></a>Gerneral</h3><p>Android开发常用知识储备。Android的四大组件中除了BroadCastReceiver以外，其他三种组件都必须在AndroidManifest中注册<br>才能使用</p><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p><img src="/img/005EpKr8ly1g3oy01r9m7j30hd0j1wfy.jpg" alt="activity"></p><ol><li>Activity生命周期</li></ol><ul><li>完整生存期：活动在onCreate()和onDestroy()方法之间所经历的</li><li>可见生存期：活动在onStart()和onStop()方法之间所经历的</li><li>交互活动期：活动在onResume()和onPause()方法之间所经历的</li></ul><ol start="2"><li>Activity注册<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;com.lang.payhelper.SettingActivity&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li>容易忽略重点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBackPressed() &#123;</span><br><span class="line">    // sendmsg(&quot;触发 onBackPressed&quot;); 界面上的回退</span><br><span class="line">    moveTaskToBack(true);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</span><br><span class="line">    // 过滤按键动作</span><br><span class="line">    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        sendmsg(&quot;触发 KeyEvent.KEYCODE_BACK&quot;);</span><br><span class="line">        moveTaskToBack(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;</span><br><span class="line">    // 异常恢复 </span><br><span class="line">    // TODO:这个还不是很理解</span><br><span class="line">    super.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><img src="/img/android-service.jpg" alt="Service"></p><ol><li>注册service<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;com.lang.payhelper.payhook.DaemonService&quot;</span><br><span class="line">    android:enabled=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    android:process=&quot;:daemon_service&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li>启动service方式</li></ol><ul><li>本进程 startService(new Intent(this, DaemonService.class));</li><li>非本进程 bindService （案例 <a href="https://blog.csdn.net/iispring/article/details/48169339">https://blog.csdn.net/iispring/article/details/48169339</a> ）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bindService(intent, new ServiceConnection() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onServiceDisconnected(ComponentName componentName) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure></li></ul><h4 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h4><ol><li>动态注册  registerReceiver(Received, intentFilter);</li></ol><ul><li>Received 处理广播的类，继承BroadcastReceiver</li><li>intentFilter 关注的话题<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter intentFilter = new IntentFilter();</span><br><span class="line">intentFilter.addAction(BILLRECEIVED_ACTION);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>静态注册<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.activity.broadcastreceiver.staticregist.StaticReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.broadcast.static&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure></li><li>有序广播 priority越小优先执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">    android:name=&quot;.activity.broadcastreceiver.orderregist.FirstReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter android:priority=&quot;300&quot;&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.broadcast.order&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br><span class="line">&lt;receiver</span><br><span class="line">    android:name=&quot;.activity.broadcastreceiver.orderregist.SecondReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter android:priority=&quot;200&quot;&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.broadcast.order&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br><span class="line">&lt;receiver</span><br><span class="line">    android:name=&quot;.activity.broadcastreceiver.orderregist.ThirdReveiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter android:priority=&quot;100&quot;&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.broadcast.order&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure></li><li>本地广播</li></ol><h4 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h4><ol><li>原理<br>数据通过唯一的 URI 标识来源。ContentProvider 将数据看作表，查询 &#x2F; 操作数据的时候，通过类似数据库操作的 insert &#x2F; delete &#x2F; query &#x2F; update 方法来实现增删查改操作。因此包含数据提供方和使用方</li><li>提供方 Provider (案例 <a href="https://www.jianshu.com/p/ac40ed95d577">https://www.jianshu.com/p/ac40ed95d577</a>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission</span><br><span class="line">    android:name=&quot;com.straw.providerhost.course.read&quot;</span><br><span class="line">    android:protectionLevel=&quot;normal&quot;/&gt;</span><br><span class="line">&lt;permission</span><br><span class="line">    android:name=&quot;com.straw.providerhost.course.write&quot;</span><br><span class="line">    android:protectionLevel=&quot;normal&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;application&gt;</span><br><span class="line">    &lt;provider</span><br><span class="line">        android:authorities=&quot;com.straw.course&quot;</span><br><span class="line">        android:name=&quot;com.straw.providerhost.CourseContentProvider&quot;</span><br><span class="line">        android:exported=&quot;true&quot;</span><br><span class="line">        android:readPermission=&quot;com.straw.providerhost.course.read&quot;</span><br><span class="line">        android:writePermission=&quot;com.straw.providerhost.course.write&quot;/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure></li><li>使用方 ContentReciver.query(uri)的方式获取数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android自曝签名剖析</title>
      <link href="/2025/05/18/Android-framwork-%E8%87%AA%E6%9B%9D%E7%AD%BE%E5%90%8D%E5%89%96%E6%9E%90/"/>
      <url>/2025/05/18/Android-framwork-%E8%87%AA%E6%9B%9D%E7%AD%BE%E5%90%8D%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h5 id="注-本次解读是对尼古拉斯赵四项目中自曝签名解读"><a href="#注-本次解读是对尼古拉斯赵四项目中自曝签名解读" class="headerlink" title="注:本次解读是对尼古拉斯赵四项目中自曝签名解读"></a>注:本次解读是对尼古拉斯赵四项目中自曝签名解读</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  *content: Activity</span><br><span class="line">  *signed:签名信息</span><br><span class="line">  */</span><br><span class="line">public static void hookPMS(Context context, String signed)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">            Method currentActivityThreadMethod =</span><br><span class="line">                    activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);</span><br><span class="line">            Object currentActivityThread = currentActivityThreadMethod.invoke(null);</span><br><span class="line">            Field sPackageManagerField = activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);</span><br><span class="line">            sPackageManagerField.setAccessible(true);</span><br><span class="line">            Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line">            Class&lt;?&gt; iPackageManagerInterface = Class.forName(&quot;android.content.pm.IPackageManager&quot;);</span><br><span class="line"></span><br><span class="line">            // 代码编号1</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(</span><br><span class="line">                    iPackageManagerInterface.getClassLoader(),</span><br><span class="line">                    new Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;,</span><br><span class="line">                    new PmsHookBinderInvocationHandler(sPackageManager, signed));</span><br><span class="line">            //代码编号2</span><br><span class="line">            sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line">            PackageManager pm = context.getPackageManager();</span><br><span class="line">            Log.i(&quot;jw&quot;, &quot;pm:&quot;+pm);</span><br><span class="line">            Field mPmField = pm.getClass().getDeclaredField(&quot;mPM&quot;);</span><br><span class="line">            mPmField.setAccessible(true);</span><br><span class="line">            mPmField.set(pm, proxy);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            Log.d(&quot;jw&quot;, &quot;hook pms error:&quot;+Log.getStackTraceString(e));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import android.content.pm.PackageInfo;</span><br><span class="line">import android.content.pm.PackageManager;</span><br><span class="line">import android.content.pm.Signature;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态代理</span><br><span class="line"> */</span><br><span class="line">public class PmsHookBinderInvocationHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">    private Object base;</span><br><span class="line">    </span><br><span class="line">    private String SIGN;</span><br><span class="line"></span><br><span class="line">    public PmsHookBinderInvocationHandler(Object base, String sign) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.base = base;</span><br><span class="line">            this.SIGN = sign;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.d(&quot;jw&quot;, &quot;error:&quot;+Log.getStackTraceString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            if(&quot;getPackageInfo&quot;.equals(method.getName()))&#123;</span><br><span class="line">                String pkgName = (String)args[0];</span><br><span class="line">                Integer flag = (Integer)args[1];</span><br><span class="line">                if(flag == PackageManager.GET_SIGNATURES &amp;&amp; &quot;lang.com.douyin&quot;.equals(pkgName))&#123;</span><br><span class="line">                    Signature sign = new Signature(SIGN);</span><br><span class="line">                    PackageInfo info = (PackageInfo) method.invoke(base, args);</span><br><span class="line">                    info.signatures[0] = sign;</span><br><span class="line">                    return info;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码编号1-理解动态代理"><a href="#代码编号1-理解动态代理" class="headerlink" title="代码编号1-理解动态代理"></a>代码编号1-理解动态代理</h3><p> 核心原理：在内存中生存继承PmsHookBinderInvocationHandler代理类，实现iPackageManagerInterface接口的类</p><h3 id="代码编号2-替换pm"><a href="#代码编号2-替换pm" class="headerlink" title="代码编号2-替换pm"></a>代码编号2-替换pm</h3><p>  替换系统中的PackageManager</p><h3 id="里面设计到的ActivityThread，IPackageManager等貌似不能Android代码中导入，还需要进一步调试Android源码，查明原因"><a href="#里面设计到的ActivityThread，IPackageManager等貌似不能Android代码中导入，还需要进一步调试Android源码，查明原因" class="headerlink" title="里面设计到的ActivityThread，IPackageManager等貌似不能Android代码中导入，还需要进一步调试Android源码，查明原因"></a>里面设计到的ActivityThread，IPackageManager等貌似不能Android代码中导入，还需要进一步调试Android源码，查明原因</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android EventBus</title>
      <link href="/2025/05/18/Android-framworkEventBus/"/>
      <url>/2025/05/18/Android-framworkEventBus/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码(1)-Android源码学习指南</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(1)-Android%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(1)-Android%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一-准备"><a href="#一-准备" class="headerlink" title="一. 准备"></a>一. 准备</h1><ul><li>Java&#x2F;C&#x2F;C++基础，Java Framwork和C++ Framework, 一部分Lib则采用C.</li><li>Linux相关知识，Android是基于Linux内核</li><li>MakeFile知识，Android采用make编译，可以看到很多Android.mk类似的文件</li><li>Source insight,源码阅读工具神器。（我个人mac电脑是用git + Android stadio）</li><li>StartUML,类图工具（mac omniGraffle）</li><li>ProcessOn&#x2F;Visio,流程图工具</li></ul><h1 id="二-入门学习"><a href="#二-入门学习" class="headerlink" title="二. 入门学习"></a>二. 入门学习</h1><ul><li>Android官方培训 Android training（<a href="https://developer.android.com/training/index.html%EF%BC%89">https://developer.android.com/training/index.html）</a></li><li>胡凯发起的 Android官方培训课程中文版（<a href="http://hukai.me/android-training-course-in-chinese/index.html%EF%BC%89">http://hukai.me/android-training-course-in-chinese/index.html）</a></li></ul><h1 id="三-进阶学习"><a href="#三-进阶学习" class="headerlink" title="三. 进阶学习"></a>三. 进阶学习</h1><p><img src="/img/316892-20160117121057022-207634193.png" alt="Android架构图"></p><ul><li>Application层，和用户直接交互，Java开发</li><li>Java Framework层，Android api </li><li>C++ Framework&#x2F;Libraries层，这一层提供动态库，Android运行库，Dalvik虚拟机等，也叫Native层</li><li>Linux Kernel 层，Android是基于Linux内核，其核心进程管理，内存管理，文件管理，设备管理，网络协议，驱动之类</li></ul><h1 id="四-Android框架"><a href="#四-Android框架" class="headerlink" title="四. Android框架"></a>四. Android框架</h1><p>学习整体概念框架<br><img src="/img/android-boot-up.png" alt="Android架构图"></p><p>4.1 Loader层</p><ol><li><p>Boot ROM<br>上电后，BootRom被激活，引导芯片代码从（固化在ROM）执行，加载引导程序到RAM</p></li><li><p>BootLoader 引导程序<br>BootLoader 是启动Android系统之前的引导程序，引导程序是厂商设定，针对特定的主板和芯片。BootLoader主要作用是检查RAM，初始化硬件参数等功能</p></li></ol><p>4.2 Kernel层<br>Kernel 层启动流程:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alps/kernel/init/main.c</span><br><span class="line">start_kernel() ==&gt; rest_init() ==&gt; kernel_thread(kernel_init) ==&gt; kernel_init()</span><br></pre></td></tr></table></figure><p>0号进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapper进程(pid=0):又称为idle进程，即空闲进程，由系统自动创建，运行在内核态。</span><br><span class="line">系统初始化过程kernel由无到有的第一个进程，也是唯一一个没有通过fork或kernel_thread产生的进程。</span><br><span class="line">swapper进程用于初始化进程管理，内存管理，加载Display,Camera Driver,Binder Driver等工作</span><br></pre></td></tr></table></figure><p>1号进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init进程（pid=1）：由0号进程通过kernel_thread创建，在内核空间完成初始化，加载init程序，并最终运行在用户空间，init进程是所有用户进程的鼻祖</span><br></pre></td></tr></table></figure><p>2号进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kthreadd进程（pid=2）：又0号进程通过kernel_thread创建，是linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd,thermal等内核守护进程。</span><br><span class="line">kthreadd运行在内核空间，负责所有内核线程的调度和管理，kthreadd进程是所有内核进程的鼻祖</span><br></pre></td></tr></table></figure><p>4.3 Native层</p><p>Native层主要是一号进程，并且由其孵化出一系例daemon进程，还有一些列native service</p><ul><li>init会孵化ueventd,lodd,healthd,installd,adbd,lmkd等用户守护进程</li><li>init进程还启动servicemanager,bootanim,mediaserver等重要本地服务</li><li>init进程孵化Zygote进程，Zygote进程是Android系统的第一个进程，是所有Java进程父进程</li></ul><p>4.4 Java层</p><ul><li>zygote是第一个Java进程，并且是所有Java进程的父进程，由init进程解析init.rc文件后fork</li><li>System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程。System Server 负责启动和管理整个Java framework，包含ActivityManager,PackageManager,WindowManager等服务</li></ul><p>4.5 Application层<br>Zygote进程孵化出第一个app进程是Launcher，Zygote进程还会创建Brower,phone,Email等App进程，每个app进程都是由Zygote进程Fork生成的</p><h1 id="五-学习计划"><a href="#五-学习计划" class="headerlink" title="五. 学习计划"></a>五. 学习计划</h1><p>5.1 四大组件<br>Android 应用的四大组件Activity，service，Broadcast Receiver，Content provider。</p><ul><li>四大组件基础知识<ul><li>Android 四大组件</li></ul></li><li>Android组件 - Activity</li><li>Android组件 - Service</li><li>Android组件 - Broadcast Receiver</li><li>Android组件 - Content Provider</li></ul><p>5.2 消息处理机制</p><ul><li>Android消息处理机制Looper,Handler,Message介绍<ul><li>Android消息机制</li></ul></li></ul><p>5.3 IPC处理机制</p><ul><li>Binder机制<ul><li>Binder实用指南（1）-理解篇</li><li>Binder实用指南（2）-实战篇</li></ul></li><li>Socket通讯</li></ul><p>5.4 系统启动</p><ul><li>Android系统启动总结，包含如何启动init进程，如何启动zygote和system_server进程：</li><li>init进程相关包含init rc语法</li><li>Zygote进程相关知识</li><li>system_server进程</li><li>DVM的启动</li></ul><p>5.5 系统服务</p><ul><li>Android系统服务 - ActivityManagerService<ul><li>AMS启动流程</li><li>AMS的activity调度</li></ul></li><li>Android系统服务 - PackageManagerService<ul><li>PackageManagerService启动流程</li><li>应用程序安装流程</li><li>应用程序卸载流程</li><li>installd守护进程</li></ul></li><li>Android系统服务 - WindowManagerService<ul><li>Surface view 原理</li></ul></li><li>Android系统服务 - SurfaceFlinger推图</li><li>Input系统<ul><li>InputReader介绍</li><li>InputDispatcher介绍</li></ul></li><li>Android系统服务 - PowermanagerService</li><li>Android系统服务 - UserManagerService</li><li>MediaServer<ul><li>AudioFlinger-处理上层AudioTrack创建的音频</li><li>MediaPlayService服务：StageFrightPlayer本地播放，NuPlayer在线播放</li></ul></li></ul><p>5.6 安全机制</p><ul><li>Android系统build阶段签名机制</li><li>ApK签名机制</li><li>APK逆向 - smali注入</li></ul><p>5.7 问题分析</p><ul><li>ANR问题原理与分析</li><li>Crash&#x2F;Exception问题分析<ul><li>Java Exception</li><li>Native Exception</li><li>Kernel Panic</li></ul></li><li>LowMemoryKiller</li></ul><p>5.8 工具篇</p><ul><li>Android.mk介绍</li><li>理解和使用systrace</li></ul><p>5.9 其他</p><ul><li>Android智能指针</li></ul>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码(2)-Android系统启动流程</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(2)-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(2)-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Loader层"><a href="#一-Loader层" class="headerlink" title="一. Loader层"></a>一. Loader层</h1><ol><li><p>Boot ROM:<br>上电后，BootRom会被激活，引导芯片代码开始从预定义的地方（固化在ROM）开始执行，然后加载引导程序到RAM。</p></li><li><p>Boot Loader引导程序<br>Boot Loader是启动Android系统之前的引导程序，引导程序是OEM厂商或者运营商加锁和限制的地方，它是针对特定的主板与芯片的。OEM厂商要么使用很受欢迎的引导程序比如redboot、uboot、ARMboot等或者开发自己的引导程序，它不是Android操作系统的一部分。<br>Boot Loader主要作用是检查RAM，初始化硬件参数等功能。</p></li></ol><p>3 Preloader:<br>（1）Preloader是MTK平台独有的防止芯片被Hack的一个loader，MTK平台的bootrom会先加载preloader到SRAM中，preloader会先去初始化一些HW组件，比如通信端口(USB&#x2F;Uart)，外部存储设备(Emmc or Nand)，内存设备(DRAM Calibration)等，最后会Load LK到DRAM中并且run LK(U-boot)。<br>（2）LK会从外部存储设备load boot image,包括Linux kernel和Ramdisk到DRAM中.最后LK会跳到 Linux Kernel里去执行start kernel.<br>（3）linux kernel会先完成一些初始化动作，mount 根文件系统和启动第一个用户进程(init 进程)</p><h1 id="二-kernel层"><a href="#二-kernel层" class="headerlink" title="二. kernel层"></a>二. kernel层</h1><p>Android内核与linux内核启动的方式差不多。Kernel的启动流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alps/kernel/init/main.c</span><br><span class="line">start_kernel() ==&gt; rest_init() ==&gt; kernel_thread(kernel_init) ==&gt; kernel_init()</span><br></pre></td></tr></table></figure><p>2.1 rest_init()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static noinline void __ref rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    kernel_thread(kernel_init, NULL, CLONE_FS);</span><br><span class="line">    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</span><br><span class="line">    ...</span><br><span class="line">    init_idle_bootup_task(current);</span><br><span class="line">    schedule_preempt_disabled();</span><br><span class="line">    ...</span><br><span class="line">    cpu_idle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>rest_init中调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd</li><li>调用schedule函数开启了内核的调度系统，从此linux系统开始转起来了。</li><li>rest_init最终调用cpu_idle函数结束了整个内核的启动。<br>也就是说linux内核最终结束了一个函数cpu_idle。这个函数里面肯定是死循环。</li><li>简单来说，linux内核最终的状态是：有事干的时候去执行有意义的工作（执行各个进程任务），实在没活干的时候就去死循环（实际上死循环也可以看成是一个任务）。</li><li>之前已经启动了内核调度系统，调度系统会负责考评系统中所有的进程，这些进程里面只有有哪个需要被运行，调度系统就会终止cpu_idle死循环进程（空闲进程）转而去执行有意义的干活的进程。这样操作系统就转起来了。<br>0号进程：<br>swapper进程(pid&#x3D;0)：又称为idle进程, 叫空闲进程，由系统自动创建, 运行在内核态。<br>系统初始化过程Kernel由无到有开创的第一个进程, 也是唯一一个没有通过fork或者kernel_thread产生的进程。<br>swapper进程用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作。</li></ol><p>1号进程<br>init进程(pid&#x3D;1)：由0号进程通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 并最终运行在用户空间，init进程是所有用户进程的鼻祖。</p><p>2号进程<br>kthreadd进程(pid&#x3D;2)：由0号进程通过kernel_thread创建，是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。<br>kthreadd运行在内核空间, 负责所有内核线程的调度和管理 , kthreadd进程是所有内核进程的鼻祖。</p><p>2.2 kernel_init()<br>init进程会通过kernel_init创建，这个时候是在内核态，那么怎么一步步进入用户态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_init-&gt;init_post-&gt;run_init_process-&gt;kernel_execve</span><br></pre></td></tr></table></figure><p>先是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int __init kernel_init(void * unused)  </span><br><span class="line">&#123;  </span><br><span class="line">    /*Wait until kthreadd is all set-up.*/  </span><br><span class="line">    wait_for_completion(&amp;kthreadd_done);  </span><br><span class="line">     </span><br><span class="line">    //主要是初始化设备驱动，完成其他驱动程序（直接编译进内核的模块）的初始化。</span><br><span class="line">    do_basic_setup();  </span><br><span class="line">    //挂载根文件系统</span><br><span class="line">    if (sys_open((const char __user *) &quot;/dev/console&quot;, O_RDWR, 0) &lt; 0)  </span><br><span class="line">        printk(KERN_WARNING &quot;Warning: unable to open an initial console.\n&quot;); </span><br><span class="line">    //定义init进程 </span><br><span class="line">    if (!ramdisk_execute_command)  </span><br><span class="line">        ramdisk_execute_command = &quot;/init&quot;;  </span><br><span class="line">    //最后调用init_post，启动进程负责用户空间的初始化 </span><br><span class="line">    init_post();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static noinline int init_post(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    ……//省略部分代码  </span><br><span class="line">    if (ramdisk_execute_command) &#123;  </span><br><span class="line">    //run_init_process执行后将不再返回  </span><br><span class="line">    run_init_process(ramdisk_execute_command);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (execute_command) &#123;  </span><br><span class="line">       run_init_process(execute_command);  </span><br><span class="line">    &#125;  </span><br><span class="line">    run_init_process(&quot;/sbin/init&quot;);  </span><br><span class="line">    run_init_process(&quot;/etc/init&quot;);  </span><br><span class="line">    run_init_process(&quot;/bin/init&quot;);  </span><br><span class="line">    run_init_process(&quot;/bin/sh&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute_command是bootloader传递给内核的参数，一般是&#x2F;init（根目录下的init程序），也就是调用文件系统的init进程。如果找不到就会继续寻找“&#x2F;sbin&#x2F;init”,“&#x2F;etc&#x2F;init”,“&#x2F;bin&#x2F;init”,“&#x2F;bin&#x2F;sh”,找到后便执行run_init_process,且不再返回。run_init_process的函数体非常简单，仅仅是对kernel_execve函数的封装，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void run_init_process(const char *init_filename)  </span><br><span class="line">&#123;  </span><br><span class="line">  argv_init[0] = init_filename;  </span><br><span class="line">  kernel_execve(init_filename, argv_init, envp_init);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kernel_execve是linux内核中创建用户进程的方法接口，其实现位于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch/arm/kernel/sys_arm.c</span><br></pre></td></tr></table></figure><p>那么至此，我们已经对Android Kernel如何引导以及用户空间1号进程（init进程）如何启动做了详细分析。</p><h1 id="三-init进程"><a href="#三-init进程" class="headerlink" title="三.init进程"></a>三.init进程</h1><p>3.1 init Process<br>这里的native层主要说明init进程，当kernel initialize完成之后，系统会执行第一个用户进程init,我们可以说它是root进程或者所有进程的父进程。init进程相关的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/system/core/init/init.cpp：</span><br><span class="line">/system/core/rootdir/init.rc</span><br><span class="line">/system/core/init/readme.txt</span><br></pre></td></tr></table></figure><p>Init进程启动过程就是代码init.cpp中main函数执行过程，我们来看看它做了什么:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123;</span><br><span class="line">        return ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!strcmp(basename(argv[0]), &quot;watchdogd&quot;)) &#123;</span><br><span class="line">        return watchdogd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    // Clear the umask.</span><br><span class="line">    umask(0);</span><br><span class="line">    add_environment(&quot;PATH&quot;, _PATH_DEFPATH);</span><br><span class="line">    bool is_first_stage = (argc == 1) || (strcmp(argv[1], &quot;--second-stage&quot;) != 0);</span><br><span class="line">    //挂载tmpfs, devpts, proc, sysfs文件系统</span><br><span class="line">    if (is_first_stage) &#123;</span><br><span class="line">        mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;);</span><br><span class="line">        mkdir(&quot;/dev/pts&quot;, 0755);</span><br><span class="line">        mkdir(&quot;/dev/socket&quot;, 0755);</span><br><span class="line">        mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL);</span><br><span class="line">        #define MAKE_STR(x) __STRING(x)</span><br><span class="line">        mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC));</span><br><span class="line">        mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    // We must have some place other than / to create the device nodes for</span><br><span class="line">    // kmsg and null, otherwise we won&#x27;t be able to remount / read-only</span><br><span class="line">    // later on. Now that tmpfs is mounted on /dev, we can actually talk</span><br><span class="line">    // to the outside world.</span><br><span class="line">    //屏蔽标准的输入输出，即标准的输入输出定向到NULL设备。  </span><br><span class="line">    open_devnull_stdio();</span><br><span class="line">    //kernel log初始化</span><br><span class="line">    klog_init();</span><br><span class="line">    klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line">    NOTICE(&quot;init %s started!\n&quot;, is_first_stage ? &quot;first stage&quot; : &quot;second stage&quot;);</span><br><span class="line">    if (!is_first_stage) &#123;</span><br><span class="line">        // Indicate that booting is in progress to background fw loaders, etc.</span><br><span class="line">        close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000));</span><br><span class="line">        //创建一块共享的内存空间，用于属性服务</span><br><span class="line">        property_init();</span><br><span class="line">        // If arguments are passed both on the command line and in DT,</span><br><span class="line">        // properties set in DT always have priority over the command-line ones.</span><br><span class="line">        //设置基本属性 </span><br><span class="line">        process_kernel_dt();</span><br><span class="line">        process_kernel_cmdline();</span><br><span class="line">        // Propagate the kernel variables to internal variables</span><br><span class="line">        // used by init as well as the current required properties.</span><br><span class="line">        export_kernel_boot_props();</span><br><span class="line">    &#125;</span><br><span class="line">    // Set up SELinux, including loading the SELinux policy if we&#x27;re in the kernel domain.</span><br><span class="line">    // 加载SELinux</span><br><span class="line">    selinux_initialize(is_first_stage);</span><br><span class="line">    // If we&#x27;re in the kernel domain, re-exec init to transition to the init domain now</span><br><span class="line">    // that the SELinux policy has been loaded.</span><br><span class="line">    if (is_first_stage) &#123;</span><br><span class="line">        if (restorecon(&quot;/init&quot;) == -1) &#123;</span><br><span class="line">            ERROR(&quot;restorecon failed: %s\n&quot;, strerror(errno));</span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line">        char* path = argv[0];</span><br><span class="line">        char* args[] = &#123; path, const_cast&lt;char*&gt;(&quot;--second-stage&quot;), nullptr &#125;;</span><br><span class="line">        if (execv(path, args) == -1) &#123;</span><br><span class="line">            ERROR(&quot;execv(\&quot;%s\&quot;) failed: %s\n&quot;, path, strerror(errno));</span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // These directories were necessarily created before initial policy load</span><br><span class="line">    // and therefore need their security context restored to the proper value.</span><br><span class="line">    // This must happen before /dev is populated by ueventd.</span><br><span class="line">    NOTICE(&quot;Running restorecon...\n&quot;);</span><br><span class="line">    restorecon(&quot;/dev&quot;);</span><br><span class="line">    restorecon(&quot;/dev/socket&quot;);</span><br><span class="line">    restorecon(&quot;/dev/__properties__&quot;);</span><br><span class="line">    restorecon(&quot;/property_contexts&quot;);</span><br><span class="line">    restorecon_recursive(&quot;/sys&quot;);</span><br><span class="line">    epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">    if (epoll_fd == -1) &#123;</span><br><span class="line">        ERROR(&quot;epoll_create1 failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化子进程退出的信号处理过程</span><br><span class="line">    signal_handler_init();</span><br><span class="line">    //加载/default.prop文件</span><br><span class="line">    property_load_boot_defaults();</span><br><span class="line">    export_oem_lock_status();</span><br><span class="line">    //启动属性服务</span><br><span class="line">    start_property_service();</span><br><span class="line">    const BuiltinFunctionMap function_map;</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    // 添加解service, on, import 解析器</span><br><span class="line">    Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">    parser.AddSectionParser(&quot;service&quot;,std::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">    parser.AddSectionParser(&quot;on&quot;, std::make_unique&lt;ActionParser&gt;());</span><br><span class="line">    parser.AddSectionParser(&quot;import&quot;, std::make_unique&lt;ImportParser&gt;());</span><br><span class="line">    // 解析init rc文件</span><br><span class="line">    parser.ParseConfig(&quot;/init.rc&quot;);</span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    //执行rc文件中触发器为 on early-init的语句</span><br><span class="line">    am.QueueEventTrigger(&quot;early-init&quot;);</span><br><span class="line">    //创建wait_for_coldboot_done 动作并添加到action vector和trigger_queue_中</span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);</span><br><span class="line">    am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line">    am.QueueBuiltinAction(set_mmap_rnd_bits_action, &quot;set_mmap_rnd_bits&quot;);</span><br><span class="line">    am.QueueBuiltinAction(keychord_init_action, &quot;keychord_init&quot;);</span><br><span class="line">    am.QueueBuiltinAction(console_init_action, &quot;console_init&quot;);</span><br><span class="line">    //执行rc文件中触发器为 on init的语句</span><br><span class="line">    // Trigger all the boot actions to get us started.</span><br><span class="line">    am.QueueEventTrigger(&quot;init&quot;);</span><br><span class="line">    // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span><br><span class="line">    // wasn&#x27;t ready immediately after wait_for_coldboot_done</span><br><span class="line">    am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line">    // Don&#x27;t mount filesystems or start core system services in charger mode.</span><br><span class="line">    std::string bootmode = property_get(&quot;ro.bootmode&quot;);</span><br><span class="line">    if (bootmode == &quot;charger&quot;) &#123;</span><br><span class="line">        //充电模式下，执行rc文件中触发器为charger的语句</span><br><span class="line">        am.QueueEventTrigger(&quot;charger&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //非充电模式下，执行rc文件中触发器为late-init的语句</span><br><span class="line">        am.QueueEventTrigger(&quot;late-init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // Run all property triggers based on current state of the properties.</span><br><span class="line">    // 创建queue_property_triggers动作并且添加到action vector和trigger_queue_中</span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (!waiting_for_exec) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">            // 重启一些关键进程</span><br><span class="line">            restart_processes();</span><br><span class="line">        &#125;</span><br><span class="line">        int timeout = -1;</span><br><span class="line">        if (process_needs_restart) &#123;</span><br><span class="line">            timeout = (process_needs_restart - gettime()) * 1000;</span><br><span class="line">            if (timeout &lt; 0)</span><br><span class="line">                timeout = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (am.HasMoreCommands()) &#123;</span><br><span class="line">            timeout = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bootchart_sample(&amp;timeout);</span><br><span class="line">        epoll_event ev;</span><br><span class="line">        //循环 等待事件发生</span><br><span class="line">        int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout));</span><br><span class="line">        if (nr == -1) &#123;</span><br><span class="line">            ERROR(&quot;epoll_wait failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        &#125; else if (nr == 1) &#123;</span><br><span class="line">            ((void (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，init进程主要完成以下功能:</p><ol><li>是挂载tmpfs,devpts,proc,sysfs文件系统</li><li>加载解析命令 Action,service</li><li>运行init.rc脚步，init将会解析init.rc，并且执行init.rc中的命令</li><li>当一些关键进程死亡，重启该进程</li><li>提供Android系统属性服务</li></ol><p>3.2 文件系统简介</p><ol><li><p>tmpfs<br>tmpfs是一种虚拟内存文件系统，因此它会将所有的文件存储在虚拟内存中，并且tmpfs下的所有内容均为临时性的内容，如果你将tmpfs文件系统卸载后，那么它下面的内存将不复存在，tmpfs是一个独立的文件系统，不是块设备，只要挂接，立即可以使用</p></li><li><p>devpts<br>devpts文件系统为伪终端提供的一个标准接口，它的标准挂接点&#x2F;dev&#x2F;pts.只要pts的主复合设备&#x2F;dev&#x2F;ptmx被打开，就会在&#x2F;dev&#x2F;pts下动态创建一个新的pty设备文件</p></li><li><p>proc文件系统<br>proc文件系统是一个非常重要的虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统信息，同时也能够在运行时修改特定的内核参数</p></li><li><p>sysfs文件系统<br>与proc文件系统类似，sysfs文件系统也是一个不占任何磁盘空间的虚拟文件系统。它通常被挂接在&#x2F;sys目录下。sysfs文件系统是Linux2.6内核引入的，它把链接在系统上的设备和总线组织成为一个分级的文件，使得它们可以在用户空间存取</p></li></ol><h1 id="四-init-rc文件和语法"><a href="#四-init-rc文件和语法" class="headerlink" title="四.init.rc文件和语法"></a>四.init.rc文件和语法</h1><p>init.rc文件语法是以行为单位，以空格间隔的语法，以#开始代表注释行。rc文件主要包含Action,Service,Command,Option,其中对于Action和Service的名称都是唯一的，对于重复的命令视为无效</p><p>4.1 动作Action<br>Action：通过trigger，即以on开头的语句，决定何时执行相关service</p><ul><li>on early-init,在初始化早起阶段触发</li><li>on init;在初始化阶段触发</li><li>on late-init;在初始化晚期阶段触发</li><li>on boot&#x2F;charger;当系统启动&#x2F;充电时触发，还包含其他情况</li><li>on property&#x3D;；当属性值满足条件触发</li></ul><p>4.2 服务Servcie<br>服务Service，以service开头，由init进程启动，一般运行于另外一个init进程，所以启动Service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service，在启动时会fork方式生成子进程</p><p>4.3 命令Command<br>下面列举常用的命令</p><ul><li>class_start ： 启动属于同一个class的所有服务；</li><li>start ： 启动指定的服务，若已启动则跳过；</li><li>stop ： 停止正在运行的服务</li><li>setprop ：设置属性值</li><li>mkdir ：创建指定目录</li><li>symlink ： 创建连接到的符号链接；</li><li>write ： 向文件path中写入字符串；</li><li>exec： fork并执行，会阻塞init进程直到程序完毕；</li><li>exprot ：设定环境变量；</li><li>loglevel ：设置log级别</li></ul><p>4.4 可选操作Option<br>Options是Services的可选项，与service配合使用</p><ul><li>disabled: 不随class自动启动，只有根据service名才启动；</li><li>oneshot: service退出后不再重启；</li><li>user&#x2F;group： 设置执行服务的用户&#x2F;用户组，默认都是root；</li><li>class：设置所属的类名，当所属类启动&#x2F;退出时，服务也启动&#x2F;停止，默认为default；</li><li>onrestart:当服务重启时执行相应命令；</li><li>socket: 创建名为&#x2F;dev&#x2F;socket&#x2F;的socket</li><li>critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式</li></ul><p>*default: 意味着disabled&#x3D;false，oneshot&#x3D;false，critical&#x3D;false。</p><p>所有的Service里面只有servicemanager ，zygote ，surfaceflinger这3个service有onrestart关键字来触发其他service启动过程。</p><h1 id="五-Daemon守护进程"><a href="#五-Daemon守护进程" class="headerlink" title="五.Daemon守护进程"></a>五.Daemon守护进程</h1><p>init.rc会启动一些daemon进程，比如ueventd,adbd,servicemaager,vold,netd,debuggerd等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">service ueventd /sbin/ueventd  </span><br><span class="line">    class core  </span><br><span class="line">    critical  </span><br><span class="line">  </span><br><span class="line">service console /system/bin/sh  </span><br><span class="line">    class core  </span><br><span class="line">    console  </span><br><span class="line">    disabled  </span><br><span class="line">    user shell  </span><br><span class="line">    group log  </span><br><span class="line">  </span><br><span class="line">service adbd /sbin/adbd  </span><br><span class="line">    class core  </span><br><span class="line">    disabled  </span><br><span class="line">      </span><br><span class="line">service servicemanager /system/bin/servicemanager  </span><br><span class="line">    class core  </span><br><span class="line">    user system  </span><br><span class="line">    group system  </span><br><span class="line">    critical  </span><br><span class="line">    onrestart restart zygote  </span><br><span class="line">    onrestart restart media  </span><br><span class="line">    onrestart restart surfaceflinger  </span><br><span class="line">    onrestart restart drm  </span><br><span class="line">  </span><br><span class="line">service vold /system/bin/vold  </span><br><span class="line">    class core  </span><br><span class="line">    socket vold stream 0660 root mount  </span><br><span class="line">    ioprio be 2  </span><br><span class="line">  </span><br><span class="line">service netd /system/bin/netd  </span><br><span class="line">    class main  </span><br><span class="line">    socket netd stream 0660 root system  </span><br><span class="line">    socket dnsproxyd stream 0660 root inet  </span><br><span class="line">    socket mdns stream 0660 root system  </span><br><span class="line">  </span><br><span class="line">service debuggerd /system/bin/debuggerd  </span><br><span class="line">    class main</span><br></pre></td></tr></table></figure><h1 id="六-ServiceMnager"><a href="#六-ServiceMnager" class="headerlink" title="六. ServiceMnager"></a>六. ServiceMnager</h1><p>ServiceManager也是守护进程，它是Android大管家，是一个很重要的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//servicemanager可触发healthd、zygote、media、surfaceflinger、drm重启</span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br></pre></td></tr></table></figure><p>service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager表示服务名为servicemanager，服务运行的时候会执行&#x2F;system&#x2F;bin&#x2F;servicemanager</p><h1 id="七-Zygote"><a href="#七-Zygote" class="headerlink" title="七.Zygote"></a>七.Zygote</h1><p>Zygote是第一个Java进程，并且是所有java进程的父进程，在init.zygote32.rc文件中，zygote服务启动如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//zygote可触发media、netd重启</span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br></pre></td></tr></table></figure><p>Zygote入口和相关类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/cmds/app_process/App_main.cpp （内含AppRuntime类）</span><br><span class="line">/frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line">/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line">/frameworks/base/core/java/com/android/internal/os/Zygote.java</span><br><span class="line">/frameworks/base/core/java/android/net/LocalServerSocket.java</span><br><span class="line">/system/core/libutils/Threads.cpp</span><br></pre></td></tr></table></figure><p>解释下第一行参数：</p><ul><li>zygote:服务名</li><li>systen&#x2F;bin&#x2F;app_process:zygote所对应的可执行文件，通过pid&#x3D;fork()创建子进程</li><li>剩下的四个参数是zygote进程的启动参数，其中最后一个参数 –start-system-server是表示zygote进程启动完成后，马上将system进程启动启动</li></ul><p>zygote启动过程调用堆栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">App_main.main()</span><br><span class="line">    AndroidRuntime.start()</span><br><span class="line">        StartVM()</span><br><span class="line">        StartReg()</span><br><span class="line">        ZygoteInit.main()</span><br><span class="line">            ResgisterZygoteSocket()</span><br><span class="line">            preload()</span><br><span class="line">            startSystemServer()</span><br><span class="line">            runSelectLoop()</span><br></pre></td></tr></table></figure><p>zygote进程的主要工作如下：</p><ol><li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法</li><li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数</li><li>通过JNI方法调用ZygoteInit.main(),进入第一个java世界 （frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit.java：）</li><li>registerZygoteSocket()建立通道，zygote作为通讯的服务端，用于响应客户请求</li><li>preload（）预加载通用类，drawable和color资源，openGL以及共享库webView，提高ap启动效率</li><li>zygote完成大部分工作，接下来再通过startSystemServer(),fork得力帮手system_server进程，也是上层framework的运行载体（frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java）</li><li>zygote功成身退，调用runSelectLoop(),随时待命，当接受到请求创建新进程请求时立即唤醒并执行相应工作</li></ol><h1 id="八-system-server"><a href="#八-system-server" class="headerlink" title="八.system_server"></a>八.system_server</h1><p>上面提到Zygote启动过程会调用startSystemserver(),可知startSystemServer()函数是system_server启动流程的起点，system_server相关函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">/frameworks/base/core/java/android/app/LoadedApk.java</span><br><span class="line">/frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line">/frameworks/base/core/java/com/android/server/LocalServices.java</span><br><span class="line">/frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/ServiceThread.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/Installer.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br></pre></td></tr></table></figure><p>启动流程图如下：<br><img src="/img/system_server.jpg" alt="system_server"></p><p>进入到SystemServer.main后，调用堆栈如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SystemServer.main</span><br><span class="line">    SystemServer.run</span><br><span class="line">        createSystemContext</span><br><span class="line">            ActivityThread.systemMain</span><br><span class="line">                ActivityThread.attach</span><br><span class="line">                    LoadedApk.makeApplication</span><br><span class="line">            ActivityThread.getSystemContext</span><br><span class="line">                ContextImpl.createSystemContext</span><br><span class="line">        startBootstrapServices();//启动引导服务</span><br><span class="line">        startCoreServices();     // 启动核心服务</span><br><span class="line">        startOtherServices();    // 启动其他服务</span><br><span class="line">        Looper.loop();</span><br></pre></td></tr></table></figure><p>system_server最主要的工作就是启动系统服务。通过startBootstrapServices(),startCoreServices(),startOtherServices()3个方法</p><p>【注意：版本4.4.1 的代码如下】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line">public void initAndLoop() &#123;</span><br><span class="line"> </span><br><span class="line">        ···</span><br><span class="line">        // bootstrap services</span><br><span class="line">        boolean onlyCore = false;</span><br><span class="line">        boolean firstBoot = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Wait for installd to finished starting up so that it has a chance to</span><br><span class="line">            // create critical directories such as /data/user with the appropriate</span><br><span class="line">            // permissions.  We need this to complete before we initialize other services.</span><br><span class="line">            Slog.i(TAG, &quot;Waiting for installd to be ready.&quot;);</span><br><span class="line">            installer = new Installer();</span><br><span class="line">            installer.ping();</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Power Manager&quot;);</span><br><span class="line">            power = new PowerManagerService();</span><br><span class="line">            ServiceManager.addService(Context.POWER_SERVICE, power);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Activity Manager&quot;);</span><br><span class="line">            context = ActivityManagerService.main(factoryTest);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;************ Failure starting bootstrap service&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ···</span><br><span class="line">        try &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Display Manager&quot;);</span><br><span class="line">            display = new DisplayManagerService(context, wmHandler);</span><br><span class="line">            ServiceManager.addService(Context.DISPLAY_SERVICE, display, true);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Telephony Registry&quot;);</span><br><span class="line">            telephonyRegistry = new TelephonyRegistry(context);</span><br><span class="line">            ServiceManager.addService(&quot;telephony.registry&quot;, telephonyRegistry);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Scheduling Policy&quot;);</span><br><span class="line">            ServiceManager.addService(&quot;scheduling_policy&quot;, new SchedulingPolicyService());</span><br><span class="line"></span><br><span class="line">            AttributeCache.init(context);</span><br><span class="line"></span><br><span class="line">            if (!display.waitForDefaultDisplay()) &#123;</span><br><span class="line">                reportWtf(&quot;Timeout waiting for default display to be initialized.&quot;,</span><br><span class="line">                        new Throwable());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Package Manager&quot;);</span><br><span class="line">            // Only run &quot;core&quot; apps if we&#x27;re encrypting the device.</span><br><span class="line">            String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</span><br><span class="line">            if (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</span><br><span class="line">                onlyCore = true;</span><br><span class="line">            &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</span><br><span class="line">                onlyCore = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pm = PackageManagerService.main(context, installer,</span><br><span class="line">                    factoryTest != SystemServer.FACTORY_TEST_OFF,</span><br><span class="line">                    onlyCore);</span><br><span class="line">            try &#123;</span><br><span class="line">                firstBoot = pm.isFirstBoot();</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Entropy Mixer&quot;);</span><br><span class="line">            ServiceManager.addService(&quot;entropy&quot;, new EntropyMixer(context));</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;User Service&quot;);</span><br><span class="line">            ServiceManager.addService(Context.USER_SERVICE,</span><br><span class="line">                    UserManagerService.getInstance());</span><br><span class="line"></span><br><span class="line">            mContentResolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">            // The AccountManager must come before the ContentService</span><br><span class="line">            try &#123;</span><br><span class="line">                // TODO: seems like this should be disable-able, but req&#x27;d by ContentService</span><br><span class="line">                Slog.i(TAG, &quot;Account Manager&quot;);</span><br><span class="line">                accountManager = new AccountManagerService(context);</span><br><span class="line">                ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                Slog.e(TAG, &quot;Failure starting Account Manager&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Content Manager&quot;);</span><br><span class="line">            contentService = ContentService.main(context,</span><br><span class="line">                    factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;System Content Providers&quot;);</span><br><span class="line">            ActivityManagerService.installSystemProviders();</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Lights Service&quot;);</span><br><span class="line">            lights = new LightsService(context);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Battery Service&quot;);</span><br><span class="line">            battery = new BatteryService(context, lights);</span><br><span class="line">            ServiceManager.addService(&quot;battery&quot;, battery);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Vibrator Service&quot;);</span><br><span class="line">            vibrator = new VibratorService(context);</span><br><span class="line">            ServiceManager.addService(&quot;vibrator&quot;, vibrator);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Consumer IR Service&quot;);</span><br><span class="line">            consumerIr = new ConsumerIrService(context);</span><br><span class="line">            ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);</span><br><span class="line"></span><br><span class="line">            // only initialize the power service after we have started the</span><br><span class="line">            // lights service, content providers and the battery service.</span><br><span class="line">            power.init(context, lights, ActivityManagerService.self(), battery,</span><br><span class="line">                    BatteryStatsService.getService(),</span><br><span class="line">                    ActivityManagerService.self().getAppOpsService(), display);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Alarm Manager&quot;);</span><br><span class="line">            alarm = new AlarmManagerService(context);</span><br><span class="line">            ServiceManager.addService(Context.ALARM_SERVICE, alarm);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Init Watchdog&quot;);</span><br><span class="line">            Watchdog.getInstance().init(context, battery, power, alarm,</span><br><span class="line">                    ActivityManagerService.self());</span><br><span class="line">            Watchdog.getInstance().addThread(wmHandler, &quot;WindowManager thread&quot;);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Input Manager&quot;);</span><br><span class="line">            inputManager = new InputManagerService(context, wmHandler);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Window Manager&quot;);</span><br><span class="line">            wm = WindowManagerService.main(context, power, display, inputManager,</span><br><span class="line">                    wmHandler, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                    !firstBoot, onlyCore);</span><br><span class="line">            ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">            ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line"></span><br><span class="line">            ActivityManagerService.self().setWindowManager(wm);</span><br><span class="line"></span><br><span class="line">            inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">            inputManager.start();</span><br><span class="line"></span><br><span class="line">            display.setWindowManager(wm);</span><br><span class="line">            display.setInputManager(inputManager);</span><br><span class="line"></span><br><span class="line">            // Skip Bluetooth if we have an emulator kernel</span><br><span class="line">            // TODO: Use a more reliable check to see if this product should</span><br><span class="line">            // support Bluetooth - see bug 988521</span><br><span class="line">            if (SystemProperties.get(&quot;ro.kernel.qemu&quot;).equals(&quot;1&quot;)) &#123;</span><br><span class="line">                Slog.i(TAG, &quot;No Bluetooh Service (emulator)&quot;);</span><br><span class="line">            &#125; else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">                Slog.i(TAG, &quot;No Bluetooth Service (factory test)&quot;);</span><br><span class="line">            &#125; else if (!context.getPackageManager().hasSystemFeature</span><br><span class="line">                       (PackageManager.FEATURE_BLUETOOTH)) &#123;</span><br><span class="line">                Slog.i(TAG, &quot;No Bluetooth Service (Bluetooth Hardware Not Present)&quot;);</span><br><span class="line">            &#125; else if (disableBluetooth) &#123;</span><br><span class="line">                Slog.i(TAG, &quot;Bluetooth Service disabled by config&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.i(TAG, &quot;Bluetooth Manager Service&quot;);</span><br><span class="line">                bluetooth = new BluetoothManagerService(context);</span><br><span class="line">                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;************ Failure starting core service&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DevicePolicyManagerService devicePolicy = null;</span><br><span class="line">        StatusBarManagerService statusBar = null;</span><br><span class="line">        InputMethodManagerService imm = null;</span><br><span class="line">        AppWidgetService appWidget = null;</span><br><span class="line">        NotificationManagerService notification = null;</span><br><span class="line">        WallpaperManagerService wallpaper = null;</span><br><span class="line">        LocationManagerService location = null;</span><br><span class="line">        CountryDetectorService countryDetector = null;</span><br><span class="line">        TextServicesManagerService tsms = null;</span><br><span class="line">        LockSettingsService lockSettings = null;</span><br><span class="line">        DreamManagerService dreamy = null;</span><br><span class="line">        AssetAtlasService atlas = null;</span><br><span class="line">        PrintManagerService printManager = null;</span><br><span class="line">        MediaRouterService mediaRouter = null;</span><br><span class="line"></span><br><span class="line">        // We now tell the activity manager it is okay to run third party</span><br><span class="line">        // code.  It will call back into us once it has gotten to the state</span><br><span class="line">        // where third party code can really run (but before it has actually</span><br><span class="line">        // started launching the initial applications), for us to complete our</span><br><span class="line">        // initialization.</span><br><span class="line">        ActivityManagerService.self().systemReady(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Slog.i(TAG, &quot;Making services ready&quot;);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerService.self().startObservingNativeCrashes();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;observing native crashes&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!headless) &#123;</span><br><span class="line">                    startSystemUi(contextF);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (mountServiceF != null) mountServiceF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Mount Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (batteryF != null) batteryF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Battery Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkManagementF != null) networkManagementF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Network Managment Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkStatsF != null) networkStatsF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Network Stats Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkPolicyF != null) networkPolicyF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Network Policy Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (connectivityF != null) connectivityF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Connectivity Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (dockF != null) dockF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Dock Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (usbF != null) usbF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making USB Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (twilightF != null) twilightF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;makin Twilight Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (uiModeF != null) uiModeF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making UI Mode Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (recognitionF != null) recognitionF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Recognition Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                Watchdog.getInstance().start();</span><br><span class="line"></span><br><span class="line">                // It is now okay to let the various system services start their</span><br><span class="line">                // third party code...</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    if (appWidgetF != null) appWidgetF.systemRunning(safeMode);</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying AppWidgetService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (wallpaperF != null) wallpaperF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying WallpaperService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (immF != null) immF.systemRunning(statusBarF);</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying InputMethodService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (locationF != null) locationF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying Location Service running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (countryDetectorF != null) countryDetectorF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying CountryDetectorService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying NetworkTimeService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (commonTimeMgmtServiceF != null) commonTimeMgmtServiceF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying CommonTimeManagementService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (textServiceManagerServiceF != null)</span><br><span class="line">                        textServiceManagerServiceF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying TextServicesManagerService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (dreamyF != null) dreamyF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying DreamManagerService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (atlasF != null) atlasF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying AssetAtlasService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // TODO(BT) Pass parameter to input manager</span><br><span class="line">                    if (inputManagerF != null) inputManagerF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying InputManagerService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    if (telephonyRegistryF != null) telephonyRegistryF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying TelephonyRegistry running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    if (printManagerF != null) printManagerF.systemRuning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying PrintManagerService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    if (mediaRouterF != null) mediaRouterF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying MediaRouterService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ···</span><br><span class="line">        // For debug builds, log event loop stalls to dropbox for analysis.</span><br><span class="line">        if (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">        Slog.d(TAG, &quot;System ServerThread is exiting!&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>8.1 startBootstrapServices()<br>[SystemServer.java]启动引导服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    //阻塞等待与installd建立socket通道</span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    //启动服务ActivityManagerService</span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    //启动服务PowerManagerService</span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    //初始化power management</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    //启动服务LightsService</span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line">    //启动服务DisplayManagerService</span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line">    //Phase100: 在初始化package manager之前，需要默认的显示.</span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">    //当设备正在加密时，仅运行核心</span><br><span class="line">    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</span><br><span class="line">    if (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = true;</span><br><span class="line">    &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //启动服务PackageManagerService</span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">    //启动服务UserManagerService，新建目录/data/user/</span><br><span class="line">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line">    //设置AMS</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line">    //启动传感器服务</span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.2 startCoreServices()<br>[ SystemServer.java ] 启动核心服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">    //启动服务BatteryService，用于统计电池电量，需要LightService.</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line">    //启动服务UsageStatsService，用于统计应用使用情况</span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</span><br><span class="line">    //启动服务WebViewUpdateService</span><br><span class="line">    mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务BatteryService，UsageStatsService，WebViewUpdateService</p><p>8.3 startOtherServices()<br>[ SystemServer.java ] 启动其他服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">        ...</span><br><span class="line">        SystemConfig.getInstance();</span><br><span class="line">        mContentResolver = context.getContentResolver(); // resolver</span><br><span class="line">        ...</span><br><span class="line">        mActivityManagerService.installSystemProviders(); //provider</span><br><span class="line">        mSystemServiceManager.startService(AlarmManagerService.class); // alarm</span><br><span class="line">        // watchdog</span><br><span class="line">        watchdog.init(context, mActivityManagerService); </span><br><span class="line">        inputManager = new InputManagerService(context); // input</span><br><span class="line">        wm = WindowManagerService.main(...); // window</span><br><span class="line">        inputManager.start();  //启动input</span><br><span class="line">        mDisplayManagerService.windowManagerAndInputReady();</span><br><span class="line">        ...</span><br><span class="line">        mSystemServiceManager.startService(MOUNT_SERVICE_CLASS); // mount</span><br><span class="line">        mPackageManagerService.performBootDexOpt();  // dexopt操作</span><br><span class="line">        ActivityManagerNative.getDefault().showBootMessage(...); //显示启动界面</span><br><span class="line">        ...</span><br><span class="line">        statusBar = new StatusBarManagerService(context, wm); //statusBar</span><br><span class="line">        //dropbox</span><br><span class="line">        ServiceManager.addService(Context.DROPBOX_SERVICE,</span><br><span class="line">                    new DropBoxManagerService(context, new File(&quot;/data/system/dropbox&quot;)));</span><br><span class="line">         mSystemServiceManager.startService(JobSchedulerService.class); //JobScheduler</span><br><span class="line">         lockSettings.systemReady(); //lockSettings</span><br><span class="line">        //phase480 和phase500</span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">        ...</span><br><span class="line">        // 准备好window, power, package, display服务</span><br><span class="line">        wm.systemReady();</span><br><span class="line">        mPowerManagerService.systemReady(...);</span><br><span class="line">        mPackageManagerService.systemReady();</span><br><span class="line">        mDisplayManagerService.systemReady(...);</span><br><span class="line">        //见下面分析</span><br><span class="line">        mActivityManagerService.systemReady(new Runnable() &#123;...&#125;);</span><br></pre></td></tr></table></figure><p>其中AMS.systemReady()的大致过程如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService extends ActivityManagerNative</span><br><span class="line">    implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line">        </span><br><span class="line">    public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">        ... //update相关</span><br><span class="line">        mSystemReady = true;</span><br><span class="line">        </span><br><span class="line">        //杀掉所有非persistent进程</span><br><span class="line">        removeProcessLocked(proc, true, false, &quot;system update done&quot;);</span><br><span class="line">        mProcessesReady = true; </span><br><span class="line">        goingCallback.run();  //[见小节1.6.2]</span><br><span class="line">        </span><br><span class="line">        addAppLocked(info, false, null); //启动所有的persistent进程</span><br><span class="line">        mBooting = true; </span><br><span class="line">        </span><br><span class="line">        //启动home</span><br><span class="line">        startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;); </span><br><span class="line">        //恢复栈顶的Activity</span><br><span class="line">        mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityManagerService的systemReady方法，在该方法里会启动系统界面以及Home程序。</p>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码(3)-PackageManagerService启动流程</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(3)-PackageManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(3)-PackageManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>相关源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/pm/PackageInstallerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/pm/Settings.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/pm/Installer.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/SystemConfig.java</span><br><span class="line">frameworks/base/core/java/android/content/pm/PackageManager.java</span><br><span class="line">frameworks/base/core/java/android/content/pm/IPackageManager.aidl</span><br><span class="line">frameworks/base/core/java/android/content/pm/PackageParser.java</span><br><span class="line">frameworks/base/core/java/com/android/internal/os/InstallerConnection.java</span><br><span class="line">frameworks/base/cmds/pm/src/com/android/commands/pm/Pm.java</span><br></pre></td></tr></table></figure><h3 id="一-system-server启动pms"><a href="#一-system-server启动pms" class="headerlink" title="一. system_server启动pms"></a>一. system_server启动pms</h3><p>Android的所有Java服务都是通过System_server进程启动的，并且驻留在system_server进程中。SystemServer进程在启动时，通过创建一个ServerThread线程来启动所有服务，现在先来看看Android服务中PackageManagerService服务启动过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/java/com/android/server/SystemServer.java</span><br></pre></td></tr></table></figure><p>1.1 startBootstrapServices()<br>system_server的startBootstrapServices()函数启动一些引导服务，该方法所创建的服务</p><ul><li>ActivityManagerService</li><li>PowerManagerService</li><li>LightService</li><li>DisplayManagerService</li><li>PackageManagerService</li><li>UserManagerService</li><li>SensorService服务</li></ul><p>其中我们需要的PackageManagerService就在这里启动，我们来看看startBootstrapServices()是如何PMS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">        //启动installer服务</span><br><span class="line">        Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">        // We need the default display before we can initialize the package manager.</span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">        </span><br><span class="line">        //处于加密状态则仅仅解析核心应用</span><br><span class="line">        // Only run &quot;core&quot; apps if we&#x27;re encrypting the device.</span><br><span class="line">        String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</span><br><span class="line">        if (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</span><br><span class="line">            mOnlyCore = true;</span><br><span class="line">        &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</span><br><span class="line">            mOnlyCore = true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建PMS对象 - 启动入口</span><br><span class="line">        traceBeginAndSlog(&quot;StartPackageManagerService&quot;);</span><br><span class="line">        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">        // 是否首次启动</span><br><span class="line">        mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">        </span><br><span class="line">        // 获取PackageManager</span><br><span class="line">        mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2 startOtherServices()<br>另外，system_server的startOtherServices()方法会启动其他服务，这个函数也会对PMS作一些操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">    ......</span><br><span class="line">    if (!mOnlyCore) &#123;</span><br><span class="line">        ........</span><br><span class="line">        try &#123;</span><br><span class="line">            //将调用performDexOpt:Performs dexopt on the set of packages</span><br><span class="line">            mPackageManagerService.updatePackagesIfNeeded();</span><br><span class="line">        &#125;.......</span><br><span class="line">        ........</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行Fstrim，执行磁盘维护操作，未看到详细的资料</span><br><span class="line">            //可能类似于TRIM技术，将标记为删除的文件，彻底从硬盘上移除</span><br><span class="line">            //而不是等到写入时再移除，目的是提高写入时效率</span><br><span class="line">            mPackageManagerService.performFstrimIfNeeded();</span><br><span class="line">        &#125;.........</span><br><span class="line">        .......</span><br><span class="line">        try &#123;</span><br><span class="line">            mPackageManagerService.systemReady();</span><br><span class="line">        &#125;........</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，PMS启动后将参与一些系统优化的工作，然后调用SystemReady函数通知系统进入就绪状态。</p><p>整个system_server进程启动过程，涉及PackageManagerServer启动流程</p><h3 id="二-PMS-main入口"><a href="#二-PMS-main入口" class="headerlink" title="二. PMS.main入口"></a>二. PMS.main入口</h3><p>PackageManagerServer.main过程主要创建PMS服务，并注册到ServiceManager大管家</p><h3 id="三-PMS构造函数-分析"><a href="#三-PMS构造函数-分析" class="headerlink" title="三.PMS构造函数-分析"></a>三.PMS构造函数-分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new PackageManagerService(context, installer, factoryTest, onlyCore);</span><br></pre></td></tr></table></figure><p>创建PMS对象的过程，就是执行PMS的构造函数，PMS构造函数比较长，我们把这个过程分成几个阶段</p><ul><li>BOOT_PROGRESS_PMS_START</li><li>BOOT_PROGRESS_PMS_SYSTEM_SCAN_START</li><li>BOOT_PROGRESS_PMS_DATA_SCAN_START</li><li>BOOT_PROGRESS_PMS_SCAN_END</li><li>BOOT_PROGRESS_PMS_READY<br>PMS构造函数里面，在每个阶段开始的时候，都会往Eventlog里面打tag,比如像这样<br>EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());</li></ul><p>3.1 PMS_START<br>BOOT_PROGRESS_PMS_START阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">// 输出event log</span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">        SystemClock.uptimeMillis());</span><br><span class="line">/** M: Mtprof tool @&#123; */</span><br><span class="line">//mMTPROFDisable = &quot;1&quot;.equals(SystemProperties.get(&quot;ro.mtprof.disable&quot;));</span><br><span class="line">mMTPROFDisable = false;</span><br><span class="line">addBootEvent(&quot;Android:PackageManagerService_Start&quot;);</span><br><span class="line">/** @&#125; */</span><br><span class="line">if (mSdkVersion &lt;= 0) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;**** ro.build.version.sdk not set!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">mContext = context;</span><br><span class="line">mFactoryTest = factoryTest;</span><br><span class="line">mOnlyCore = onlyCore;</span><br><span class="line">// DisplayMetrics是一个描述界面显示，尺寸，分辨率，密度的类。</span><br><span class="line">mMetrics = new DisplayMetrics();</span><br><span class="line">// Settings是Android的全局管理者，用于协助PMS保存所有的安装包信息</span><br><span class="line">mSettings = new Settings(mPackages);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, Process.SYSTEM_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;, RADIO_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.log&quot;, LOG_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;, NFC_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.bluetooth&quot;, BLUETOOTH_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.shell&quot;, SHELL_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">// 获取debug.separate_processes属性</span><br><span class="line">// 如果设置了这个属性，那么会强制应用程序组件在自己的进程中运行。</span><br><span class="line">// 一般情况下不会设置这个属性</span><br><span class="line">String separateProcesses = SystemProperties.get(&quot;debug.separate_processes&quot;);</span><br><span class="line">if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) &#123;</span><br><span class="line">    // 所有process都设置这个属性</span><br><span class="line">    if (&quot;*&quot;.equals(separateProcesses)) &#123;</span><br><span class="line">        mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</span><br><span class="line">        mSeparateProcesses = null;</span><br><span class="line">        Slog.w(TAG, &quot;Running with debug.separate_processes: * (ALL)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 个别的process设置这个属性 </span><br><span class="line">    else &#123;</span><br><span class="line">        mDefParseFlags = 0;</span><br><span class="line">        mSeparateProcesses = separateProcesses.split(&quot;,&quot;);</span><br><span class="line">        Slog.w(TAG, &quot;Running with debug.separate_processes: &quot;</span><br><span class="line">                + separateProcesses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123; // 不设置这个属性,一般情况下会走这</span><br><span class="line">    mDefParseFlags = 0;</span><br><span class="line">    mSeparateProcesses = null;</span><br><span class="line">&#125;</span><br><span class="line">// 保存Installer对象</span><br><span class="line">mInstaller = installer;</span><br><span class="line">// //用于dex优化</span><br><span class="line">mPackageDexOptimizer = new PackageDexOptimizer(installer, mInstallLock, context,</span><br><span class="line">        &quot;*dexopt*&quot;);</span><br><span class="line">mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());</span><br><span class="line">mOnPermissionChangeListeners = new OnPermissionChangeListeners(</span><br><span class="line">        FgThread.get().getLooper());</span><br><span class="line">// 获取默认的显示信息，保存到mMetrics</span><br><span class="line">getDefaultDisplayMetrics(context, mMetrics);</span><br><span class="line">// 获取系统配置信息</span><br><span class="line">SystemConfig systemConfig = SystemConfig.getInstance();</span><br><span class="line">mGlobalGids = systemConfig.getGlobalGids();</span><br><span class="line">mSystemPermissions = systemConfig.getSystemPermissions();</span><br><span class="line">mAvailableFeatures = systemConfig.getAvailableFeatures();</span><br><span class="line">synchronized (mInstallLock) &#123;</span><br><span class="line">// writer</span><br><span class="line">synchronized (mPackages) &#123;</span><br><span class="line">    //创建名为“PackageManager”的handler线程</span><br><span class="line">    mHandlerThread = new ServiceThread(TAG,</span><br><span class="line">            Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    </span><br><span class="line">    // 建立PackageHandler消息循环，用于处理外部的安装请求等消息</span><br><span class="line">    // 比如如adb install、packageinstaller安装APK时</span><br><span class="line">    mHandler = new PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">    mProcessLoggingHandler = new ProcessLoggingHandler();</span><br><span class="line">    Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</span><br><span class="line">    // 创建各种目录</span><br><span class="line">    File dataDir = Environment.getDataDirectory();</span><br><span class="line">    mAppInstallDir = new File(dataDir, &quot;app&quot;);</span><br><span class="line">    mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;);</span><br><span class="line">    mEphemeralInstallDir = new File(dataDir, &quot;app-ephemeral&quot;);</span><br><span class="line">    mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath();</span><br><span class="line">    mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;);</span><br><span class="line">    // 创建用户管理服务</span><br><span class="line">    sUserManager = new UserManagerService(context, this, mPackages);</span><br><span class="line">    // Propagate permission configuration in to package manager.</span><br><span class="line">    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</span><br><span class="line">            = systemConfig.getPermissions();</span><br><span class="line">    for (int i=0; i&lt;permConfig.size(); i++) &#123;</span><br><span class="line">        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</span><br><span class="line">        BasePermission bp = mSettings.mPermissions.get(perm.name);</span><br><span class="line">        if (bp == null) &#123;</span><br><span class="line">            bp = new BasePermission(perm.name, &quot;android&quot;, BasePermission.TYPE_BUILTIN);</span><br><span class="line">            mSettings.mPermissions.put(perm.name, bp);</span><br><span class="line">        &#125;</span><br><span class="line">        if (perm.gids != null) &#123;</span><br><span class="line">            bp.setGids(perm.gids, perm.perUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取共享库</span><br><span class="line">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</span><br><span class="line">    for (int i=0; i&lt;libConfig.size(); i++) &#123;</span><br><span class="line">        mSharedLibraries.put(libConfig.keyAt(i),</span><br><span class="line">                new SharedLibraryEntry(libConfig.valueAt(i), null));</span><br><span class="line">    &#125;</span><br><span class="line">    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</span><br><span class="line">    // 解析packages.xml和packages-backup.xml</span><br><span class="line">    mRestoredSettings = mSettings.readLPw(sUserManager.getUsers(false));</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结阶段一主要工作如下:</p><ul><li>构造DisplayMetrics类：描述界面显示，尺寸，分辨率，密度。构造完后并获取默认的信息保存到变量mMetrics中。</li><li>构造Setting：这个是Android的全局管理者，用于协助PMS保存所有的安装包信息</li><li>保存Installer对象</li><li>获取系统配置信息：SystemConfig构造函数中通过readPermissions()解析指定目录下的xml,然后把这个信息保存到SystemConfig中，设计的目录如下:<ul><li>&#x2F;system&#x2F;etc&#x2F;sysconfig</li><li>&#x2F;system&#x2F;etc&#x2F;permissions</li><li>&#x2F;oem&#x2F;etc&#x2F;sysconfig</li><li>&#x2F;oem&#x2F;etc&#x2F;permissions</li></ul></li><li>创建名为PackageManager的handler线程，建立PackageHandler消息循环，用于处理外部的安装请求等消息</li><li>创建data下的各种目录，比如data&#x2F;app,data&#x2F;app-private</li><li>创建用户管理服务UserManagerService</li><li>把systemConfig关于xml中的标签所指动态库保存到mSharedLibraries</li><li>Setting.readLPw扫描packages.xml和package-backup.xml</li></ul><p>补充说明debug.separate_processes这个属性<br>这个属性你可以使用强制应用程序组件在自己的进程中运行，有两种方法可以使用这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 所有的进程都会收到影响</span><br><span class="line">setprop debug.separate_processes</span><br><span class="line">// 指定进程受影响</span><br><span class="line">setprop debug.separate_processes &quot;com.google.process.content, com.google.android.samples&quot;</span><br></pre></td></tr></table></figure><p>3.2 PMS_SYSTEM_SCAN_START<br>接下来是BOOT_PROGRESS_PMS_SYSTEM_SCAN_START阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">long startTime = SystemClock.uptimeMillis();</span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">        startTime);</span><br><span class="line">final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</span><br><span class="line">//该集合中存放的是已经优化或者不需要优先的文件</span><br><span class="line">final ArraySet&lt;String&gt; alreadyDexOpted = new ArraySet&lt;String&gt;();</span><br><span class="line">final String bootClassPath = System.getenv(&quot;BOOTCLASSPATH&quot;);</span><br><span class="line">final String systemServerClassPath = System.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line">//将环境变量BOOTCLASSPATH所执行的文件加入alreadyDexOpted</span><br><span class="line">if (bootClassPath != null) &#123;</span><br><span class="line">    String[] bootClassPathElements = splitString(bootClassPath, &#x27;:&#x27;);</span><br><span class="line">    for (String element : bootClassPathElements) &#123;</span><br><span class="line">        alreadyDexOpted.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//将环境变量SYSTEMSERVERCLASSPATH所执行的文件加入alreadyDexOpted</span><br><span class="line">if (systemServerClassPath != null) &#123;</span><br><span class="line">    String[] systemServerClassPathElements = splitString(systemServerClassPath, &#x27;:&#x27;);</span><br><span class="line">    for (String element : systemServerClassPathElements) &#123;</span><br><span class="line">        alreadyDexOpted.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">//此处共享库是由SystemConfig实例化过程赋值的</span><br><span class="line">if (mSharedLibraries.size() &gt; 0) &#123;</span><br><span class="line">    for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">        for (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</span><br><span class="line">            final String lib = libEntry.path;</span><br><span class="line">            ...</span><br><span class="line">            int dexoptNeeded = DexFile.getDexOptNeeded(lib, dexCodeInstructionSet,</span><br><span class="line">                    &quot;speed&quot;, false);</span><br><span class="line">            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                alreadyDexOpted.add(lib);</span><br><span class="line">                //执行dexopt操作</span><br><span class="line">                mInstaller.dexopt(lib, Process.SYSTEM_UID, dexCodeInstructionSet,</span><br><span class="line">                        dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//此处frameworkDir目录为/system/framework</span><br><span class="line">File frameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;);</span><br><span class="line">//添加以下两个文件添加到已优化集合</span><br><span class="line">alreadyDexOpted.add(frameworkDir.getPath() + &quot;/framework-res.apk&quot;);</span><br><span class="line">alreadyDexOpted.add(frameworkDir.getPath() + &quot;/core-libart.jar&quot;);</span><br><span class="line">String[] frameworkFiles = frameworkDir.list();</span><br><span class="line">if (frameworkFiles != null) &#123;</span><br><span class="line">    for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">        for (int i=0; i&lt;frameworkFiles.length; i++) &#123;</span><br><span class="line">            File libPath = new File(frameworkDir, frameworkFiles[i]);</span><br><span class="line">            String path = libPath.getPath();</span><br><span class="line">            //跳过已优化集合中的文件</span><br><span class="line">            if (alreadyDexOpted.contains(path)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //跳过后缀不为apk和jar的文件</span><br><span class="line">            if (!path.endsWith(&quot;.apk&quot;) &amp;&amp; !path.endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int dexoptNeeded = DexFile.getDexOptNeeded(path, dexCodeInstructionSet,</span><br><span class="line">                    &quot;speed&quot;, false);</span><br><span class="line">            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                //执行dexopt操作【见小节2.2.1】</span><br><span class="line">                mInstaller.dexopt(path, Process.SYSTEM_UID, dexCodeInstructionSet,</span><br><span class="line">                        dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final VersionInfo ver = mSettings.getInternalVersion();</span><br><span class="line">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</span><br><span class="line">mPromoteSystemApps = mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</span><br><span class="line">if (mPromoteSystemApps) &#123;</span><br><span class="line">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</span><br><span class="line">    while (pkgSettingIter.hasNext()) &#123;</span><br><span class="line">        PackageSetting ps = pkgSettingIter.next();</span><br><span class="line">        if (isSystemApp(ps)) &#123;</span><br><span class="line">            mExistingSystemPackages.add(ps.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//收集供应商包名：/vendor/overlay</span><br><span class="line">File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);</span><br><span class="line">scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);</span><br><span class="line">//收集包名：/system/framework</span><br><span class="line">scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">        | PackageParser.PARSE_IS_PRIVILEGED,</span><br><span class="line">        scanFlags | SCAN_NO_DEX, 0);</span><br><span class="line">//收集私有的系统包名：/system/priv-app</span><br><span class="line">final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;);</span><br><span class="line">scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);</span><br><span class="line">//收集一般地系统包名：/system/app</span><br><span class="line">final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;);</span><br><span class="line">scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">//收集私有供应商包名：/vendor/priv-app</span><br><span class="line">final File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), &quot;priv-app&quot;);</span><br><span class="line">scanDirLI(privilegedVendorAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);</span><br><span class="line">//收集所有的供应商包名：/vendor/app</span><br><span class="line">File vendorAppDir = new File(Environment.getVendorDirectory(), &quot;app&quot;);</span><br><span class="line">vendorAppDir = vendorAppDir.getCanonicalFile();</span><br><span class="line">scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">//收集所有OEM包名：/oem/app</span><br><span class="line">final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;);</span><br><span class="line">scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">//移除文件</span><br><span class="line">mInstaller.moveFiles();</span><br><span class="line">//删除不在存在的系统包</span><br><span class="line">final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;();</span><br><span class="line">if (!mOnlyCore) &#123;</span><br><span class="line">    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line">    while (psit.hasNext()) &#123;</span><br><span class="line">        PackageSetting ps = psit.next();</span><br><span class="line">        if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        final PackageParser.Package scannedPkg = mPackages.get(ps.name);</span><br><span class="line">        if (scannedPkg != null) &#123;</span><br><span class="line">            if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                removePackageLI(ps, true);</span><br><span class="line">                mExpectingBetter.put(ps.name, ps.codePath);</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">            psit.remove();</span><br><span class="line">            removeDataDirsLI(null, ps.name);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</span><br><span class="line">            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) &#123;</span><br><span class="line">                possiblyDeletedUpdatedSystemApps.add(ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//清理所有安装不完整的包</span><br><span class="line">ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</span><br><span class="line">for(int i = 0; i &lt; deletePkgsList.size(); i++) &#123;</span><br><span class="line">    cleanupInstallFailedPackage(deletePkgsList.get(i));</span><br><span class="line">&#125;</span><br><span class="line">//删除临时文件</span><br><span class="line">deleteTempPackageFiles();</span><br><span class="line">//移除不相干包中的所有共享userID</span><br><span class="line">mSettings.pruneSharedUsersLPw();</span><br></pre></td></tr></table></figure><p>PMS_SYSTEM_SCAN_START阶段主要做了如下工作：</p><ul><li>首先将BOOTCLASSPATH,SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要优化dex优化集合alreadyDexOpted中<ul><li>SYSTEMSERVERCLASSPATH:主要包含&#x2F;system&#x2F;framework目录下的services.jar ethernet-service.jar,wifi-service.jar这3个文件</li><li>BOOTCLASSPATH:该环境变量内容较多，不同的ROM可能有所不同，常见内容包含&#x2F;system&#x2F;frmework目录下的freamework.jar,ext.jar,core-libart.jar,telephony-commom.jar,ims-common.jar,core-junit.jar等</li></ul></li><li>获取共享库mSharedLibraries，判断是否需要dex优化，如果需要则进行dex优化，并加入到alreadyDexOpted列表中</li><li>添加framework-res.apk,core-libart.jar两个文件添加到已优化集合alreadyDexOpted中</li><li>将framework目录下，其他的apk或jar,进行dex优化并加入到优化集合alreadyDexOpted中</li><li>scanDirLi():扫描指定目录下的apk文件，最终调用PackageParse.parseBaseApk来完成AndroidManifest.xml的文件解析，生成Application，activity,service,broadcast,provider等信息</li><li>删除系统不存在的包removePackageLI</li><li>清理安装失败的包cleanupInstallFaildPackage</li><li>删除临时文件deleteTempPackageFiles</li><li>移除不想干包中的所有共享UserId</li></ul><p>3.3 PMS_DATA_SCAN_START<br>BOOT_PROGRESS_PMS_DATA_SCAN_START阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">if (!mOnlyCore) &#123;</span><br><span class="line">      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">              SystemClock.uptimeMillis());</span><br><span class="line">      scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);</span><br><span class="line">      scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</span><br><span class="line">              scanFlags | SCAN_REQUIRE_KNOWN, 0);</span><br><span class="line">      /**</span><br><span class="line">       * Remove disable package settings for any updated system</span><br><span class="line">       * apps that were removed via an OTA. If they&#x27;re not a</span><br><span class="line">       * previously-updated app, remove them completely.</span><br><span class="line">       * Otherwise, just revoke their system-level permissions.</span><br><span class="line">       */</span><br><span class="line">      for (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</span><br><span class="line">          PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</span><br><span class="line">          mSettings.removeDisabledSystemPackageLPw(deletedAppName);</span><br><span class="line">          String msg;</span><br><span class="line">          if (deletedPkg == null) &#123;</span><br><span class="line">              msg = &quot;Updated system package &quot; + deletedAppName</span><br><span class="line">                      + &quot; no longer exists; wiping its data&quot;;</span><br><span class="line">              removeDataDirsLI(null, deletedAppName);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              msg = &quot;Updated system app + &quot; + deletedAppName</span><br><span class="line">                      + &quot; no longer present; removing system privileges for &quot;</span><br><span class="line">                      + deletedAppName;</span><br><span class="line">              deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">              PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</span><br><span class="line">              deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">          &#125;</span><br><span class="line">          logCriticalInfo(Log.WARN, msg);</span><br><span class="line">      &#125;</span><br><span class="line">      /**</span><br><span class="line">       * Make sure all system apps that we expected to appear on</span><br><span class="line">       * the userdata partition actually showed up. If they never</span><br><span class="line">       * appeared, crawl back and revive the system version.</span><br><span class="line">       */</span><br><span class="line">      for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123;</span><br><span class="line">          final String packageName = mExpectingBetter.keyAt(i);</span><br><span class="line">          if (!mPackages.containsKey(packageName)) &#123;</span><br><span class="line">              final File scanFile = mExpectingBetter.valueAt(i);</span><br><span class="line">              logCriticalInfo(Log.WARN, &quot;Expected better &quot; + packageName</span><br><span class="line">                      + &quot; but never showed up; reverting to system&quot;);</span><br><span class="line">              final int reparseFlags;</span><br><span class="line">              if (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</span><br><span class="line">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                          | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">                          | PackageParser.PARSE_IS_PRIVILEGED;</span><br><span class="line">              &#125; else if (FileUtils.contains(systemAppDir, scanFile)) &#123;</span><br><span class="line">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">              &#125; else if (FileUtils.contains(vendorAppDir, scanFile)) &#123;</span><br><span class="line">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">              &#125; else if (FileUtils.contains(oemAppDir, scanFile)) &#123;</span><br><span class="line">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  Slog.e(TAG, &quot;Ignoring unexpected fallback path &quot; + scanFile);</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line">              mSettings.enableSystemPackageLPw(packageName);</span><br><span class="line">              try &#123;</span><br><span class="line">                  scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);</span><br><span class="line">              &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                  Slog.e(TAG, &quot;Failed to parse original system package: &quot;</span><br><span class="line">                          + e.getMessage());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mExpectingBetter.clear();</span><br><span class="line">  // Now that we know all of the shared libraries, update all clients to have</span><br><span class="line">  // the correct library paths.</span><br><span class="line">  updateAllSharedLibrariesLPw();</span><br><span class="line">  for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</span><br><span class="line">      // NOTE: We ignore potential failures here during a system scan (like</span><br><span class="line">      // the rest of the commands above) because there&#x27;s precious little we</span><br><span class="line">      // can do about it. A settings error is reported, though.</span><br><span class="line">      adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,</span><br><span class="line">              false /* force dexopt */, false /* defer dexopt */);</span><br><span class="line">  &#125;</span><br><span class="line">  // Now that we know all the packages we are keeping,</span><br><span class="line">  // read and update their last usage times.</span><br><span class="line">  mPackageUsage.readLP();</span><br></pre></td></tr></table></figure><p>3.4 PMS_SCAN_END<br>BOOT_PROGRESS_PMS_SCAN_END阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,</span><br><span class="line">        SystemClock.uptimeMillis());</span><br><span class="line">Slog.i(TAG, &quot;Time to scan packages: &quot;</span><br><span class="line">        + ((SystemClock.uptimeMillis()-startTime)/1000f)</span><br><span class="line">        + &quot; seconds&quot;);</span><br><span class="line">// 当sdk版本不一致时，需要更新权限</span><br><span class="line">int updateFlags = UPDATE_PERMISSIONS_ALL;</span><br><span class="line">if (ver.sdkVersion != mSdkVersion) &#123;</span><br><span class="line">    Slog.i(TAG, &quot;Platform changed from &quot; + ver.sdkVersion + &quot; to &quot;</span><br><span class="line">            + mSdkVersion + &quot;; regranting permissions for internal storage&quot;);</span><br><span class="line">    updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</span><br><span class="line">&#125;</span><br><span class="line">updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);</span><br><span class="line">ver.sdkVersion = mSdkVersion;</span><br><span class="line">//当这是ota后的首次启动，正常启动则需要清除目录的缓存代码</span><br><span class="line">if (!onlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) &#123;</span><br><span class="line">    for (UserInfo user : sUserManager.getUsers(true)) &#123;</span><br><span class="line">        mSettings.applyDefaultPreferredAppsLPw(this, user.id);</span><br><span class="line">        applyFactoryDefaultBrowserLPw(user.id);</span><br><span class="line">        primeDomainVerificationsLPw(user.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//当权限和其他默认项都完成更新，则清理相关信息</span><br><span class="line">final int storageFlags;</span><br><span class="line">if (StorageManager.isFileEncryptedNativeOrEmulated()) &#123;</span><br><span class="line">    storageFlags = StorageManager.FLAG_STORAGE_DE;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;</span><br><span class="line">&#125;</span><br><span class="line">reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, UserHandle.USER_SYSTEM,</span><br><span class="line">        storageFlags);</span><br><span class="line">//当这是ota后的首次启动，正常启动则需要清除目录的缓存代码</span><br><span class="line">if (mIsUpgrade &amp;&amp; !onlyCore) &#123;</span><br><span class="line">    Slog.i(TAG, &quot;Build fingerprint changed; clearing code caches&quot;);</span><br><span class="line">    for (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123;</span><br><span class="line">        final PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</span><br><span class="line">            // No apps are running this early, so no need to freeze</span><br><span class="line">            clearAppDataLIF(ps.pkg, UserHandle.USER_ALL,</span><br><span class="line">                    StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE</span><br><span class="line">                            | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ver.fingerprint = Build.FINGERPRINT;</span><br><span class="line">&#125;</span><br><span class="line">checkDefaultBrowser();</span><br><span class="line">//当权限和其他默认项都完成更新，则清理相关信息</span><br><span class="line">mExistingSystemPackages.clear();</span><br><span class="line">mPromoteSystemApps = false;</span><br><span class="line">// All the changes are done during package scanning.</span><br><span class="line">ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</span><br><span class="line">//信息写回packages.xml文件</span><br><span class="line">mSettings.writeLPr();</span><br></pre></td></tr></table></figure><ul><li>当sdk版本不一致时，需要跟新权限</li><li>当这是ota后的首次启动，正常启动则需要清理目标的缓存代码</li><li>当权限和其他默认项都完成更新，则清理相关信息</li><li>信息写回package.xml文件</li></ul><p>3.5 PMS_READY<br>BOOT_PROGRESS_PMS_READY阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line">    if (!mOnlyCore) &#123;</span><br><span class="line">        mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();</span><br><span class="line">        mRequiredInstallerPackage = getRequiredInstallerLPr();</span><br><span class="line">        mRequiredUninstallerPackage = getRequiredUninstallerLPr();</span><br><span class="line">        mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</span><br><span class="line">        mIntentFilterVerifier = new IntentVerifierProxy(mContext,</span><br><span class="line">                mIntentFilterVerifierComponent);</span><br><span class="line">        mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr(</span><br><span class="line">                PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES);</span><br><span class="line">        mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr(</span><br><span class="line">                PackageManager.SYSTEM_SHARED_LIBRARY_SHARED);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mRequiredVerifierPackage = null;</span><br><span class="line">        mRequiredInstallerPackage = null;</span><br><span class="line">        mRequiredUninstallerPackage = null;</span><br><span class="line">        mIntentFilterVerifierComponent = null;</span><br><span class="line">        mIntentFilterVerifier = null;</span><br><span class="line">        mServicesSystemSharedLibraryPackageName = null;</span><br><span class="line">        mSharedSystemSharedLibraryPackageName = null;</span><br><span class="line">    &#125;</span><br><span class="line">    mInstallerService = new PackageInstallerService(context, this);</span><br><span class="line">    final ComponentName ephemeralResolverComponent = getEphemeralResolverLPr();</span><br><span class="line">    final ComponentName ephemeralInstallerComponent = getEphemeralInstallerLPr();</span><br><span class="line">    // both the installer and resolver must be present to enable ephemeral</span><br><span class="line">    if (ephemeralInstallerComponent != null &amp;&amp; ephemeralResolverComponent != null) &#123;</span><br><span class="line">        if (DEBUG_EPHEMERAL) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Ephemeral activated; resolver: &quot; + ephemeralResolverComponent</span><br><span class="line">                    + &quot; installer:&quot; + ephemeralInstallerComponent);</span><br><span class="line">        &#125;</span><br><span class="line">        mEphemeralResolverComponent = ephemeralResolverComponent;</span><br><span class="line">        mEphemeralInstallerComponent = ephemeralInstallerComponent;</span><br><span class="line">        setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent);</span><br><span class="line">        mEphemeralResolverConnection =</span><br><span class="line">                new EphemeralResolverConnection(mContext, mEphemeralResolverComponent);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (DEBUG_EPHEMERAL) &#123;</span><br><span class="line">            final String missingComponent =</span><br><span class="line">                    (ephemeralResolverComponent == null)</span><br><span class="line">                    ? (ephemeralInstallerComponent == null)</span><br><span class="line">                            ? &quot;resolver and installer&quot;</span><br><span class="line">                            : &quot;resolver&quot;</span><br><span class="line">                    : &quot;installer&quot;;</span><br><span class="line">            Slog.i(TAG, &quot;Ephemeral deactivated; missing &quot; + missingComponent);</span><br><span class="line">        &#125;</span><br><span class="line">        mEphemeralResolverComponent = null;</span><br><span class="line">        mEphemeralInstallerComponent = null;</span><br><span class="line">        mEphemeralResolverConnection = null;</span><br><span class="line">    &#125;</span><br><span class="line">    mEphemeralApplicationRegistry = new EphemeralApplicationRegistry(this);</span><br><span class="line">&#125; // synchronized (mPackages)</span><br><span class="line">&#125; // synchronized (mInstallLock)</span><br><span class="line">// Now after opening every single application zip, make sure they</span><br><span class="line">// are all flushed.  Not really needed, but keeps things nice and</span><br><span class="line">// tidy.</span><br><span class="line">Runtime.getRuntime().gc();</span><br><span class="line">// The initial scanning above does many calls into installd while</span><br><span class="line">// holding the mPackages lock, but we&#x27;re mostly interested in yelling</span><br><span class="line">// once we have a booted system.</span><br><span class="line">mInstaller.setWarnIfHeld(mPackages);</span><br><span class="line">// Expose private service for system components to use.</span><br><span class="line">LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());</span><br></pre></td></tr></table></figure><ul><li>初始化PackageInstallerService</li><li>GC回收下内存</li></ul><h3 id="四-PMS构造函数-总结"><a href="#四-PMS构造函数-总结" class="headerlink" title="四. PMS构造函数-总结"></a>四. PMS构造函数-总结</h3><p>PMS初始化过程，分为5个阶段:<br>1.PMS_START阶段:</p><ul><li>创建Setting对象；</li><li>将6类shareUserId到mSettings;</li><li>初始化SystemConfig;</li><li>创建名为“PackageManagerService”的handler线程mHandlerThread</li><li>创建UserManagerService多用户管理服务</li><li>通过解析4大目录中的xml文件构造共享mSharedLibraries;</li></ul><ol start="2"><li>PMS_SYSTEM_SCAN_START阶段：</li></ol><ul><li>mSharedLibraries共享库的文件执行dexopt操作</li><li>system&#x2F;framework目录中满足的pak或jar文件执行dexopt操作</li><li>扫描系统apk</li></ul><ol start="3"><li>PMS_DATA_SCAN_START阶段:</li></ol><ul><li>扫描&#x2F;data&#x2F;app目录下的apk</li><li>扫描&#x2F;data&#x2F;app-private目录下的apk</li></ul><ol start="4"><li>PMS_SCAN_END</li></ol><ul><li>将上诉信息写回&#x2F;data&#x2F;system&#x2F;package.xml<br>5 PMS_READY阶段</li><li>创建服务PackageInstallerService</li></ul><p>到这里，大致介绍完了整个PMS构造函数的流程，基本上PMS_SCAN_END阶段我们apk就算安装完成了，接下来是单独看看几个比较重要模块</p><ul><li>Setting</li><li>SystemConfig-readPermissions</li><li>scanPackageLI</li></ul><h3 id="五-Settings"><a href="#五-Settings" class="headerlink" title="五. Settings"></a>五. Settings</h3><p>在BOOT_PROGRESS_PMS_START阶段，我们会创建Setting对象，以及一堆addSharedUserLPw调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mSettings = new Settings(mPackages);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, Process.SYSTEM_UID,</span><br><span class="line">    ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.1 创建Settings</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[frameworks/base/services/core/java/com/android/server/pm/Settings.java]</span><br><span class="line">Settings(Object lock) &#123;</span><br><span class="line">    this(Environment.getDataDirectory(), lock);</span><br><span class="line">&#125;</span><br><span class="line">Settings(File dataDir, Object lock) &#123;</span><br><span class="line">    mLock = lock;</span><br><span class="line">    mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock);</span><br><span class="line">    //创建目录&quot;data/system&quot;</span><br><span class="line">    mSystemDir = new File(dataDir, &quot;system&quot;);</span><br><span class="line">    mSystemDir.mkdirs();</span><br><span class="line">    FileUtils.setPermissions(mSystemDir.toString(),</span><br><span class="line">            FileUtils.S_IRWXU|FileUtils.S_IRWXG</span><br><span class="line">            |FileUtils.S_IROTH|FileUtils.S_IXOTH,</span><br><span class="line">            -1, -1);</span><br><span class="line">    // packages.xml和packages-backup.xml为一组，用于描述系统所安装的Package信息，</span><br><span class="line">    // 其中packages-backup.xml是packages.xml的备份</span><br><span class="line">    // PMS写把数据写到backup文件中，信息全部写成功后在改名为非backup文件，</span><br><span class="line">    // 以防止在写文件的过程中出错，导致信息丢失</span><br><span class="line">    mSettingsFilename = new File(mSystemDir, &quot;packages.xml&quot;);</span><br><span class="line">    mBackupSettingsFilename = new File(mSystemDir, &quot;packages-backup.xml&quot;);</span><br><span class="line">    //packages.list保存系统中存在的所有非系统自带的APK信息，即UID大于10000的apk</span><br><span class="line">    mPackageListFilename = new File(mSystemDir, &quot;packages.list&quot;);</span><br><span class="line">    FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID);</span><br><span class="line">    //感觉是sdcardfs相关的文件</span><br><span class="line">    final File kernelDir = new File(&quot;/config/sdcardfs&quot;);</span><br><span class="line">    mKernelMappingFilename = kernelDir.exists() ? kernelDir : null;</span><br><span class="line">    // Deprecated: Needed for migration</span><br><span class="line">    //packages-stopped.xml用于描述系统中强行停止运行的package信息，backup也是备份文件</span><br><span class="line">    mStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped.xml&quot;);</span><br><span class="line">    mBackupStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped-backup.xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Setting的构造函数主要用于创建data&#x2F;system 目录和一些xml文件，并配置相应的权限，其中：</p><ul><li>packages.xml记录所有安装app信息，当系统进行程序安装，卸载和更新操作时，均会跟新该文件</li><li>package-backup.xml 备份文件</li><li>packages-stopped.xml 记录被用户强行停止的应用Package信息</li><li>packages-stopped-backup.xml 备份文件</li><li>packages.list 记录非系统自带的apk的数据信息，这些apk有变化会更新该文件</li></ul><p>5.2 Setting.readLPw<br>readLPw()函数，从&#x2F;data&#x2F;system&#x2F;packages.xml或packages-backup.xml文件中获取packages,permissions相关信息，添加相关内存列表。packages.xml文件记录了系统的permisssions以及每个apk的name,codePath,flags,version等信息这些信息主要通过apk的AndroidManifest.xml解析获取，解析完apk后将更新信息写入这个文件，下次开机直接从里面读取相关信息添加到内存相关结构中，当有apk升级，安装，删除会更新这个文件。</p><p>5.3 Setting.writeLPr<br>writeLPr函数，将解析出的每个apk的信息（mSetting.mPackages）保存到packages.xml和packages.list文件。packages.list记录如下数据：pkgName,userid,debugFlag,dataPath(包的数据路径)</p><h3 id="六-SystemConfig-readPermissions"><a href="#六-SystemConfig-readPermissions" class="headerlink" title="六. SystemConfig-readPermissions"></a>六. SystemConfig-readPermissions</h3><p>同样在BOOT_PROGRESS_PMS_START阶段，我们会初始化SystemConfig去获取系统配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取系统配置信息</span><br><span class="line">SystemConfig systemConfig = SystemConfig.getInstance();</span><br><span class="line">mGlobalGids = systemConfig.getGlobalGids();</span><br><span class="line">mSystemPermissions = systemConfig.getSystemPermissions();</span><br><span class="line">mAvailableFeatures = systemConfig.getAvailableFeatures();</span><br></pre></td></tr></table></figure><p>6.1 创建SystemCofig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[frameworks/base/services/core/java/com/android/server/SystemConfig.java]</span><br><span class="line">//单例模式</span><br><span class="line">public static SystemConfig getInstance() &#123;</span><br><span class="line">    synchronized (SystemConfig.class) &#123;</span><br><span class="line">        if (sInstance == null) &#123;</span><br><span class="line">            sInstance = new SystemConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SystemConfig() &#123;</span><br><span class="line">    // system/etc/目录</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getRootDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_ALL);</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getRootDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_ALL);</span><br><span class="line">    int odmPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS;</span><br><span class="line">    </span><br><span class="line">    // odm/etc/目录</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getOdmDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), odmPermissionFlag);</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getOdmDirectory(), &quot;etc&quot;, &quot;permissions&quot;), odmPermissionFlag);</span><br><span class="line">    // oem/etc/目录</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">        Environment.getOemDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_FEATURES);</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">        Environment.getOemDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_FEATURES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，SystemConfig是单例模式，会通过readPermissions解析目录下的xml文件：<br>*&#x2F;system&#x2F;etc&#x2F;sysconfig<br>*&#x2F;system&#x2F;etc&#x2F;permissions<br>*&#x2F;odm&#x2F;etc&#x2F;sysconfig<br>*&#x2F;odm&#x2F;etc&#x2F;permissions<br>*&#x2F;oem&#x2F;etc&#x2F;sysconfig<br>*&#x2F;oem&#x2F;etc&#x2F;permissions<br>其中比较重要的是system&#x2F;etc&#x2F;permisssions目录，该目录大多来源于代码中的frameworks&#x2F;(base or native)&#x2F;data&#x2F;etc，这些文件的作用表明系统支持的feature有哪些，例如是否支持蓝牙，wifi,p2p</p><p>6.2 readzPermissions</p><p>readPermissions会循环去读取目录下的xml,但是它会跳过platform.xml文件，最后再去读取platform.xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void readPermissions(File libraryDir, int permissionFlag) &#123;</span><br><span class="line">    //检测目录是否存在，是否可读</span><br><span class="line">    ..........</span><br><span class="line">    // Iterate over the files in the directory and scan .xml files</span><br><span class="line">    File platformFile = null;</span><br><span class="line">    //  循环解析xml文件</span><br><span class="line">    for (File f : libraryDir.listFiles()) &#123;</span><br><span class="line">        // 跳过，最后再解析platform.xml </span><br><span class="line">        if (f.getPath().endsWith(&quot;etc/permissions/platform.xml&quot;)) &#123;</span><br><span class="line">            platformFile = f;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 解析可读的xml文件</span><br><span class="line">        readPermissionsFromXml(f, permissionFlag);</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后解析platform.xml文件</span><br><span class="line">    if (platformFile != null) &#123;</span><br><span class="line">        readPermissionsFromXml(platformFile, permissionFlag);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现读取函数最后都调用最后都调用readPermissionsFromXml(),函数readPermissionFromXml最终会使用XMLPullParase的方式解析这些文件，然后再把解析出来的数据结构保存到PMS中</p><p>6.2.1 android.hardware.bluetooth.xml<br>最终会解析并且保存到PMS的 final ArrayMap&lt;String, FeatureInfo&gt; mAvailableFeatures中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;permissions&gt;  </span><br><span class="line">    &lt;feature name=&quot;android.hardware.bluetooth&quot; /&gt;  </span><br><span class="line">&lt;/permissions&gt;</span><br></pre></td></tr></table></figure><p>6.2.2 com.android.location.provider.xml<br>指明了运行一些library时，还需要加载一些java库。<br>这个最终会解析并保存到PMS的final ArrayMap&lt;String, SharedLibraryEntry&gt; mSharedLibraries中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;permissions&gt;</span><br><span class="line">    &lt;library name=&quot;com.android.location.provider&quot;</span><br><span class="line">            file=&quot;/system/framework/com.android.location.provider.jar&quot; /&gt;</span><br><span class="line">&lt;/permissions&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.2.3 platform.xml<br>这个文件中定义了底层GID和app层权限名字之间的对应关系，或者直接给某一个uid赋予对应的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;permissions&gt;</span><br><span class="line">    &lt;permission name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &gt;</span><br><span class="line">        &lt;group gid=&quot;sdcard_r&quot; /&gt;</span><br><span class="line">        &lt;group gid=&quot;sdcard_rw&quot; /&gt;</span><br><span class="line">    &lt;/permission&gt;</span><br><span class="line">    ......</span><br><span class="line">    &lt;assign-permission name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; uid=&quot;media&quot; /&gt;</span><br><span class="line">    &lt;assign-permission name=&quot;android.permission.ACCESS_SURFACE_FLINGER&quot; uid=&quot;media&quot; /&gt;</span><br><span class="line">    ......</span><br><span class="line">&lt;/permissions&gt;</span><br></pre></td></tr></table></figure><p>解析<permission>标签的时候，会创建一个PermissionEntry类，他关联了gids和permission name：<br>最终PermissionEntry会放入SystemConfig的final ArrayMap&lt;String, PermissionEntry&gt; mPermissions变量中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static final class PermissionEntry &#123;</span><br><span class="line">        public final String name;</span><br><span class="line">        public int[] gids;</span><br><span class="line">        PermissionEntry(String _name) &#123;</span><br><span class="line">            name = _name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解析<assign-permission>的时候表示把属性name中的字符串表示的权限赋予属性uid中的用户。uid和name则存入SystemConfig中的SparseArray&gt; 类型的mSystemPermissions变量中</p><p>7.2 scanPackageLI安装apk<br>PackageManagerService的scanPackageLI过程scanPackageLI()有3个重载的方法，参数稍有不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 第（1）个</span><br><span class="line">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,</span><br><span class="line">        long currentTime, UserHandle user)</span><br><span class="line">// 第（2）个</span><br><span class="line">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile,</span><br><span class="line">        final int policyFlags, int scanFlags, long currentTime, UserHandle user)</span><br><span class="line">// 第（3）个</span><br><span class="line">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags,</span><br><span class="line">        int scanFlags, long currentTime, UserHandle user)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(1）scanPackageLI(File scanFile, int parseFlags,…）函数</p><p>实例化一个PackageParser对象，接着调用该对象的parsePackage()对APK文件进行解析。<br>实例化一个Package对象，用于保存解析出的APK信息<br>从AndroidManifest.xml文件中解析出VersionCode、VersionName、installLocation等全局属性信息，然后根据标签循环解析XML文件包含的其它组成部分，将解析出的信息添加到Package对象的相关列表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,</span><br><span class="line">        long currentTime, UserHandle user) throws PackageManagerException &#123;</span><br><span class="line">    //创建出PackageParser对象</span><br><span class="line">    PackageParser pp = new PackageParser();</span><br><span class="line">    ...........</span><br><span class="line">    final PackageParser.Package pkg;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 解析package</span><br><span class="line">        pkg = pp.parsePackage(scanFile, parseFlags);</span><br><span class="line">    &#125; catch (PackageParserException e) &#123;</span><br><span class="line">        ..........</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ..........</span><br><span class="line">    &#125;</span><br><span class="line">    //调用第（2）个scanPackageLI</span><br><span class="line">    return scanPackageLI(pkg, scanFile, parseFlags, scanFlags, currentTime, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会调用第（2）个scanPackageLI去继续解析。</p><p>（2）scanPackageLI(PackageParser.Package pkg, File scanFile,…)函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile,</span><br><span class="line">        final int policyFlags, int scanFlags, long currentTime, UserHandle user)</span><br><span class="line">        throws PackageManagerException &#123;</span><br><span class="line">    </span><br><span class="line">    //有childPackage时，第一次只执行检查的工作</span><br><span class="line">    if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123;</span><br><span class="line">        //当解析一个Package的AndroidManifest.xml时，如果该XML文件中使用了&quot;package&quot;的tag</span><br><span class="line">        //那么该tag对应的package是当前XML文件对应package的childPackage</span><br><span class="line">        if (pkg.childPackages != null &amp;&amp; pkg.childPackages.size() &gt; 0) &#123;</span><br><span class="line">            scanFlags |= SCAN_CHECK_ONLY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //第二次进入，才开始实际的解析</span><br><span class="line">        scanFlags &amp;= ~SCAN_CHECK_ONLY;</span><br><span class="line">    &#125;</span><br><span class="line">    final PackageParser.Package scannedPkg;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Scan the parent</span><br><span class="line">        //scanFlags将决定这一次是否仅执行检查工作</span><br><span class="line">        scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags, currentTime, user);</span><br><span class="line">        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            PackageParser.Package childPkg = pkg.childPackages.get(i);</span><br><span class="line">            scanPackageLI(childPkg, policyFlags,</span><br><span class="line">                    scanFlags, currentTime, user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        .........   </span><br><span class="line">    &#125;</span><br><span class="line">    if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123;</span><br><span class="line">        //第一次检查完毕后，再次调用函数</span><br><span class="line">        return scanPackageTracedLI(pkg, policyFlags, scanFlags, currentTime, user);</span><br><span class="line">    &#125;</span><br><span class="line">    return scannedPkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）scanPackageLI(PackageParser.Package pkg, final int policyFlags,…)函数</p><p>最终会走到第三个scanPackageLI函数，这个函数最后会调用scanPackageDirtyLI函数，scanPackageDirtyLI是实际解析package的函数，这个才是真正干活的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags,</span><br><span class="line">        int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123;</span><br><span class="line">    boolean success = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        //实际的解析函数，很长...</span><br><span class="line">        final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags,</span><br><span class="line">                currentTime, user);</span><br><span class="line">        success = true;</span><br><span class="line">        return res;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.3 scanPackageDirtyLI<br>通过上述的扫描过程，我们得到了当前apk文件对应的Package信息。不过这部分信息是存储在PackageParser中的，我们必须将这部分信息传递到PMS中。毕竟最终的目的是：让PMS能得到所有目录下Package的信息。<br>scanPackageDirtyLI函数主要就是把签名解析应用程序得到的package、provider、service、receiver和activity等信息保存在PackageManagerService相关的成员列表里。</p><p>比如将每个APK的receivers列表里的元素，通过mReceivers.addActivity(a, “receiver”)添加到PMS成员列表mReceivers中:</p><p>1<br>final ActivityIntentResolver mReceivers &#x3D; new ActivityIntentResolver();&#96;<br>由于实际解析函数太长，粗略看下有1000来行，读者有兴趣的可以自行研究。</p><p>八、开机时间分析<br>adb shell cat &#x2F;proc&#x2F;bootprof&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> C:\Users\shun&gt;adb shell cat /proc/bootprof</span><br><span class="line">----------------------------------------</span><br><span class="line">0           BOOT PROF (unit:msec)</span><br><span class="line">----------------------------------------</span><br><span class="line">      1655        : preloader</span><br><span class="line">      1001        : lk</span><br><span class="line">       493        : lk-&gt;Kernel</span><br><span class="line">----------------------------------------</span><br><span class="line">      5156.702307 : Kernel_init_done</span><br><span class="line">      5171.629538 : SElinux start.</span><br><span class="line">     10739.699692 : SElinux end.</span><br><span class="line">     11496.788538 : INIT: on init start</span><br><span class="line">     11878.325615 : INIT:eMMC:Mount_START</span><br><span class="line">     12777.653384 : INIT:eMMC:Mount_END</span><br><span class="line">     12780.874230 : INIT:PROTECT:Mount_START</span><br><span class="line">     12938.042615 : INIT:PROTECT:Mount_END</span><br><span class="line">     14029.370538 : INIT: eng build setting</span><br><span class="line">     15215.342538 : BOOT_Animation:START</span><br><span class="line">     16618.475076 : Zygote:Preload Start</span><br><span class="line">     20691.658230 : Zygote:Preload 2775 classes in 4062ms</span><br><span class="line">     23061.424153 : Zygote:Preload 274 obtain resources in 2334ms</span><br><span class="line">     23110.519076 : Zygote:Preload 31 resources in 47ms</span><br><span class="line">     23240.816000 : Zygote:Preload End</span><br><span class="line">     23720.832000 : Android:SysServerInit_START</span><br><span class="line">     24448.175153 : Android:PackageManagerService_Start</span><br><span class="line">     24747.363153 : Android:PMS_scan_START</span><br><span class="line">     24817.216000 : Android:PMS_scan_done:/custom/framework</span><br><span class="line">     24947.104384 : Android:PMS_scan_done:/system/framework</span><br><span class="line">     25131.265384 : Android:PMS_scan_done:/system/priv-app</span><br><span class="line">     25533.440461 : Android:PMS_scan_done:/system/app</span><br><span class="line">     25540.237769 : Android:PMS_scan_done:/system/vendor/app</span><br><span class="line">     25542.379538 : Android:PMS_scan_done:/system/vendor/operator/app</span><br><span class="line">     25544.285615 : Android:PMS_scan_done:/custom/app</span><br><span class="line">     25551.297076 : Android:PMS_scan_data_start</span><br><span class="line">     25967.971076 : Android:PMS_scan_data_done:/data/app</span><br><span class="line">     25969.811230 : Android:PMS_scan_data_done:/data/app-private</span><br><span class="line">     25971.862692 : Android:PMS_scan_END</span><br><span class="line">     26224.410076 : Android:PMS_READY</span><br><span class="line">     30108.635538 : AP_Init:[service]:[com.mediatek.security]:[com.mediatek.security/.service.PermControlService]:pid:738</span><br><span class="line">     30548.305692 : AP_Init:[broadcast]:[com.android.settings]:[com.android.settings/.widget.SettingsAppWidgetProvider]:pid:769</span><br><span class="line">     31341.380923 : AP_Init:[broadcast]:[com.mediatek.engineermode]:[com.mediatek.engineermode/.wifi.WifiStateReceiver]:pid:806</span><br><span class="line">     31563.917923 : AP_Init:[broadcast]:[com.tvguo.app]:[com.tvguo.app/.content.TvguoStateReceiver]:pid:829</span><br><span class="line">     31708.206000 : AP_Init:[service]:[com.android.systemui]:[com.android.systemui/.ImageWallpaper]:pid:847</span><br><span class="line">     31796.008076 : AP_Init:[service]:[com.android.inputmethod.latin]:[com.android.inputmethod.latin/.LatinIME]:pid:860</span><br><span class="line">     31987.434923 : AP_Init:[added application]:[com.mediatek.dongle]:[com.mediatek.dongle]:pid:878:(PersistAP)</span><br><span class="line">     32051.271692 : AP_Init:[added application]:[com.mediatek.bluetooth]:[com.mediatek.bluetooth]:pid:891:(PersistAP)</span><br><span class="line">     32142.389846 : AP_Init:[activity]:[com.android.launcher3]:[com.android.launcher3/.Launcher]:pid:906</span><br><span class="line">     32170.530846 : Android:SysServerInit_END</span><br><span class="line">     32309.788000 : AP_Init:[service]:[com.android.printspooler]:[com.android.printspooler/.PrintSpoolerService]:pid:923</span><br><span class="line">     33967.604076 : AP_Init:[broadcast]:[com.android.contacts]:[com.android.contacts/com.mediatek.contacts.simcontact.BootCmpReceiver]:pid:972</span><br><span class="line">     34752.970538 : AP_Init:[content provider]:[android.process.acore]:[com.android.providers.contacts/.ContactsProvider2]:pid:1028</span><br><span class="line">     35486.120000 : BOOT_Animation:END</span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure><p>我们可以从上面的信息看到PMS在开机的时候做的动作和时间分布：（因为手上只有kk的平台，所以信息不太对应）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">24747.363153 : Android:PMS_scan_START</span><br><span class="line">24817.216000 : Android:PMS_scan_done:/custom/framework</span><br><span class="line">24947.104384 : Android:PMS_scan_done:/system/framework</span><br><span class="line">25131.265384 : Android:PMS_scan_done:/system/priv-app</span><br><span class="line">25533.440461 : Android:PMS_scan_done:/system/app</span><br><span class="line">25540.237769 : Android:PMS_scan_done:/system/vendor/app</span><br><span class="line">25542.379538 : Android:PMS_scan_done:/system/vendor/operator/app</span><br><span class="line">25544.285615 : Android:PMS_scan_done:/custom/app</span><br><span class="line">25551.297076 : Android:PMS_scan_data_start</span><br><span class="line">25967.971076 : Android:PMS_scan_data_done:/data/app</span><br><span class="line">25969.811230 : Android:PMS_scan_data_done:/data/app-private</span><br><span class="line">25971.862692 : Android:PMS_scan_END</span><br><span class="line">26224.410076 : Android:PMS_READY</span><br><span class="line">一般app装的越多，那么开机时间就会越长。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码(4)-应用程序安装流程</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(4)-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(4)-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一-安装流程图"><a href="#一-安装流程图" class="headerlink" title="一. 安装流程图"></a>一. 安装流程图</h1><p><img src="/img/pms_install.png" alt="pms-install"></p><p>从上图我们可以看到apk安装到最后都会调用到这个flow：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PMS.scanPackageTracedLI=&gt;PMS.scanPackageLI=&gt;PMS.scanPackageDirtyLI</span><br></pre></td></tr></table></figure><h1 id="二-APK文件结构"><a href="#二-APK文件结构" class="headerlink" title="二. APK文件结构"></a>二. APK文件结构</h1><p>APK(Android Package)，可以看做是一个zip压缩包，可以通过解压缩工具解开，其文件结构如下：</p><table><thead><tr><th align="center">目录 or 文件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">assert</td><td align="center">存放的原生资源文件,通过AssetManager类访问</td></tr><tr><td align="center">lib</td><td align="center">native库文件</td></tr><tr><td align="center">META - INF</td><td align="center">存放签名信息，用来保证APK包的完整性和系统的安全。系统安装APK时，应用管理器会按照对应算法对包里文件做校验，<br>如果校验结果与META-INF中内容不一致，则不会安装这个APK。</td></tr><tr><td align="center">res</td><td align="center">种资源文件系统会在R.java里面自动生成该资源文件的ID，所以访问这种资源文件比较简单，通过R.XXX.ID即可</td></tr><tr><td align="center">AndroidManifest.xml</td><td align="center">每个应用都必须定义和包含，描述应用的名字、版本权限、引用的库文件等信息。apk中的AndroidManifest.xml经过压缩，<br>可以通过AXMLPrinter2工具解开。</td></tr><tr><td align="center">classes.dex</td><td align="center">是JAVA源码编译后生成的JAVA字节码文件。但Android使用的dalvik虚拟机与标准的JAVA虚拟机不兼容，<br>dex文件与class文件相比，不论是文件结构还是opcode都不一样。</td></tr><tr><td align="center">resources.arsc</td><td align="center">编译后的二进制资源文件。</td></tr></tbody></table><h1 id="三-apk安装方法"><a href="#三-apk安装方法" class="headerlink" title="三. apk安装方法"></a>三. apk安装方法</h1><p>apk有下面4种安装方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">开机过程中安装</td><td align="center">开机时完成，没有安装界面，如系统应用、其它预置应用</td></tr><tr><td align="center">adb工具安装</td><td align="center">没有安装界面，adb install&#x2F;push xxxx.apk</td></tr><tr><td align="center">第三方应用安装</td><td align="center">通过packageinstaller.apk进行安装，有安装界面，如打开文件管理器并点击sdk卡里APK文件</td></tr><tr><td align="center">网络下载应用安装</td><td align="center">通过google market应用完成，没有安装界面</td></tr></tbody></table><p>简单说明下apk安装的基本过程：</p><p>拷贝目标apk到指定文件目录<br>调用scanPackageLI为apk文件在系统中注册信息</p><h1 id="四-引用程序安装过程"><a href="#四-引用程序安装过程" class="headerlink" title="四.引用程序安装过程"></a>四.引用程序安装过程</h1><p>上述几种安装方法最终都通过PackageManagerService.scanPackageLI完成，总结起来大致有以下三种方式：</p><ul><li>adb push：<br>PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件<br>frameworks\base\services\java\com\android\server\pm\PackageManagerService.java</li><li>adb install：<br>安装入口函数为Pm.runInstall<br>frameworks\base\cmds\pm\src\com\android\commands\pm\Pm.java</li><li>网络下载应用安装和第三方应用安装：<br>安装入口函数为ApplicationPackageManager.installPackage<br>frameworks\base\core\java\android\app\ApplicationPackageManager.java</li></ul><h1 id="五、adb-push"><a href="#五、adb-push" class="headerlink" title="五、adb push"></a>五、adb push</h1><p>Android 4.4平台，PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件。<br>如果是添加事件，则调用scanPackageLI，并使用updatePermissionsLPw授权；如果是删除事件则调用removePackageLI移除该apk的相关信息。最后都要调用writeLPr重新保存相关信息到packages.xml。</p><p>关于AppDirObserver具体如何监听的，可以查看：AppDirObserver</p><p>不过我在android 7.0 sdk里面没有看到这个类，难道7.0把这个功能砍了？手头没有7.0平台，不好验证。</p><p>我猜测现在通过adb push apk到data&#x2F;app或者system&#x2F;app的apk，如果这个监听的功能砍了，那么应该是会通过reboot重启系统，走PMS.main流程，scanDir–&gt;scanPackageLI去安装apk。</p><p>以上待填坑。</p><h1 id="六、adb-install"><a href="#六、adb-install" class="headerlink" title="六、adb install"></a>六、adb install</h1><p>adb install 的安装方式，会调用system&#x2F;core&#x2F;adb&#x2F;commandline.cpp中的adb_commandline函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb_commandline</span><br><span class="line">    install_app_legacy or install_app </span><br><span class="line">        pm_command</span><br><span class="line">            send_shell_command</span><br><span class="line">                Pm.runInstall()</span><br></pre></td></tr></table></figure><p>这个过程会把apk文件copy到data&#x2F;local&#x2F;tmp&#x2F;目录下，然后向shell服务发送pm命令安装apk，最后调用Pm.runInstall()方法来安装apk。</p><p>6.1 pm.runInstall<br>frameworks\base\cmds\pm\src\com\android\commands\pm\Pm.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private int runInstall() throws RemoteException &#123;</span><br><span class="line">    final InstallParams params = makeInstallParams();</span><br><span class="line">    // 1. 创建session</span><br><span class="line">    final int sessionId = doCreateSession(params.sessionParams,</span><br><span class="line">            params.installerPackageName, params.userId);</span><br><span class="line">    try &#123;</span><br><span class="line">        final String inPath = nextArg();</span><br><span class="line">        if (inPath == null &amp;&amp; params.sessionParams.sizeBytes == 0) &#123;</span><br><span class="line">            System.err.println(&quot;Error: must either specify a package size or an APK file&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 写session</span><br><span class="line">        if (doWriteSession(sessionId, inPath, params.sessionParams.sizeBytes, &quot;base.apk&quot;,</span><br><span class="line">                false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. 提交Session</span><br><span class="line">        if (doCommitSession(sessionId, false /*logSuccess*/)</span><br><span class="line">                != PackageInstaller.STATUS_SUCCESS) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Success&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstaller.abandonSession(sessionId);</span><br><span class="line">        &#125; catch (Exception ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码来看，runInstall主要进行了三件事，即创建session、对session进行写操作，最后提交session。</p><p>6.1.1 doCreateSession<br>实际调用的是PackageInstallerService的createSession，这个过程主要是为APK安装做好准备工作，例如权限检查、目的临时文件的创建等， 最终创建出PackageInstallerSession对象。PackageInstallerSession可以看做是”安装APK”这个请求的封装，其中包含了处理这个请求需要的一些信息。<br>实际上PackageInstallerSession不仅是分装请求的对象，其自身还是个服务端。</p><p>6.1.2 doWriteSession<br>通过PackageInstallerSession将&#x2F;data&#x2F;local&#x2F;tmp的apk拷贝到终端目录内。</p><p>6.1.3 doCommitSession<br>doWriteSession结束后，如果没有出现任何错误，那么APK源文件已经copy到目的地址了，doCommitSession最终会调用到PMS.installStage来安装apk，调用流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PackageInstallerSession.commit ==&gt; commitLocked(); ==&gt; PMS.installStage()</span><br></pre></td></tr></table></figure><p>PMS.installStage()会调用sendMessage将”INIT_COPY”发送给PackageHandler：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void installStage(String packageName, File stagedDir, String stagedCid,</span><br><span class="line">        IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams,</span><br><span class="line">        String installerPackageName, int installerUid, UserHandle user,</span><br><span class="line">        Certificate[][] certificates) &#123;</span><br><span class="line">    if (DEBUG_EPHEMERAL) &#123;</span><br><span class="line">        if ((sessionParams.installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0) &#123;</span><br><span class="line">            Slog.d(TAG, &quot;Ephemeral install of &quot; + packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    final VerificationInfo verificationInfo = new VerificationInfo(</span><br><span class="line">            sessionParams.originatingUri, sessionParams.referrerUri,</span><br><span class="line">            sessionParams.originatingUid, installerUid);</span><br><span class="line">    final OriginInfo origin;</span><br><span class="line">    if (stagedDir != null) &#123;</span><br><span class="line">        origin = OriginInfo.fromStagedFile(stagedDir);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        origin = OriginInfo.fromStagedContainer(stagedCid);</span><br><span class="line">    &#125;</span><br><span class="line">    final Message msg = mHandler.obtainMessage(INIT_COPY);</span><br><span class="line">    final InstallParams params = new InstallParams(origin, null, observer,</span><br><span class="line">            sessionParams.installFlags, installerPackageName, sessionParams.volumeUuid,</span><br><span class="line">            verificationInfo, user, sessionParams.abiOverride,</span><br><span class="line">            sessionParams.grantedRuntimePermissions, certificates);</span><br><span class="line">    params.setTraceMethod(&quot;installStage&quot;).setTraceCookie(System.identityHashCode(params));</span><br><span class="line">    msg.obj = params;</span><br><span class="line">    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installStage&quot;,</span><br><span class="line">            System.identityHashCode(msg.obj));</span><br><span class="line">    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;queueInstall&quot;,</span><br><span class="line">            System.identityHashCode(msg.obj));</span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PackageHandler用于处理apk的安装请求等消息，后面分析。</p><h1 id="七、ApplicationPackageManager"><a href="#七、ApplicationPackageManager" class="headerlink" title="七、ApplicationPackageManager"></a>七、ApplicationPackageManager</h1><p>网络下载应用安装或者通过第三方应用安装，最终都会通过ApplicationPackageManager.installPackage来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void installPackage(Uri packageURI, PackageInstallObserver observer,</span><br><span class="line">            int flags, String installerPackageName) &#123;</span><br><span class="line">        installCommon(packageURI, observer, flags, installerPackageName, mContext.getUserId());</span><br><span class="line">    &#125;</span><br><span class="line">private void installCommon(Uri packageURI,</span><br><span class="line">        PackageInstallObserver observer, int flags, String installerPackageName,</span><br><span class="line">        int userId) &#123;</span><br><span class="line">    if (!&quot;file&quot;.equals(packageURI.getScheme())) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;Only file:// URIs are supported&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final String originPath = packageURI.getPath();</span><br><span class="line">    try &#123;</span><br><span class="line">        // PMS.installPackageAsUser</span><br><span class="line">        mPM.installPackageAsUser(originPath, observer.getBinder(), flags, installerPackageName,</span><br><span class="line">            userId);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMS.installPackageAsUser调用sendMessage将”INIT_COPY”发送给PackageHandler:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer,</span><br><span class="line">        int installFlags, String installerPackageName, int userId) &#123;</span><br><span class="line">    ...</span><br><span class="line">    final Message msg = mHandler.obtainMessage(INIT_COPY);</span><br><span class="line">    final VerificationInfo verificationInfo = new VerificationInfo(</span><br><span class="line">            null /*originatingUri*/, null /*referrer*/, -1 /*originatingUid*/, callingUid);</span><br><span class="line">    final InstallParams params = new InstallParams(origin, null /*moveInfo*/, observer,</span><br><span class="line">            installFlags, installerPackageName, null /*volumeUuid*/, verificationInfo, user,</span><br><span class="line">            null /*packageAbiOverride*/, null /*grantedPermissions*/,</span><br><span class="line">            null /*certificates*/);</span><br><span class="line">    params.setTraceMethod(&quot;installAsUser&quot;).setTraceCookie(System.identityHashCode(params));</span><br><span class="line">    msg.obj = params;</span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PackageHandler用于处理apk的安装请求等消息，后面分析。</p><h1 id="八、PackageHanlder"><a href="#八、PackageHanlder" class="headerlink" title="八、PackageHanlder"></a>八、PackageHanlder</h1><ul><li>PMS.installStage()会调用sendMessage将”INIT_COPY”发送给PackageHandler</li><li>PMS.installPackageAsUser调用sendMessage将”INIT_COPY”发送给PackageHandler</li></ul><p>8.1 INIT_COPY<br>PackageHandler用于处理apk的安装请求等消息，在PMS构造函数中有初始化。实际处理消息的函数为doHandleMessage，我们来看看INIT_COPY的处理流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class PackageHandler extends Handler &#123;</span><br><span class="line">    ...</span><br><span class="line">    void doHandleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case INIT_COPY: &#123;</span><br><span class="line">                //这里取出的其实就是InstallParams</span><br><span class="line">                HandlerParams params = (HandlerParams) msg.obj;</span><br><span class="line">                //idx为当前等待处理处理的安装请求的个数</span><br><span class="line">                int idx = mPendingInstalls.size();</span><br><span class="line">                ............</span><br><span class="line">                //初始时，mBound的值为false</span><br><span class="line">                if (!mBound) &#123;</span><br><span class="line">                    ............</span><br><span class="line">                    // If this is the only one pending we might</span><br><span class="line">                    // have to bind to the service again.</span><br><span class="line">                    //连接安装服务</span><br><span class="line">                    if (!connectToService()) &#123;</span><br><span class="line">                        ..................</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Once we bind to the service, the first</span><br><span class="line">                        // pending request will be processed.</span><br><span class="line">                        //绑定服务成功后，将新的请求加入到mPendingIntalls中，等待处理</span><br><span class="line">                        mPendingInstalls.add(idx, params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //如果之前已经绑定过服务，同样将新的请求加入到mPendingIntalls中，等待处理</span><br><span class="line">                    mPendingInstalls.add(idx, params);</span><br><span class="line">                    // Already bound to the service. Just make</span><br><span class="line">                    // sure we trigger off processing the first request.</span><br><span class="line">                    if (idx == 0) &#123;</span><br><span class="line">                        //如果是第一个请求，则直接发送事件MCS_BOUND，触发处理流程</span><br><span class="line">                        mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>INIT_COPY主要是将新的请求加入到mPendingIntalls中，等待MCS_BOUND阶段处理。</p><p>8.2 MCS_BOUND<br>INIT_COPY最后会发送MCS_BOUND消息触发接下来的流程，MCS_BOUND对应的处理流程同样定义于doHandleMessage中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">void doHandleMessage(Message msg) &#123;</span><br><span class="line">    .......</span><br><span class="line">    case MCS_BOUND: &#123;</span><br><span class="line">        ........</span><br><span class="line">        if (msg.obj != null) &#123;</span><br><span class="line">            mContainerService = (IMediaContainerService) msg.obj;</span><br><span class="line">            .......</span><br><span class="line">        &#125;</span><br><span class="line">        if (mContainerService == null) &#123;</span><br><span class="line">            if (!mBound) &#123;</span><br><span class="line">                // Something seriously wrong since we are not bound and we are not</span><br><span class="line">                // waiting for connection. Bail out.</span><br><span class="line">                ............            </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Waiting to connect to media container service&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        // 请求队列mPendingInstalls不为空</span><br><span class="line">        &#125; else if (mPendingInstalls.size() &gt; 0) &#123;</span><br><span class="line">            HandlerParams params = mPendingInstalls.get(0);</span><br><span class="line">            if (params != null) &#123;</span><br><span class="line">                ........</span><br><span class="line">                //调用参数的startCopy函数处理安装请求</span><br><span class="line">                if (params.startCopy()) &#123;</span><br><span class="line">                    ........</span><br><span class="line">                    // Delete pending install</span><br><span class="line">                    if (mPendingInstalls.size() &gt; 0) &#123;</span><br><span class="line">                        mPendingInstalls.remove(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (mPendingInstalls.size() == 0) &#123;</span><br><span class="line">                        if (mBound) &#123;</span><br><span class="line">                            ..........</span><br><span class="line">                            removeMessages(MCS_UNBIND);</span><br><span class="line">                            Message ubmsg = obtainMessage(MCS_UNBIND);</span><br><span class="line">                            // Unbind after a little delay, to avoid</span><br><span class="line">                            // continual thrashing.</span><br><span class="line">                            sendMessageDelayed(ubmsg, 10000);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // There are more pending requests in queue.</span><br><span class="line">                        // Just post MCS_BOUND message to trigger processing</span><br><span class="line">                        // of next pending install.</span><br><span class="line">                        ......</span><br><span class="line">                        mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .........</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Should never happen ideally.</span><br><span class="line">            Slog.w(TAG, &quot;Empty queue&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果mPendingInstalls不为空，调用InstallParams.startCopy函数处理安装请求。</li><li>接着如果mPendingInstalls不为空，发送MCS_BOUND继续处理下一个，直到队列为空。</li><li>如果队列为空，则等待一段时间后，发送MCS_UNBIND消息断开与安装服务的绑定。</li></ul><h1 id="九、startCopy"><a href="#九、startCopy" class="headerlink" title="九、startCopy"></a>九、startCopy</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span><br></pre></td></tr></table></figure><p>InstallParams继承HandlerParams，实际调用的是HandlerParams.startCopy:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final boolean startCopy() &#123;</span><br><span class="line">    boolean res;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);</span><br><span class="line">        if (++mRetries &gt; MAX_RETRIES) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);</span><br><span class="line">            mHandler.sendEmptyMessage(MCS_GIVE_UP);</span><br><span class="line">            handleServiceError();</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 调用handleStartCopy()处理</span><br><span class="line">            handleStartCopy();</span><br><span class="line">            Slog.i(TAG, &quot;Apk copy done&quot;);</span><br><span class="line">            res = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);</span><br><span class="line">        mHandler.sendEmptyMessage(MCS_RECONNECT);</span><br><span class="line">        res = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // </span><br><span class="line">    handleReturnCode();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMS将先后调用handleStartCopy和handleReturnCode来完成主要的工作。</p><p>9.1 handleStartCopy<br>handleStartCopy函数在HandleParams抽象类定义，在其子类InstallParams来实现，我们看看与实际安装相关的handleStartCopy函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ublic void handleStartCopy() throws RemoteException &#123;</span><br><span class="line">    int ret = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">    // 决定是安装在手机内还是sdcard中，设置对应标志位</span><br><span class="line">    if (origin.staged) &#123;</span><br><span class="line">        if (origin.file != null) &#123;</span><br><span class="line">            installFlags |= PackageManager.INSTALL_INTERNAL;</span><br><span class="line">            installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL;</span><br><span class="line">        &#125; else if (origin.cid != null) &#123;</span><br><span class="line">            installFlags |= PackageManager.INSTALL_EXTERNAL;</span><br><span class="line">            installFlags &amp;= ~PackageManager.INSTALL_INTERNAL;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Invalid stage location&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // 检查APK的安装位置是否正确</span><br><span class="line">    if (onInt &amp;&amp; onSd) &#123;</span><br><span class="line">        // Check if both bits are set.</span><br><span class="line">        Slog.w(TAG, &quot;Conflicting flags specified for installing on both internal and external&quot;);</span><br><span class="line">        ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</span><br><span class="line">    &#125; else if (onSd &amp;&amp; ephemeral) &#123;</span><br><span class="line">        Slog.w(TAG,  &quot;Conflicting flags specified for installing ephemeral on external&quot;);</span><br><span class="line">        ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // createInstallArgs用于创建一个安装参数对象</span><br><span class="line">    final InstallArgs args = createInstallArgs(this);</span><br><span class="line">    </span><br><span class="line">    if (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">        ...</span><br><span class="line">            // 调用InstallArgs的copyApk函数</span><br><span class="line">            ret = args.copyApk(mContainerService, true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRet = ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InstallParams$handleStartCopy()主要功能是获取安装位置信息以及复制apk到指定位置。抽象类InstallArgs中的copyApk负责复制APK文件，具体实现在子类FileInstallArgs和SdInstallArgs里面。</p><p>9.2 handleReturnCode<br>InstallParams$handleReturnCode()中，调用processPendingInstall方法处理安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void handleReturnCode() &#123;</span><br><span class="line">    // If mArgs is null, then MCS couldn&#x27;t be reached. When it</span><br><span class="line">    // reconnects, it will try again to install. At that point, this</span><br><span class="line">    // will succeed.</span><br><span class="line">    if (mArgs != null) &#123;</span><br><span class="line">        processPendingInstall(mArgs, mRet);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>9.3 processPendingInstall<br>主要的安装流程都在这个方法里面: PMS.processPendingInstall</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123;</span><br><span class="line">    mHandler.post(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            mHandler.removeCallbacks(this);</span><br><span class="line">            // Result object to be returned</span><br><span class="line">            PackageInstalledInfo res = new PackageInstalledInfo();</span><br><span class="line">            res.setReturnCode(currentStatus);</span><br><span class="line">            res.uid = -1;</span><br><span class="line">            res.pkg = null;</span><br><span class="line">            res.removedInfo = null;</span><br><span class="line">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                //1、预安装，检查包状态，确保环境ok，如果环境不ok，那么会清理拷贝的文件</span><br><span class="line">                args.doPreInstall(res.returnCode);</span><br><span class="line">                synchronized (mInstallLock) &#123;</span><br><span class="line">                    //2、安装，调用installPackageTracedLI进行安装</span><br><span class="line">                    installPackageTracedLI(args, res);</span><br><span class="line">                &#125;</span><br><span class="line">                //3、安装收尾</span><br><span class="line">                args.doPostInstall(res.returnCode, res.uid);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (!doRestore) &#123;</span><br><span class="line">                .......</span><br><span class="line">                //4、生成一个POST_INSTALL消息给PackageHanlder</span><br><span class="line">                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装过程放在一个线程里面，处理流程是预安装-安装-安装收尾-发送 POST_INSTALL消息：</p><ul><li>预安装：检查当前安装包的状态以及确保SDCARD的挂载，并返回状态信息。在安装前确保安装环境的可靠。</li><li>安装：对mInstallLock加锁，表明同时只能有一个安装包进行安装；然后调用installPackageTracedLI完成具体安装操作。</li><li>安装收尾： 检查状态，如果安装不成功，删除掉相关目录文件。</li><li>发送POST_INSTALL消息：该消息由PackageHandler接收。POST_INSTALL的主要工作其实还是通过广播、回调接口通知系统中的其它组件，有新的Pacakge安装或发生了改变。</li></ul><p>从上面我们可以知道，具体安装apk的函数是PMS.installPackageTracedLI。</p><p>十、installPackageTracedLI<br>PMS.installPackageTracedLI函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installPackage&quot;);</span><br><span class="line">        installPackageLI(args, res);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>十一、installPackageLI<br>继续PMS.installPackageLI：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private void installPackageLI(InstallArgs args, PackageInstalledInfo res) &#123;</span><br><span class="line">    </span><br><span class="line">    // PackageParser对象</span><br><span class="line">    PackageParser pp = new PackageParser();</span><br><span class="line">    pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">    pp.setDisplayMetrics(mMetrics);</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;parsePackage&quot;);</span><br><span class="line">    final PackageParser.Package pkg;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Start parsing apk: &quot; + installerPackageName);</span><br><span class="line">        // 1.开始解析我们的package</span><br><span class="line">        pkg = pp.parsePackage(tmpPackageFile, parseFlags);</span><br><span class="line">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Parsing done for apk: &quot; + installerPackageName);</span><br><span class="line">    &#125; catch (PackageParserException e) &#123;</span><br><span class="line">        res.setError(&quot;Failed parse during installPackageLI&quot;, e);</span><br><span class="line">        return;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    //2. 加载证书，获取签名信息</span><br><span class="line">    try &#123;</span><br><span class="line">        // either use what we&#x27;ve been given or parse directly from the APK</span><br><span class="line">        if (args.certificates != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                PackageParser.populateCertificates(pkg, args.certificates);</span><br><span class="line">            &#125; catch (PackageParserException e) &#123;</span><br><span class="line">                PackageParser.collectCertificates(pkg, parseFlags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            PackageParser.collectCertificates(pkg, parseFlags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PackageParserException e) &#123;</span><br><span class="line">        res.setError(&quot;Failed collect during installPackageLI&quot;, e);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    synchronized (mPackages) &#123;</span><br><span class="line">        // 3.检测packages是否存在</span><br><span class="line">        if ((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) &#123;</span><br><span class="line">                ...</span><br><span class="line">                replace = true;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (mPackages.containsKey(pkgName)) &#123;</span><br><span class="line">                ...</span><br><span class="line">                replace = true;</span><br><span class="line">                if (DEBUG_INSTALL) Slog.d(TAG, &quot;Replace existing pacakge: &quot; + pkgName);</span><br><span class="line">            &#125;</span><br><span class="line">            ...           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags,</span><br><span class="line">            &quot;installPackageLI&quot;)) &#123;</span><br><span class="line">        if (replace) &#123;</span><br><span class="line">            // 4.更新已经存在的packages</span><br><span class="line">            replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user,</span><br><span class="line">                    installerPackageName, res);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 5.安装新的packages</span><br><span class="line">            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES,</span><br><span class="line">                    args.user, installerPackageName, volumeUuid, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数过程比较长，主要做了几件事：</p><ul><li>PackageParser$parsePackage，主要是解析APK的AndroidManifest.xml，将每个标签对应的信息添加到Package的相关列表中，如将下的信息添加到Package的activities列表等。</li><li>加载apk证书，获取签名信息</li><li>检查目前安装的APK是否在系统中已存在:<ul><li>已存在，则调用replacePackageLIF进行替换安装。</li><li>不存在，否则调用installNewPackageLIF进行安装。</li></ul></li></ul><p>11.1 replacePackageLIF<br>如果需要替换的是系统APP，则调用Settings$disableSystemPackageLPw来disable旧的APK；如果替换的是非系统APP，则调用deletePackageLI删除旧的APK。</p><p>因为这个过程实在太差，没有必要贴出来一一分析，我来简化一下flow，有兴趣的读者可以深入跟进：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">replacePackageLIF</span><br><span class="line">    replaceSystemPackageLIF  // 系统 pkg</span><br><span class="line">        removePackageLI</span><br><span class="line">        disableSystemPackageLPw</span><br><span class="line">        clearAppDataLIF</span><br><span class="line">        scanPackageTracedLI  //安装apk</span><br><span class="line">            scanPackageLI</span><br><span class="line">                scanPackageDirtyLI  </span><br><span class="line">        updateSettingsLI</span><br><span class="line">        updatePermissionsLPw</span><br><span class="line">        mSettings.writeLPr();</span><br><span class="line">    replaceNonSystemPackageLIF  // 非系统 pkg</span><br><span class="line">        deletePackageLIF</span><br><span class="line">        clearAppDataLIF</span><br><span class="line">        clearAppProfilesLIF</span><br><span class="line">        scanPackageTracedLI    // 安装apk</span><br><span class="line">            scanPackageLI</span><br><span class="line">                scanPackageDirtyLI  </span><br><span class="line">        updateSettingsLI</span><br><span class="line">        updatePermissionsLPw</span><br><span class="line">        mSettings.writeLPr();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不管是更新系统还是非系统apk，都会先清除之前的packages信息，然后通过scanPackageTracedLI去安装apk，安装完后更新permissions和setting，最后通过writeLPr更新packages.xml。</p><p>关于scanPackageTracedLI和Settings.writeLPr();我有在上一篇blog讲过，可以回去看看。</p><p>11.2 installNewPackageLIF<br>PMS.installNewPackageLIF用于安装新的apk：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void installNewPackageLIF(PackageParser.Package pkg, final int policyFlags,</span><br><span class="line">            int scanFlags, UserHandle user, String installerPackageName, String volumeUuid,</span><br><span class="line">            PackageInstalledInfo res) &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installNewPackage&quot;);</span><br><span class="line">        // Remember this for later, in case we need to rollback this install</span><br><span class="line">        String pkgName = pkg.packageName;</span><br><span class="line">        if (DEBUG_INSTALL) Slog.d(TAG, &quot;installNewPackageLI: &quot; + pkg);</span><br><span class="line">        // package已经存在</span><br><span class="line">        synchronized(mPackages) &#123;</span><br><span class="line">            if (mSettings.mRenamedPackages.containsKey(pkgName)) &#123;</span><br><span class="line">                // A package with the same name is already installed, though</span><br><span class="line">                // it has been renamed to an older name.  The package we</span><br><span class="line">                // are trying to install should be installed as an update to</span><br><span class="line">                // the existing one, but that has not been requested, so bail.</span><br><span class="line">                res.setError(INSTALL_FAILED_ALREADY_EXISTS, &quot;Attempt to re-install &quot; + pkgName</span><br><span class="line">                        + &quot; without first uninstalling package running as &quot;</span><br><span class="line">                        + mSettings.mRenamedPackages.get(pkgName));</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPackages.containsKey(pkgName)) &#123;</span><br><span class="line">                // Don&#x27;t allow installation over an existing package with the same name.</span><br><span class="line">                res.setError(INSTALL_FAILED_ALREADY_EXISTS, &quot;Attempt to re-install &quot; + pkgName</span><br><span class="line">                        + &quot; without first uninstalling.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 1. 安装apk</span><br><span class="line">            PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags,</span><br><span class="line">                    System.currentTimeMillis(), user);</span><br><span class="line">            // 2. 更新setting</span><br><span class="line">            updateSettingsLI(newPackage, installerPackageName, null, res, user);</span><br><span class="line">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                prepareAppDataAfterInstallLIF(newPackage);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Remove package from internal structures, but keep around any</span><br><span class="line">                // data that might have already existed</span><br><span class="line">                deletePackageLIF(pkgName, UserHandle.ALL, false, null,</span><br><span class="line">                        PackageManager.DELETE_KEEP_DATA, res.removedInfo, true, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">            res.setError(&quot;Package couldn&#x27;t be installed in &quot; + pkg.codePath, e);</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>installNewPackageLIF会调用scanPackageTracedLI去安装apk，最终会调用scanPackageLI-&gt;scanPackageDirtyLI实际去安装apk。</p>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码(5)-ActivityManagerService启动流程</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(5)-ActivityManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(5)-ActivityManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h1><p>AMS为主线，讲述system_server进程中AMS服务的启动过程，以startBootstrapServices()方法为起点，紧跟着startCoreServices(), startOtherServices()共3个方法。</p><h1 id="二-AMS启动过程"><a href="#二-AMS启动过程" class="headerlink" title="二.AMS启动过程"></a>二.AMS启动过程</h1><p>2.1 startBootstrapServices</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    ...</span><br><span class="line">    //启动AMS服务【见小节2.2】</span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line"></span><br><span class="line">    //设置AMS的系统服务管理器</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    //设置AMS的APP安装器</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    //初始化AMS相关的PMS</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    //设置SystemServer【见小节2.3】</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2 启动AMS服务<br>SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) 功能主要：<br>    * 创建ActivityManagerService.Lifecycle对象；<br>    * 调用Lifecycle.onStart()方法。</p><p>2.1.1 AMS.Lifecycle</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static final class Lifecycle extends SystemService &#123;</span><br><span class="line">    private final ActivityManagerService mService;</span><br><span class="line"></span><br><span class="line">    public Lifecycle(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        //创建ActivityManagerService【见小节2.1.2】</span><br><span class="line">        mService = new ActivityManagerService(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        mService.start();  //【见小节2.1.3】</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ActivityManagerService getService() &#123;</span><br><span class="line">        return mService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该过程：创建AMS内部类的Lifecycle，已经创建AMS对象，并调用AMS.start();<br>2.1.2 AMS创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">    mContext = systemContext;</span><br><span class="line">    mFactoryTest = FactoryTest.getMode();//默认为FACTORY_TEST_OFF</span><br><span class="line">    mSystemThread = ActivityThread.currentActivityThread();</span><br><span class="line"></span><br><span class="line">    //创建名为&quot;ActivityManager&quot;的前台线程，并获取mHandler</span><br><span class="line">    mHandlerThread = new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line"></span><br><span class="line">    mHandler = new MainHandler(mHandlerThread.getLooper());</span><br><span class="line"></span><br><span class="line">    //通过UiThread类，创建名为&quot;android.ui&quot;的线程</span><br><span class="line">    mUiHandler = new UiHandler();</span><br><span class="line"></span><br><span class="line">    //前台广播接收器，在运行超过10s将放弃执行</span><br><span class="line">    mFgBroadcastQueue = new BroadcastQueue(this, mHandler,</span><br><span class="line">            &quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false);</span><br><span class="line">    //后台广播接收器，在运行超过60s将放弃执行</span><br><span class="line">    mBgBroadcastQueue = new BroadcastQueue(this, mHandler,</span><br><span class="line">            &quot;background&quot;, BROADCAST_BG_TIMEOUT, true);</span><br><span class="line">    mBroadcastQueues[0] = mFgBroadcastQueue;</span><br><span class="line">    mBroadcastQueues[1] = mBgBroadcastQueue;</span><br><span class="line"></span><br><span class="line">    //创建ActiveServices，其中非低内存手机mMaxStartingBackground为8</span><br><span class="line">    mServices = new ActiveServices(this);</span><br><span class="line">    mProviderMap = new ProviderMap(this);</span><br><span class="line"></span><br><span class="line">    //创建目录/data/system</span><br><span class="line">    File dataDir = Environment.getDataDirectory();</span><br><span class="line">    File systemDir = new File(dataDir, &quot;system&quot;);</span><br><span class="line">    systemDir.mkdirs();</span><br><span class="line"></span><br><span class="line">    //创建服务BatteryStatsService</span><br><span class="line">    mBatteryStatsService = new BatteryStatsService(systemDir, mHandler);</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    //创建进程统计服务，信息保存在目录/data/system/procstats，</span><br><span class="line">    mProcessStats = new ProcessStatsService(this, new File(systemDir, &quot;procstats&quot;));</span><br><span class="line"></span><br><span class="line">    mAppOpsService = new AppOpsService(new File(systemDir, &quot;appops.xml&quot;), mHandler);</span><br><span class="line">    mGrantFile = new AtomicFile(new File(systemDir, &quot;urigrants.xml&quot;));</span><br><span class="line"></span><br><span class="line">    // User 0是第一个，也是唯一的一个开机过程中运行的用户</span><br><span class="line">    mStartedUsers.put(UserHandle.USER_OWNER, new UserState(UserHandle.OWNER, true));</span><br><span class="line">    mUserLru.add(UserHandle.USER_OWNER);</span><br><span class="line">    updateStartedUserArrayLocked();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    //CPU使用情况的追踪器执行初始化</span><br><span class="line">    mProcessCpuTracker.init();</span><br><span class="line">    ...</span><br><span class="line">    mRecentTasks = new RecentTasks(this);</span><br><span class="line">    // 创建ActivityStackSupervisor对象</span><br><span class="line">    mStackSupervisor = new ActivityStackSupervisor(this, mRecentTasks);</span><br><span class="line">    mTaskPersister = new TaskPersister(systemDir, mStackSupervisor, mRecentTasks);</span><br><span class="line"></span><br><span class="line">    //创建名为&quot;CpuTracker&quot;的线程</span><br><span class="line">    mProcessCpuThread = new Thread(&quot;CpuTracker&quot;) &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">              synchronized(this) &#123;</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</span><br><span class="line">                long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</span><br><span class="line">                if (nextWriteDelay &lt; nextCpuDelay) &#123;</span><br><span class="line">                    nextCpuDelay = nextWriteDelay;</span><br><span class="line">                &#125;</span><br><span class="line">                if (nextCpuDelay &gt; 0) &#123;</span><br><span class="line">                    mProcessCpuMutexFree.set(true);</span><br><span class="line">                    this.wait(nextCpuDelay);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              updateCpuStatsNow(); //更新CPU状态</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该过程共创建了3个线程，分别为”ActivityManager”，”android.ui”，”CpuTracker”。</p><p>2.1.3 AMS.start</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void start() &#123;</span><br><span class="line">    Process.removeAllProcessGroups(); //移除所有的进程组</span><br><span class="line">    mProcessCpuThread.start(); //启动CpuTracker线程</span><br><span class="line"></span><br><span class="line">    mBatteryStatsService.publish(mContext); //启动电池统计服务</span><br><span class="line">    mAppOpsService.publish(mContext);</span><br><span class="line">    //创建LocalService，并添加到LocalServices</span><br><span class="line">    LocalServices.addService(ActivityManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.3 AMS.setSystemProcess</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void setSystemProcess() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this));</span><br><span class="line">        ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this));</span><br><span class="line">        ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this));</span><br><span class="line">        if (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this));</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(&quot;permission&quot;, new PermissionController(this));</span><br><span class="line">        ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this));</span><br><span class="line">        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                &quot;android&quot;, STOCK_PM_FLAGS);</span><br><span class="line"></span><br><span class="line">        //【见小节2.3.1】</span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //创建ProcessRecord对象</span><br><span class="line">            ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);</span><br><span class="line">            app.persistent = true; //设置为persistent进程</span><br><span class="line">            app.pid = MY_PID;</span><br><span class="line">            app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">            updateLruProcessLocked(app, false, null);//维护进程lru</span><br><span class="line">            updateOomAdjLocked(); //更新adj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要工作是注册各种服务。<br>2.3.1 AT.installSystemApplicationInfo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        getSystemContext().installSystemApplicationInfo(info, classLoader);</span><br><span class="line">        mProfiler = new Profiler();    //创建用于性能统计的Profiler对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用ContextImpl的nstallSystemApplicationInfo()方法，最终调用LoadedApk的installSystemApplicationInfo，加载名为“android”的package</p><p>2.3.2 installSystemApplicationInfo </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123;</span><br><span class="line">    assert info.packageName.equals(&quot;android&quot;);</span><br><span class="line">    mApplicationInfo = info; //将包名为&quot;android&quot;的应用信息保存到mApplicationInfo</span><br><span class="line">    mClassLoader = classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.4 startOtherServices</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ...</span><br><span class="line">  //安装系统Provider 【见小节2.4.1】</span><br><span class="line">  mActivityManagerService.installSystemProviders();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  //phase480 &amp;&amp; 500</span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  //【见小节3.1】</span><br><span class="line">  mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         //phase550</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         ...</span><br><span class="line">         //phase600</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.4.1 AMS.installSystemProviders</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final void installSystemProviders() &#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        ProcessRecord app = mProcessNames.get(&quot;system&quot;, Process.SYSTEM_UID);</span><br><span class="line">        providers = generateApplicationProvidersLocked(app);</span><br><span class="line">        if (providers != null) &#123;</span><br><span class="line">            for (int i=providers.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                ProviderInfo pi = (ProviderInfo)providers.get(i);</span><br><span class="line">                //移除非系统的provider</span><br><span class="line">                if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) &#123;</span><br><span class="line">                    providers.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (providers != null) &#123;</span><br><span class="line">        //安装所有的系统provider</span><br><span class="line">        mSystemThread.installSystemProviders(providers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建核心Settings Observer，用于监控Settings的改变。</span><br><span class="line">    mCoreSettingsObserver = new CoreSettingsObserver(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS 启动服务完成，并且将SystemServer纳入AMS管理体系，接下来主要看AMS如何通讯管理activity</p><h1 id="三-createSystemContext"><a href="#三-createSystemContext" class="headerlink" title="三. createSystemContext"></a>三. createSystemContext</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void createSystemContext() &#123;</span><br><span class="line">    //调用ActivityThread的systemMain函数，其中会创建出系统对应的Context对象</span><br><span class="line">    ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line"></span><br><span class="line">    //取出上面函数创建的Context对象，保存在mSystemContext中</span><br><span class="line">    mSystemContext = activityThread.getSystemContext();</span><br><span class="line"></span><br><span class="line">    //设置系统主题</span><br><span class="line">    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动ams之前，系统调用了createSystemContext 创建了ActivityThread（app启动入口），配置了mSystemContext<br>3.1 ActivityThread &#x3D;&gt; attach</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[系统app]</span><br><span class="line">public static ActivityThread systemMain() &#123;</span><br><span class="line">    // The system process on low-memory devices do not get to use hardware</span><br><span class="line">    // accelerated drawing, since this can add too much overhead to the</span><br><span class="line">    // process.</span><br><span class="line">    if (!ActivityManager.isHighEndGfx()) &#123;</span><br><span class="line">        //虽然写着ActivityManager，但和AMS没有任何关系</span><br><span class="line">        //就是利用系统属性和配置信息进行判断</span><br><span class="line"></span><br><span class="line">        //关闭硬件渲染功能</span><br><span class="line">        ThreadedRenderer.disable(true);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ThreadedRenderer.enableForegroundTrimming();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建ActivityThread</span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    //调用attach函数，参数为true</span><br><span class="line">    thread.attach(true);</span><br><span class="line">    return thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[普通app]</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">          ...ignore some code...    </span><br><span class="line"></span><br><span class="line">      Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AsyncTask.init();</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">          ...ignore some code...    </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最总进入attach</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//此时，我们传入的参数为true，表示该ActivityThread是系统进程的ActivityThread</span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    //创建出的ActivityThread保存在类的静态变量sCurrentActivityThread</span><br><span class="line">    //AMS中的大量操作将会依赖于这个ActivityThread</span><br><span class="line">    sCurrentActivityThread = this;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line"></span><br><span class="line">    if (!system) &#123;</span><br><span class="line">        ...ignore some code...    </span><br><span class="line"></span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            final IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            try &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                // Ignore</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        //系统进程的处理流程，该情况只在SystemServer中处理</span><br><span class="line"></span><br><span class="line">        // Don&#x27;t set application object here -- if the system crashes,</span><br><span class="line">        // we can&#x27;t display an alert, we just want to die die die.</span><br><span class="line">        //设置DDMS(Dalvik Debug Monitor Service)中看到的SystemServer进程的名称为“system_process”</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;,</span><br><span class="line">                UserHandle.myUserId());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //创建ActivityThread中的重要成员：Instrumentation、Application和Context</span><br><span class="line">            mInstrumentation = new Instrumentation();</span><br><span class="line">            ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                        this, getSystemContext().mPackageInfo);</span><br><span class="line">            mInitialApplication = context.mPackageInfo.makeApplication(true, null);</span><br><span class="line">            mInitialApplication.onCreate();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate Application():&quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //以下系统进程和非系统进程均会执行</span><br><span class="line">    ................</span><br><span class="line">    //注册Configuration变化的回调通知</span><br><span class="line">    ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class="line">            //当系统配置发生变化时（例如系统语言发生变化），回调该接口</span><br><span class="line">            ...............</span><br><span class="line">        &#125;</span><br><span class="line">        .............</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">attach</span><br><span class="line">    attachApplication</span><br><span class="line">        attachApplicationLocked</span><br><span class="line">            bindApplication</span><br><span class="line">    makeApplication</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来看下bindApplication</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private class ApplicationThread extends ApplicationThreadNative &#123;</span><br><span class="line"></span><br><span class="line">  public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">                IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">                IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">                boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,</span><br><span class="line">                Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services,</span><br><span class="line">                Bundle coreSettings) &#123;</span><br><span class="line"></span><br><span class="line">                 ...ignore some code...    </span><br><span class="line"></span><br><span class="line">             AppBindData data = new AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            data.instrumentationName = instrumentationName;</span><br><span class="line">            data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">            data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">            data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">            data.debugMode = debugMode;</span><br><span class="line">            data.enableOpenGlTrace = enableOpenGlTrace;</span><br><span class="line">            data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">            data.persistent = persistent;</span><br><span class="line">            data.config = config;</span><br><span class="line">            data.compatInfo = compatInfo;</span><br><span class="line">            data.initProfilerInfo = profilerInfo;</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要关注的其实就是最后的sendMessage()，里面有函数的编号H.BIND_APPLICATION，然后这个Messge会被H这个Handler处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private class H extends Handler &#123;</span><br><span class="line"></span><br><span class="line">      ...ignore some code... </span><br><span class="line"></span><br><span class="line">     public static final int BIND_APPLICATION        = 110;</span><br><span class="line"></span><br><span class="line">    ...ignore some code... </span><br><span class="line"></span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line">          switch (msg.what) &#123;</span><br><span class="line">        ...ignore some code... </span><br><span class="line">         case BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br><span class="line">        ...ignore some code... </span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后就在下面这个方法中，完成了实例化，拨那个企鹅通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line"></span><br><span class="line"> try &#123;</span><br><span class="line"></span><br><span class="line">           ...ignore some code... </span><br><span class="line"></span><br><span class="line">            Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">            mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">           ...ignore some code... </span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; catch (Exception e) &#123;            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>data.info是一个LoadeApk对象。</p><p>LoadeApk.data.info.makeApplication()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">            Instrumentation instrumentation) &#123;</span><br><span class="line">        if (mApplication != null) &#123;</span><br><span class="line">            return mApplication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Application app = null;</span><br><span class="line"></span><br><span class="line">        String appClass = mApplicationInfo.className;</span><br><span class="line">        if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">            appClass = &quot;android.app.Application&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">            if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">                initializeJavaContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">            app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;        &#125;</span><br><span class="line">        mActivityThread.mAllApplications.add(app);</span><br><span class="line">        mApplication = app;</span><br><span class="line"></span><br><span class="line">    //传进来的是null，所以这里不会执行，onCreate在上一层执行</span><br><span class="line">        if (instrumentation != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                instrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...ignore some code... </span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        return app;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以最后还是通过Instrumentation.makeApplication()实例化的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static public Application newApplication(Class&lt;?&gt; clazz, Context context)</span><br><span class="line">            throws InstantiationException, IllegalAccessException, </span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        Application app = (Application)clazz.newInstance();</span><br><span class="line">        app.attach(context);</span><br><span class="line">        return app;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="四-从luanch-app-出发看ams"><a href="#四-从luanch-app-出发看ams" class="headerlink" title="四. 从luanch app 出发看ams"></a>四. 从luanch app 出发看ams</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Launches the intent referred by the clicked shortcut</span><br><span class="line">     */</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">          ...ignore some code...</span><br><span class="line"></span><br><span class="line">         Object tag = v.getTag();</span><br><span class="line">        if (tag instanceof ShortcutInfo) &#123;</span><br><span class="line">            // Open shortcut</span><br><span class="line">            final Intent intent = ((ShortcutInfo) tag).intent;</span><br><span class="line">            int[] pos = new int[2];</span><br><span class="line">            v.getLocationOnScreen(pos);</span><br><span class="line">            intent.setSourceBounds(new Rect(pos[0], pos[1],</span><br><span class="line">                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));</span><br><span class="line">        //开始开启Activity咯~</span><br><span class="line">            boolean success = startActivitySafely(v, intent, tag);</span><br><span class="line"></span><br><span class="line">            if (success &amp;&amp; v instanceof BubbleTextView) &#123;</span><br><span class="line">                mWaitingForResume = (BubbleTextView) v;</span><br><span class="line">                mWaitingForResume.setStayPressed(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (tag instanceof FolderInfo) &#123;</span><br><span class="line">            //如果点击的是图标文件夹，就打开文件夹</span><br><span class="line">            if (v instanceof FolderIcon) &#123;</span><br><span class="line">                FolderIcon fi = (FolderIcon) v;</span><br><span class="line">                handleFolderClick(fi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (v == mAllAppsButton) &#123;</span><br><span class="line">        ...ignore some code...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们知道桌面引用就是lancher app .当用户点击后触发onclick事件，启动startActvitySafely，也就是startActivity</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options != null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Note we want to go through this call for compatibility with</span><br><span class="line">            // applications that may have overridden the method.</span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。当startActivityForResult()调用之后，实际上还是调用了mInstrumentation.execStartActivity()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">        if (mParent == null) &#123;</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            if (ar != null) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            ...ignore some code...    </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (options != null) &#123;</span><br><span class="line">                 //当现在的Activity有父Activity的时候会调用，但是在startActivityFromChild()内部实际还是调用的mInstrumentation.execStartActivity()</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         ...ignore some code...    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是mInstrumentation.execStartActivity()的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">        IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">            ...ignore some code...</span><br><span class="line">      try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess();</span><br><span class="line">            int result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端：ActivityManagerProxy &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;Binder驱动&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; ActivityManagerService：服务器<br><img src="/img/activityManagerProxy.png" alt="ActivityManagerProxy"><br>客户端：ApplicationThread &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Binder驱动&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ApplicationThreadProxy：服务器<br><img src="/img/ApplicationThreadProxy.png" alt="ApplicationThreadProxy"></p><h1 id="五-AMS接收到客户端的请求之后，会如何开启一个Activity？"><a href="#五-AMS接收到客户端的请求之后，会如何开启一个Activity？" class="headerlink" title="五. AMS接收到客户端的请求之后，会如何开启一个Activity？"></a>五. AMS接收到客户端的请求之后，会如何开启一个Activity？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">startActivity</span><br><span class="line">    startActivityAsUser</span><br><span class="line">        startActivityMayWait</span><br><span class="line">            startActivityLocked</span><br><span class="line">                startActivityUncheckedLocked</span><br><span class="line">                    startActivityLocked</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">final void startActivityLocked(ActivityRecord r, boolean newTask,</span><br><span class="line">            boolean doResume, boolean keepCurTransition, Bundle options) &#123;</span><br><span class="line"></span><br><span class="line">        //ActivityRecord中存储的TaskRecord信息</span><br><span class="line">        TaskRecord rTask = r.task;</span><br><span class="line"></span><br><span class="line">         ...ignore some code...</span><br><span class="line"></span><br><span class="line">        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象</span><br><span class="line">     TaskRecord task = null;</span><br><span class="line">        if (!newTask) &#123;</span><br><span class="line">            boolean startIt = true;</span><br><span class="line">            for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123;</span><br><span class="line">                task = mTaskHistory.get(taskNdx);</span><br><span class="line">                if (task.getTopActivity() == null) &#123;</span><br><span class="line">                    // task中的所有Activity都结束了</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (task == r.task) &#123;</span><br><span class="line">                    // 找到了</span><br><span class="line">                    if (!startIt) &#123;</span><br><span class="line">                        task.addActivityToTop(r);</span><br><span class="line">                        r.putInHistory();</span><br><span class="line">                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,</span><br><span class="line">                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,</span><br><span class="line">                                (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,</span><br><span class="line">                                r.userId, r.info.configChanges, task.voiceSession != null,</span><br><span class="line">                                r.mLaunchTaskBehind);</span><br><span class="line">                        if (VALIDATE_TOKENS) &#123;</span><br><span class="line">                            validateAppTokensLocked();</span><br><span class="line">                        &#125;</span><br><span class="line">                        ActivityOptions.abort(options);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if (task.numFullscreen &gt; 0) &#123;</span><br><span class="line">                    startIt = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ...ignore some code...</span><br><span class="line"></span><br><span class="line">        // Place a new activity at top of stack, so it is next to interact</span><br><span class="line">        // with the user.</span><br><span class="line">        task = r.task;</span><br><span class="line">        task.addActivityToTop(r);</span><br><span class="line">        task.setFrontOfTask();</span><br><span class="line"></span><br><span class="line">        ...ignore some code...</span><br><span class="line"></span><br><span class="line">         if (doResume) &#123;</span><br><span class="line">            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,</span><br><span class="line">            Bundle targetOptions) &#123;</span><br><span class="line">        if (targetStack == null) &#123;</span><br><span class="line">            targetStack = getFocusedStack();</span><br><span class="line">        &#125;</span><br><span class="line">        // Do targetStack first.</span><br><span class="line">        boolean result = false;</span><br><span class="line">        if (isFrontStack(targetStack)) &#123;</span><br><span class="line">            result = targetStack.resumeTopActivityLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">          ...ignore some code...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123;</span><br><span class="line">        if (inResumeTopActivity) &#123;</span><br><span class="line">            // Don&#x27;t even start recursing.</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean result = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Protect against recursion.</span><br><span class="line">            inResumeTopActivity = true;</span><br><span class="line">            result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            inResumeTopActivity = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123;</span><br><span class="line"></span><br><span class="line">          ...ignore some code...</span><br><span class="line">      //找出还没结束的首个ActivityRecord</span><br><span class="line">     ActivityRecord next = topRunningActivityLocked(null);</span><br><span class="line"></span><br><span class="line">    //如果一个没结束的Activity都没有，就开启Launcher程序</span><br><span class="line">    if (next == null) &#123;</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: No more activities go home&quot;);</span><br><span class="line">            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            // Only resume home if on home display</span><br><span class="line">            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?</span><br><span class="line">                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();</span><br><span class="line">            return isOnHomeDisplay() &amp;&amp;</span><br><span class="line">                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态</span><br><span class="line">          if (mResumedActivity != null) &#123;</span><br><span class="line">            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming,</span><br><span class="line">            boolean dontWait) &#123;</span><br><span class="line">        if (mPausingActivity != null) &#123;</span><br><span class="line">            completePauseLocked(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ...ignore some code...    </span><br><span class="line"></span><br><span class="line">        if (prev.app != null &amp;&amp; prev.app.thread != null) </span><br><span class="line">          try &#123;</span><br><span class="line">                mService.updateUsageStats(prev, false);</span><br><span class="line">                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                        userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                mPausingActivity = null;</span><br><span class="line">                mLastPausedActivity = null;</span><br><span class="line">                mLastNoHistoryActivity = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mPausingActivity = null;</span><br><span class="line">            mLastPausedActivity = null;</span><br><span class="line">            mLastNoHistoryActivity = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ...ignore some code...  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在Lancher进程中消息传递，调用ActivityThread.handlePauseActivity()，最终调用ActivityThread.performPauseActivity()暂停指定Activity。接着通</p><p>过前面所说的Binder通信，通知AMS已经完成暂停的操作。</p><p>总结:</p><ol><li>ams启动时候启动mHandlerThread,ui,CpuTracker 线程</li><li>ams启动前还启动了 ActivityThread 。系统app attach(True),非系统app attach（False）。true代表直接通过Instrumentation makeApplication初始化引用程序。false 代表将app 通过ActivityManagerProxy 发到bind。ActivityManagerService 接受到bind信息后makeApplication初始化app(bind有认证)。最后Instrumentation.onCreate,启动app</li><li>从luanch app 出发看ams.监听桌面的图标，调用startActivity。ActivityManagerProxy startActivity,最后到startActivityLocked中暂停ActivityTask top层的activity，resume点击的app</li></ol>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码(6)-Android消息机制</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(6)-Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(6)-Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>本文介绍Android的消息机制。</p><p>一、引言<br>假设现在我们有这样的需求，点一下图中的button，然后去获取一些数据（假设这个步骤是一个耗时的操作），然后获取完后将得到的数据返回显示到屏幕上。<br>为了避免产生ANR(Application Not Response)问题，通常我们会在新的线程去做耗时的操作，然后在UI线程里面更新组件，所以Handler就是类似这样子一个机制。</p><p><img src="/img/android-looper-handler-message-01.png" alt="1"></p><p>那么我们会怎么去实现呢？可以参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class TestDriverActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv = (TextView)findViewById(R.id.tv);</span><br><span class="line">        btn = (Button)findViewById(R.id.btn);</span><br><span class="line">        // 接收并处理消息</span><br><span class="line">        mHandler = new Handler()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg)&#123;</span><br><span class="line">                if (message.what == 0x11)&#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), &quot;mHandler handleMessage&quot; );</span><br><span class="line">                    tv.setText(&quot;mHandler is receive message&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 监听</span><br><span class="line">        btn.setOnClickListener(new View.onClickListener()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v)&#123;</span><br><span class="line">                MyThread t = new MyThread(mHandler);</span><br><span class="line">                t.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">    Handler handler;</span><br><span class="line">    public MyThread(Handler handler) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        super.run();</span><br><span class="line">        mHandler.sendEmptyMessage(0x11);  //发送消息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是一种实现的方式，如果在子线程而不是ui线程去初始化handler，则需要初始化handler前调用Looper.prepare()，初始化结束后调用Looper.loop()。</p><p>二、相关概念<br>学习Android的消息处理机制，有几个概念（类）必须了解：</p><ol><li>Message<br>消息，理解为线程间通讯的数据单元。例如后台线程在处理数据完毕后需要更新UI，则可发送一条包含更新信息的Message给UI线程。</li><li>Message Queue<br>消息队列，用来存放通过Handler发布的消息，按照先进先出执行。</li><li>Handler<br>Handler是Message的主要处理者，负责将Message添加到消息队列以及对消息队列中的Message进行处理。</li><li>Looper<br>循环器，扮演Message Queue和Handler之间桥梁的角色，循环取出Message Queue里面的Message，并交付给相应的Handler进行处理。<br>Thread<br>5.UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。<br>每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。<br>三、Looper<br>Looper被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程。使用Looper类创建Looper线程很简单：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class LooperThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 将当前线程初始化为Looper线程</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        </span><br><span class="line">        // ...其他处理，如实例化handler</span><br><span class="line">        </span><br><span class="line">        // 开始循环处理消息队列</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.1 Looper.prepare()<br>当执行了Looper.prepare()后，当前线程就会升级为Looper线程：</p><p><img src="/img/android-looper-prepare.png" alt="2"></p><p>一个Thread只能有一个Looper对象<br>线程中有一个Looper对象，它的内部维护了一个消息队列MessageQueue<br>3.2 Looper.loop()<br>当调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MQ中取出队头的消息(也叫任务)执行。</p><p><img src="/img/android-looper-loop.png" alt="3"></p><p>那么，我们如何往MQ上添加消息呢？下面有请Handler</p><p>四、Handler<br>Handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即往MQ上添加消息的时候执行sendMessage，并在loop到自己的时候处理消息执行handleMessage，整个过程是异步的。</p><p>Handler创建时会关联一个looper，默认关联当前线程的looper。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LooperThread extends Thread &#123;</span><br><span class="line">    private Handler handler1;</span><br><span class="line">    private Handler handler2;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 将当前线程初始化为Looper线程</span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        // 实例化两个handler</span><br><span class="line">        handler1 = new Handler(); </span><br><span class="line">        handler2 = new Handler();</span><br><span class="line"></span><br><span class="line">        // 开始循环处理消息队列</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入Handler后结构图如下：</p><p><img src="/img/android-looper-handler-2.png" alt="4"></p><p>一个线程可以有多个Handler，但是只能有一个Looper。</p><p>4.1 Handler发送消息和处理消息<br>大致流程：</p><p>mHandler.sendMessage()发送消息到MQ<br>Looper.loop()将message不断从MQ从取出来交给handler处理<br>mHandler.handleMessage()处理消息</p><p><img src="/img/android-handler-send-handle-msg.png" alt="5"></p><p>五、回顾<br>那么回到一开始我们举的例子，在非UI线程去做耗时的操作，然后完成后在UI线程更新UI信息。那么这种case下，我们的结构图是这样的：</p><p><img src="/img/android-ui-thread-handler.png" alt="6"></p><p>至此，本文介绍的内容已经完成，本文内容大部分非原创，更多的是基于其他博客的和自己理解的总结，好记性不如烂笔头。如果需要了解源码的同学，可以继续深入阅读研究，包括Java层Looper，Handler，Message，MessageQueue的源码和Native层Looper，NativeMessageQueue的源码实现。</p>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码(7)-Android系统build阶段签名机制</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(7)-Android%E7%B3%BB%E7%BB%9Fbuild%E9%98%B6%E6%AE%B5%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(7)-Android%E7%B3%BB%E7%BB%9Fbuild%E9%98%B6%E6%AE%B5%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>本文介绍Android系统build阶段的签名机制。</p><h1 id="一、系统build阶段签名机制"><a href="#一、系统build阶段签名机制" class="headerlink" title="一、系统build阶段签名机制"></a>一、系统build阶段签名机制</h1><ol><li>系统中有4组key用于build阶段对apk进行签名：</li></ol><ul><li>Media</li><li>Platform</li><li>Shared</li><li>Testkey</li></ul><p>default key是放在Android源码的&#x2F;build&#x2F;target&#x2F;product&#x2F;security目录下:</p><ul><li>media.pk8与media.x509.pem；</li><li>platform.pk8与platform.x509.pem；</li><li>shared.pk8与shared.x509.pem；</li><li>testkey.pk8与testkey.x509.pem；<br>其中，*.pk8文件为私钥，*.x509.pem文件为公钥，这需要去了解非对称加密方式。</li></ul><ol start="2"><li>在apk的android.mk文件中会指定LOCAL_CERTIFICATE 变量：</li></ol><p>LOCAL_CERTIFICATE可设置的值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CERTIFICATE := testkey   # 普通APK，默认情况下使用</span><br><span class="line">LOCAL_CERTIFICATE := platform  # 该APK完成一些系统的核心功能,这种方式编译出来的APK所在进程的UID为system</span><br><span class="line">LOCAL_CERTIFICATE := shared    # 该APK是media/download系统中的一环</span><br><span class="line">LOCAL_CERTIFICATE := media     # 该APK是media/download系统中的一环</span><br><span class="line">如果不指定，默认使用testkey。</span><br></pre></td></tr></table></figure><p>对应的，除了在Android.mk指定上述的值，还需要在APK源码的AndroidManifest.xml文件的manifest节点里面申明权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:sharedUserId=&quot;android.uid.system&quot;</span><br><span class="line">android:sharedUserId=&quot;android.uid.shared&quot;</span><br><span class="line">android:sharedUserId=&quot;android.media&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>Build规则是Build&#x2F;core&#x2F;prebuilt.mk。</li><li>在build&#x2F;core&#x2F;config.mk中，DEFAULT_SYSTEM_DEV_CERTIFICATE可以通过PRODUCT_DEFAULT_DEV_CERTIFICATE去指定各家厂商的key path。</li></ol><p>我们可以看到，默认为build&#x2F;target&#x2F;product&#x2F;security&#x2F;testkey。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># The default key if not set as LOCAL_CERTIFICATE</span><br><span class="line">ifdef PRODUCT_DEFAULT_DEV_CERTIFICATE</span><br><span class="line">  DEFAULT_SYSTEM_DEV_CERTIFICATE := $(PRODUCT_DEFAULT_DEV_CERTIFICATE)</span><br><span class="line">else</span><br><span class="line">  DEFAULT_SYSTEM_DEV_CERTIFICATE := build/target/product/security/testkey</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h1 id="二、自定义系统签名的key"><a href="#二、自定义系统签名的key" class="headerlink" title="二、自定义系统签名的key"></a>二、自定义系统签名的key</h1><p>上面介绍了系统有默认四组key，那么如果我们要制作自己的key，需要怎么做呢？<br>在build&#x2F;target&#x2F;product&#x2F;security&#x2F;目录下有一个README，里面有说明怎么制作这些key并且使用。</p><ol><li>进入Development&#x2F;tools&#x2F; 目录</li></ol><p><img src="/img/cd-dev-tool.png" alt="2"></p><ol start="2"><li>使用make_key工具生成签名文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh make_key releasekey  &#x27;/C=CN/ST=Guangdong/L=Shenzhen/O=Mediatek/OU=MTK/CN=fzll/emailAddress=maoao530@foxmail.com&#x27;</span><br></pre></td></tr></table></figure>其中：</li></ol><p>C : Country Name (2 letter code)<br>ST : State or Province Name (full name)<br>L : Locality Name (eg, city)<br>O : Organization Name (eg, company)<br>OU : Organizational Unit Name (eg, section)<br>CN : Common Name (eg, your name or your server’s hostname)<br>emailAddress : Contact email address<br>3. 用ls命令发现目录下多了两个文件：releasekey.x509.pem 和 releasekey.pk8</p><p><img src="/img/release-key.png" alt="1"></p><ol start="4"><li><p>同样的步骤生成platform &#x2F; shared &#x2F; media</p></li><li><p>用自定义的key替换build&#x2F;target&#x2F;product&#x2F;security&#x2F;目录下面的key。</p></li></ol><p>三、对APK进行系统签名<br>为了使apk有system权限，通常我们需要对其进行系统签名：</p><p>1、在应用程序的AndroidManifest.xml中的manifest节点中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:sharedUserId=&quot;android.uid.system&quot;这个属性。</span><br></pre></td></tr></table></figure><p>2、修改它的Android.mk文件，加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CERTIFICATE := platform</span><br><span class="line">重新编译，生成的apk就有修改system权限了,我们通过ps命令查看APK所在进程的UID，发现值为system。</span><br></pre></td></tr></table></figure><p>三. Android签名机制之—签名过程详解</p><ol><li>两种签名方式<ul><li>jarsigner</li><li>signapk</li></ul></li><li>签名流程机制<br>源码位置：com&#x2F;android&#x2F;signapk&#x2F;sign.java</br><br>通过上面的签名时我们可以看到，Android签名apk之后，会有一个META-INF文件夹，这里有三个文件：<br>MANIFEST.MF<br>CERT.RSA<br>CERT.SF<br>下面来看看这三个文件到底是干啥的？</li></ol><ul><li>MANIFEST.MF<br><img src="/img/WX20190714-095905@2x.png" alt="1"><br>开下源码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">【main】</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      if (args.length &lt; 4) usage();</span><br><span class="line"></span><br><span class="line">      sBouncyCastleProvider = new BouncyCastleProvider();</span><br><span class="line">      Security.addProvider(sBouncyCastleProvider);</span><br><span class="line"></span><br><span class="line">      boolean signWholeFile = false;</span><br><span class="line">      int argstart = 0;</span><br><span class="line">      if (args[0].equals(&quot;-w&quot;)) &#123;</span><br><span class="line">          signWholeFile = true;</span><br><span class="line">          argstart = 1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if ((args.length - argstart) % 2 == 1) usage();</span><br><span class="line">      int numKeys = ((args.length - argstart) / 2) - 1;</span><br><span class="line">      if (signWholeFile &amp;&amp; numKeys &gt; 1) &#123;</span><br><span class="line">          System.err.println(&quot;Only one key may be used with -w.&quot;);</span><br><span class="line">          System.exit(2);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String inputFilename = args[args.length-2];</span><br><span class="line">      String outputFilename = args[args.length-1];</span><br><span class="line"></span><br><span class="line">      JarFile inputJar = null;</span><br><span class="line">      FileOutputStream outputFile = null;</span><br><span class="line">      int hashes = 0;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          File firstPublicKeyFile = new File(args[argstart+0]);</span><br><span class="line"></span><br><span class="line">          X509Certificate[] publicKey = new X509Certificate[numKeys];</span><br><span class="line">          try &#123;</span><br><span class="line">              for (int i = 0; i &lt; numKeys; ++i) &#123;</span><br><span class="line">                  int argNum = argstart + i*2;</span><br><span class="line">                  publicKey[i] = readPublicKey(new File(args[argNum]));</span><br><span class="line">                  hashes |= getAlgorithm(publicKey[i]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">              System.err.println(e);</span><br><span class="line">              System.exit(1);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Set the ZIP file timestamp to the starting valid time</span><br><span class="line">          // of the 0th certificate plus one hour (to match what</span><br><span class="line">          // we&#x27;ve historically done).</span><br><span class="line">          long timestamp = publicKey[0].getNotBefore().getTime() + 3600L * 1000;</span><br><span class="line"></span><br><span class="line">          PrivateKey[] privateKey = new PrivateKey[numKeys];</span><br><span class="line">          for (int i = 0; i &lt; numKeys; ++i) &#123;</span><br><span class="line">              int argNum = argstart + i*2 + 1;</span><br><span class="line">              privateKey[i] = readPrivateKey(new File(args[argNum]));</span><br><span class="line">          &#125;</span><br><span class="line">          inputJar = new JarFile(new File(inputFilename), false);  // Don&#x27;t verify.</span><br><span class="line"></span><br><span class="line">          outputFile = new FileOutputStream(outputFilename);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          if (signWholeFile) &#123;</span><br><span class="line">              SignApk.signWholeFile(inputJar, firstPublicKeyFile,</span><br><span class="line">                                    publicKey[0], privateKey[0], outputFile);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              JarOutputStream outputJar = new JarOutputStream(outputFile);</span><br><span class="line"></span><br><span class="line">              // For signing .apks, use the maximum compression to make</span><br><span class="line">              // them as small as possible (since they live forever on</span><br><span class="line">              // the system partition).  For OTA packages, use the</span><br><span class="line">              // default compression level, which is much much faster</span><br><span class="line">              // and produces output that is only a tiny bit larger</span><br><span class="line">              // (~0.1% on full OTA packages I tested).</span><br><span class="line">              outputJar.setLevel(9);</span><br><span class="line"></span><br><span class="line">              Manifest manifest = addDigestsToManifest(inputJar, hashes);</span><br><span class="line">              copyFiles(manifest, inputJar, outputJar, timestamp);</span><br><span class="line">              signFile(manifest, inputJar, publicKey, privateKey, outputJar);</span><br><span class="line">              outputJar.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          System.exit(1);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              if (inputJar != null) inputJar.close();</span><br><span class="line">              if (outputFile != null) outputFile.close();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">              System.exit(1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">【signWholeFile中调用 signFile】</span><br><span class="line">private static void signFile(Manifest manifest, JarFile inputJar,</span><br><span class="line">                            X509Certificate[] publicKey, PrivateKey[] privateKey,</span><br><span class="line">                            JarOutputStream outputJar)</span><br><span class="line">   throws Exception &#123;</span><br><span class="line">   // Assume the certificate is valid for at least an hour.</span><br><span class="line">   long timestamp = publicKey[0].getNotBefore().getTime() + 3600L * 1000;</span><br><span class="line"></span><br><span class="line">   // MANIFEST.MF</span><br><span class="line">   JarEntry je = new JarEntry(JarFile.MANIFEST_NAME);</span><br><span class="line">   je.setTime(timestamp);</span><br><span class="line">   outputJar.putNextEntry(je);</span><br><span class="line">   manifest.write(outputJar);</span><br><span class="line"></span><br><span class="line">   int numKeys = publicKey.length;</span><br><span class="line">   for (int k = 0; k &lt; numKeys; ++k) &#123;</span><br><span class="line">       // CERT.SF / CERT#.SF</span><br><span class="line">       je = new JarEntry(numKeys == 1 ? CERT_SF_NAME :</span><br><span class="line">                         (String.format(CERT_SF_MULTI_NAME, k)));</span><br><span class="line">       je.setTime(timestamp);</span><br><span class="line">       outputJar.putNextEntry(je);</span><br><span class="line">       ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">       writeSignatureFile(manifest, baos, getAlgorithm(publicKey[k]));</span><br><span class="line">       byte[] signedData = baos.toByteArray();</span><br><span class="line">       outputJar.write(signedData);</span><br><span class="line"></span><br><span class="line">       // CERT.RSA / CERT#.RSA</span><br><span class="line">       je = new JarEntry(numKeys == 1 ? CERT_RSA_NAME :</span><br><span class="line">                         (String.format(CERT_RSA_MULTI_NAME, k)));</span><br><span class="line">       je.setTime(timestamp);</span><br><span class="line">       outputJar.putNextEntry(je);</span><br><span class="line">       writeSignatureBlock(new CMSProcessableByteArray(signedData),</span><br><span class="line">                           publicKey[k], privateKey[k], outputJar);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">【main函数中 addDigestsToManifest】</span><br><span class="line">/**</span><br><span class="line"> * Add the hash(es) of every file to the manifest, creating it if</span><br><span class="line"> * necessary.</span><br><span class="line"> */</span><br><span class="line">private static Manifest addDigestsToManifest(JarFile jar, int hashes)</span><br><span class="line">    throws IOException, GeneralSecurityException &#123;</span><br><span class="line">    Manifest input = jar.getManifest();</span><br><span class="line">    Manifest output = new Manifest();</span><br><span class="line">    Attributes main = output.getMainAttributes();</span><br><span class="line">    if (input != null) &#123;</span><br><span class="line">        main.putAll(input.getMainAttributes());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        main.putValue(&quot;Manifest-Version&quot;, &quot;1.0&quot;);</span><br><span class="line">        main.putValue(&quot;Created-By&quot;, &quot;1.0 (Android SignApk)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageDigest md_sha1 = null;</span><br><span class="line">    MessageDigest md_sha256 = null;</span><br><span class="line">    if ((hashes &amp; USE_SHA1) != 0) &#123;</span><br><span class="line">        md_sha1 = MessageDigest.getInstance(&quot;SHA1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((hashes &amp; USE_SHA256) != 0) &#123;</span><br><span class="line">        md_sha256 = MessageDigest.getInstance(&quot;SHA256&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    byte[] buffer = new byte[4096];</span><br><span class="line">    int num;</span><br><span class="line"></span><br><span class="line">    // We sort the input entries by name, and add them to the</span><br><span class="line">    // output manifest in sorted order.  We expect that the output</span><br><span class="line">    // map will be deterministic.</span><br><span class="line"></span><br><span class="line">    TreeMap&lt;String, JarEntry&gt; byName = new TreeMap&lt;String, JarEntry&gt;();</span><br><span class="line"></span><br><span class="line">    for (Enumeration&lt;JarEntry&gt; e = jar.entries(); e.hasMoreElements(); ) &#123;</span><br><span class="line">        JarEntry entry = e.nextElement();</span><br><span class="line">        byName.put(entry.getName(), entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (JarEntry entry: byName.values()) &#123;</span><br><span class="line">        String name = entry.getName();</span><br><span class="line">        if (!entry.isDirectory() &amp;&amp;</span><br><span class="line">            (stripPattern == null || !stripPattern.matcher(name).matches())) &#123;</span><br><span class="line">            InputStream data = jar.getInputStream(entry);</span><br><span class="line">            while ((num = data.read(buffer)) &gt; 0) &#123;</span><br><span class="line">                if (md_sha1 != null) md_sha1.update(buffer, 0, num);</span><br><span class="line">                if (md_sha256 != null) md_sha256.update(buffer, 0, num);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Attributes attr = null;</span><br><span class="line">            if (input != null) attr = input.getAttributes(name);</span><br><span class="line">            attr = attr != null ? new Attributes(attr) : new Attributes();</span><br><span class="line">            if (md_sha1 != null) &#123;</span><br><span class="line">                attr.putValue(&quot;SHA1-Digest&quot;,</span><br><span class="line">                              new String(Base64.encode(md_sha1.digest()), &quot;ASCII&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            if (md_sha256 != null) &#123;</span><br><span class="line">                attr.putValue(&quot;SHA-256-Digest&quot;,</span><br><span class="line">                              new String(Base64.encode(md_sha256.digest()), &quot;ASCII&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            output.getEntries().put(name, attr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>总结：生成三个文件 MANIFEST.MF，CERT.SF，CERT.RSA</li></ul><ol><li><p>&#x2F;&#x2F; MANIFEST.MF<br>JarEntry je &#x3D; new JarEntry(JarFile.MANIFEST_NAME);<br>je.setTime(timestamp);<br>outputJar.putNextEntry(je);<br>manifest.write(outputJar);</br><br>除了三个文件(MANIFEST.MF,CERT.RSA,CERT.SF)，其他的文件都会对文件内容做一次SHA1算法，就是计算出文件的摘要信息,然后用Base64进行编码即可，保存到MANIFEST.MF</p></li><li><p>&#x2F;&#x2F; CERT.SF &#x2F; CERT#.SF<br>je &#x3D; new JarEntry(numKeys &#x3D;&#x3D; 1 ? CERT_SF_NAME :<br>          (String.format(CERT_SF_MULTI_NAME, k)));</p></li></ol><p>je.setTime(timestamp);<br>outputJar.putNextEntry(je);<br>ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();<br>writeSignatureFile(manifest, baos, getAlgorithm(publicKey[k]));<br>byte[] signedData &#x3D; baos.toByteArray();<br>outputJar.write(signedData);</br><br>1》计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下</br><br>2》逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest“</p><ol start="3"><li>&#x2F;&#x2F; CERT.RSA &#x2F; CERT#.RSA<br>je &#x3D; new JarEntry(numKeys &#x3D;&#x3D; 1 ? CERT_RSA_NAME :<br> (String.format(CERT_RSA_MULTI_NAME, k)));<br>je.setTime(timestamp);<br>outputJar.putNextEntry(je);<br>writeSignatureBlock(new CMSProcessableByteArray(signedData),<br>publicKey[k], privateKey[k], outputJar);</br><br>我们看到，这里会把之前生成的 CERT.SF文件， 用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。CERT.RSA是一个满足PKCS7格式的文件。</li></ol><h1 id="四-画个图表示"><a href="#四-画个图表示" class="headerlink" title="四. 画个图表示"></a>四. 画个图表示</h1><p><img src="/img/signapk.png" alt="signapk"></p>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码(8)-Binder理解篇</title>
      <link href="/2025/05/18/Android-%E6%BA%90%E7%A0%81(8)-Binder%E8%A1%A5%E5%85%85/"/>
      <url>/2025/05/18/Android-%E6%BA%90%E7%A0%81(8)-Binder%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搬砖</p></blockquote><h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><h2 id="1-理解”上下文”"><a href="#1-理解”上下文”" class="headerlink" title="1. 理解”上下文”"></a>1. 理解”上下文”</h2><h3 id="system-server"><a href="#system-server" class="headerlink" title="system_server"></a>system_server</h3><pre><code>* zygote fork 出来的一个进程。</code></pre><h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><pre><code>* 在system_server进程中new的对象* 核心作用 ServiceManager.addService -&gt; ServiceManagerProxy.addService -&gt; IServiceManager.stub.asInterface(binder).addService* 上面的binder = this.getNativeServiceManager()，跟踪代码 -&gt; ProcessState::self()-&gt;getContextObject(nullptr);。找到了 hander = 0 的，第一个使用 /dev/binder 的Ibinder对象. * 跟踪 hander=0 的第一个binder 。原来是servicemanager进程（frameworks/native/cmds/servicemanager/main.cpp）将servicemanager.CPP 先是通过 manager-&gt;addService(&quot;manager&quot; 添加到内存map中，方便其他其地方获取service，然后通过 IPCThreadState::self()-&gt;setTheContextObject(manager); 将这个进程标记为 “上下文管理器”（context manager）</code></pre><h3 id="ContextManager"><a href="#ContextManager" class="headerlink" title="ContextManager"></a>ContextManager</h3><pre><code>* 调用 ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj); </code></pre><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><pre><code>* aidl 文件自动编译生成java类；* IServiceManager.stub.asInterface() 更具所在进程判断是否返回 remote（是一个proxy）* virtual BpBinder* remoteBinder();* proxy 会装箱拆箱，执行mRemote.transact远端调用 -&gt; BpBinder::transact -&gt; ioctl -&gt; binder_ioctl （内核）-&gt; copy_from_user -&gt; 查找进程，唤醒线程 -&gt; void IPCThreadState::joinThreadPool(bool isMain) 循环读取执行回调 -&gt; onTransact -&gt; BBinder.onTransact -&gt; remote</code></pre><h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><pre><code>* virtual BBinder*        localBinder();</code></pre>]]></content>
      
      
      <categories>
          
          <category> code-Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码刷机-环境搭建（ubuntu 14.04.5 编译Android 4.4.4 r1源码）</title>
      <link href="/2025/05/18/Android-%E7%BC%96%E8%AF%91-%E6%BA%90%E7%A0%81%E5%88%B7%E6%9C%BA/"/>
      <url>/2025/05/18/Android-%E7%BC%96%E8%AF%91-%E6%BA%90%E7%A0%81%E5%88%B7%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Android刷机步骤"><a href="#Android刷机步骤" class="headerlink" title="Android刷机步骤"></a>Android刷机步骤</h1><ol><li>jdk安装</li><li>ubuntu环境配置</li><li>android源码下载</li><li>驱动下载</li><li>编译</li><li>刷入手机</li><li>源码阅读</li></ol><h3 id="一·JDK安装"><a href="#一·JDK安装" class="headerlink" title="一·JDK安装"></a>一·JDK安装</h3><p>编译Android4.x的源码是不能用OpenJDK，需要用Oracle JDK 1.6，Oracle JDK 1.7目前是不支持的；编译Android 5.x版本以后的源码不再能使用Oracle JDK，需要使用OpenJDK 7版本。从下载页 <a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html#jdk-6u45-oth-JPR">http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html#jdk-6u45-oth-JPR</a><br>下载Linux x64bit版本Oracle JDK 1.60_45.</p><ol><li>解压<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/androidcode/AndroidDevlop</span><br><span class="line">sudo chmod u+x jdk-6u45-linux-x64.bin</span><br><span class="line">sudo ./jdk-6u45-linux-x64.bin</span><br></pre></td></tr></table></figure></li><li>环境变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br><span class="line"></span><br><span class="line"># 添加java环境变量</span><br><span class="line">export JAVA_HOME=/home/androidcode/AndroidDevlop/jdk1.6.0_45</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export PATH=$PATH:$&#123;JAVA_HOME&#125;/bin</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">javac</span><br></pre></td></tr></table></figure></li></ol><h3 id="二-ubuntu环境配置"><a href="#二-ubuntu环境配置" class="headerlink" title="二.ubuntu环境配置"></a>二.ubuntu环境配置</h3><ol><li>ssh配置 参考博客：linux免密钥登陆</li><li>编译环境配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dri:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 dpkg-dev  </span><br><span class="line"></span><br><span class="line">$ sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so</span><br><span class="line"># 注：遇到问题参考 http://www.voidcn.com/article/p-fxftmkft-bpy.html</span><br></pre></td></tr></table></figure></li><li>我遇到的安装错误<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#libcheese7</span><br><span class="line">$ sudo apt-get remove   libcheese-gtk23 libcheese7</span><br><span class="line">$ sudo apt-get install  libcheese-gtk23 libcheese7</span><br><span class="line"></span><br><span class="line">#g++</span><br><span class="line">$ sudo apt-get install g++</span><br><span class="line">$ sudo apt-get install g++-multilib</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="三-android源码下载"><a href="#三-android源码下载" class="headerlink" title="三.android源码下载"></a>三.android源码下载</h3><ol><li>安装repo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;lang&quot;</span><br><span class="line">$ git config --global user.email &quot;lang@gmail.com&quot;</span><br><span class="line"></span><br><span class="line"># 下载repo 脚本 (一个依赖python2.7 文件下载脚步。可以换网址)</span><br><span class="line">$ mkdir android</span><br><span class="line">$ cd android</span><br><span class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repo</span><br><span class="line">$ chmod a+x repo</span><br><span class="line"></span><br><span class="line"># 替换源repo脚步中的源</span><br><span class="line"># REPO_URL = &#x27;https://aosp.tuna.tsinghua.edu.cn/git-repo&#x27;</span><br></pre></td></tr></table></figure></li><li>android源码下载<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-4.4.4_r1</span><br><span class="line"></span><br><span class="line">$ repo sync</span><br></pre></td></tr></table></figure></li><li>涉及问题 repo脚步获取需要翻墙，也可以用国内源代替</li><li>也可以从百度云下载源码 <a href="http://pan.baidu.com/s/1ngsZs">http://pan.baidu.com/s/1ngsZs</a></li></ol><h3 id="四-驱动下载"><a href="#四-驱动下载" class="headerlink" title="四.驱动下载"></a>四.驱动下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在https://developers.google.com/android/drivers#hammerheadktu84p 下载对应版本驱动 这里是 KTU84P，下载文件有如下，移动到Android源码解压后运行里面 .sh 生成vendor文件夹</span><br><span class="line">1. lge-hammerhead-ktu84p-49419c39.tgz</span><br><span class="line">2. qcom-hammerhead-ktu84p-f159eadf.tgz</span><br><span class="line">3. broadcom-hammerhead-ktu84p-5a5bf60e.tgz</span><br></pre></td></tr></table></figure><h3 id="五-编译"><a href="#五-编译" class="headerlink" title="五.编译"></a>五.编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 初始化环境</span><br><span class="line">$ source build/envsetup.sh</span><br><span class="line"></span><br><span class="line"># 选择编译版本</span><br><span class="line">$ lunch 7 </span><br><span class="line"></span><br><span class="line"># 编译性能参数 8=电脑核心数*2</span><br><span class="line">$ make -j8 </span><br></pre></td></tr></table></figure><h3 id="六-刷入手机"><a href="#六-刷入手机" class="headerlink" title="六.刷入手机"></a>六.刷入手机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 连接电脑</span><br><span class="line">$ sudo adb reboot bootloader</span><br><span class="line"># 查看手机状态 如果没有，查看fastboot 权限</span><br><span class="line">$ fastboot devices </span><br><span class="line">$ fastboot -w flashall</span><br></pre></td></tr></table></figure><h3 id="七-源码阅读"><a href="#七-源码阅读" class="headerlink" title="七.源码阅读"></a>七.源码阅读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一步，这行命令的意思是编译idegen这个项目，生成idegen.jar文件。</span><br><span class="line">$ mmm development/tools/idegen/</span><br><span class="line">如果你看到了绿色的 #### make completed successfully  ####，说明这步是ok的。</span><br><span class="line">第二步，这行命令的意思是生成:android.iws, android.ipr, android.iml这个三个文件。</span><br><span class="line">$ sh ./development/tools/idegen/idegen.sh</span><br><span class="line">第三步, as 导入 android.ipr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android刷机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android脱壳系列-360加固分析</title>
      <link href="/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-360%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-360%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="二代壳-只有com-qihoo-util"><a href="#二代壳-只有com-qihoo-util" class="headerlink" title="二代壳  只有com.qihoo.util"></a>二代壳  只有com.qihoo.util</h3><p>拖360第一代壳 mmap下段过反调试 <a href="https://blog.csdn.net/jiangwei0910410003/article/details/51769447">https://blog.csdn.net/jiangwei0910410003/article/details/51769447</a></p><h3 id="第三代壳-两个包StupApp"><a href="#第三代壳-两个包StupApp" class="headerlink" title="第三代壳  两个包StupApp"></a>第三代壳  两个包StupApp</h3><p>拖360第一代壳 mmap下段过反调试 <a href="https://mp.weixin.qq.com/s/xSe2Zrv9Ev4qRaN99YmnRA">https://mp.weixin.qq.com/s/xSe2Zrv9Ev4qRaN99YmnRA</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
            <tag> so </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android脱壳系列-加固技术总结</title>
      <link href="/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
      <url>/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
            <tag> so </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android脱壳系列-梆梆加固分析</title>
      <link href="/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E6%A2%86%E6%A2%86%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E6%A2%86%E6%A2%86%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
            <tag> so </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android脱壳系列-爱加密加固分析</title>
      <link href="/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E7%88%B1%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E7%88%B1%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>给fopen fgets下段过反调试 在dvmDexFileOpenPartial dump</p><p>流程 <a href="https://www.52pojie.cn/thread-505999-1-1.html">https://www.52pojie.cn/thread-505999-1-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
            <tag> so </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android脱壳系列-百度加固分析</title>
      <link href="/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E7%99%BE%E5%BA%A6%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E7%99%BE%E5%BA%A6%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
            <tag> so </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android脱壳系列-背景</title>
      <link href="/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E8%83%8C%E6%99%AF/"/>
      <url>/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li><p>app存在的危险<br> 代码修改（广告植入，替换广告id）<br> 资源修改（界面替换广告，链接替换）<br> 破解（应用收费，内购）<br> 篡改数据（无效金币，砖石）<br> 加入恶意代码（木马，隐私，交易）<br> 动态注入，数据拦截，窃取，修改<br> 协议修改</p></li><li><p>加固目的<br> 需要防止逆向分析（防逆向）–防止核心代码被反编译<br> 控制二次打包（防篡改）– 校验完整性，签名，防止盗版<br> 防止调试和注入（防调试）–防止动态调试，注入获取关键数据<br> 防止应用数据窃取（防窃取）– 加密敏感数据<br> 防止协议直接被盗刷–加密协议通信</p></li><li><p>常用加固方式<br> 类加载技术<br> 针对apk中的classes.dex文件进行处理，放入特定的文件中，通过native代码来运行进行解密（爱加密，梆梆）<br> 方法替换技术<br> 将class.dex文件中的方法代码进行提取，抽取方法，在运行时对器进行动态解密还原</p></li><li><p>脱壳手法<br> 修改系统源码自动脱壳<br> 通过hook对关键函数进行脱壳<br> 开源工具zjdroid,dexhunter进行脱壳<br> 利用IDA或者GDB动态调试进行脱壳</p></li></ol><h3 id="壳进化"><a href="#壳进化" class="headerlink" title="壳进化"></a>壳进化</h3><ol><li><p>第一代壳 dex 加密<br> dex字符串加密<br> 资源加密<br> 对抗反调试<br> 反调试<br> 自定义dexClassLoader</p></li><li><p>第二代壳 dex抽取和so加固<br> dex代码抽取到外部<br> dex动态加载<br> so加密</p></li><li><p>第三代壳 dex动态解密和So混淆<br> dex代码动态解密<br> so代码混淆</p></li></ol><h4 id="脱壳思路"><a href="#脱壳思路" class="headerlink" title="脱壳思路"></a>脱壳思路</h4><h5 id="第一代壳"><a href="#第一代壳" class="headerlink" title="第一代壳"></a>第一代壳</h5><pre><code>1. 内存dump，内存中寻址dex.035 或dex.0362. 文件监视法    dex优化生成odex    监视文件变化（notifywait-for-Android）    监视dexOpt输出（notifywait-for-Android）3. hook法    hook dvmDexFileOpenPartial4. 定制安卓系统</code></pre><h5 id="第二代壳"><a href="#第二代壳" class="headerlink" title="第二代壳"></a>第二代壳</h5><pre><code>1. hook dexFileParse  dexFileOpenFromMD2. 定制系统    dexHunter defineClassNative    绕过3进程反调试一系列系统源码    断点mmap, dexopt优化时，dvmContinueOptimization()-&gt;mmap()</code></pre><h5 id="第三代壳-方法指令抽取"><a href="#第三代壳-方法指令抽取" class="headerlink" title="第三代壳 方法指令抽取"></a>第三代壳 方法指令抽取</h5><p>dex2oat<br>    ART模式下，dex2oat生成oat时，内存中的dex是完整的<br>定制系统<br>    hook Dalvik_dalvik_system_DexFile_defineClassNative dexHunter<br>    枚举所有DexClassDef，对所有class,调用dvmDefineClass进行强制加载</p><h5 id="第四代壳"><a href="#第四代壳" class="headerlink" title="第四代壳"></a>第四代壳</h5><p>so+vmp<br>动态调试+人肉还原</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>爱加密 脱壳点 dvmDexFileOpenPartial</p><h4 id="壳特点"><a href="#壳特点" class="headerlink" title="壳特点"></a>壳特点</h4><p>(“libsecexe.so”, “梆梆加固免费版”);<br>(“libsecmain.so”, “梆梆加固免费版”);<br>(“libSecShell.so”, “梆梆加固免费版”);<br>(“secData0.jar”, “梆梆加固免费版”);<br>(“libSecShell-x86.so”, “梆梆加固免费版”);</p><p>(“libDexHelper.so”, “梆梆企业版”);<br>(“libDexHelper-x86.so”, “梆梆企业版”);<br>(“classes.jar”, “梆梆加固定制版”);<br>(“DexHelper.so”, “梆梆加固定制版”);</p><p>(“libtup.so”, “腾讯加固”);<br>(“libshell.so”, “腾讯加固”);<br>(“mix.dex”, “腾讯加固”);<br>(“mixz.dex”, “腾讯加固”);<br>(“libshella-xxxx.so”, “腾讯加固”);<br>(“libshellx-xxxx.so”, “腾讯加固”);</p><p>(“libtosprotection.armeabi-v7a.so”, “腾讯御安全”);<br>(“libtosprotection.armeabi.so”, “腾讯御安全”);<br>(“libtosprotection.x86.so”, “腾讯御安全”);<br>(“tosversion”, “腾讯御安全”);<br>(“libTmsdk-xxx-mfr.so”, “腾讯御安全”);</p><p>(“aliprotect.dat”, “阿里加固”);<br>(“libsgmain.so”, “阿里加固”);<br>(“libsgsecuritybody.so”, “阿里加固”);<br>(“libmobisec.so”, “阿里加固”);<br>(“libfakejni.so”, “阿里加固”);<br>(“libzuma.so”, “阿里加固”);<br>(“libzumadata.so”, “阿里加固”);<br>(“libpreverify1.so”, “阿里加固”);</p><p>(“kdpdata.so”, “几维加固”);<br>(“dex.dat”, “几维加固”);<br>(“libkdp.so”, “几维加固”);<br>(“libkwscmm.so”, “几维加固”);<br>(“libkwscr.so”, “几维加固”);<br>(“libkwslinker.so”, “几维加固”);</p><p>(“libexec.so”, “爱加密”);<br>(“libexecmain.so”, “爱加密”);<br>(“ijiami.dat”, “爱加密”);<br>(“ijiami.ajm”, “爱加密”);<br>(“af.bin”, “爱加密”);<br>(“signed.bin”, “爱加密”);</p><p>(“libchaosvmp.so”, “娜迦”);<br>(“libddog.so”, “娜迦”);<br>(“libfdog.so”, “娜迦”);<br>(“libedog.so”, “娜迦”);</p><p>(“libprotectClass.so”, “360加固”);<br>(“libjiagu.so”, “360加固”);<br>(“libjiagu_art.so”, “360加固”);<br>(“libjiagu_x86.so”, “360加固”);</p><p>(“libcmvmp.so”, “中国移动安全加固”);<br>(“libmogosec_dex.so”, “中国移动安全加固”);<br>(“libmogosec_sodecrypt.so”, “中国移动安全加固”);<br>(“libmogosecurity.so”, “中国移动安全加固”);</p><p>(“libbaiduprotect.so”, “百度加固”);<br>(“baiduprotect1.jar”, “百度加固”);<br>(“baiduprotect.jar”, “百度加固”);</p><p>(“libuusafe.jar.so”, “UU安全加固”);<br>(“libuusafe.so”, “UU安全加固”);<br>(“libuusafeempty.so”, “UU安全加固”);</p><p>(“dp.arm-v7.so.dat”, “DexProtect加固”);<br>(“dp.arm.so.dat”, “DexProtect加固”);</p><p>(“libegis.so”, “通付盾加固”);<br>(“libNSaferOnly.so”, “通付盾加固”);</p><p>(“libreincp.so”, “珊瑚灵御加固”);<br>(“libreincp_x86.so”, “珊瑚灵御加固”);</p><p>(“libnqshield.so”, “网秦加固”);</p><p>(“libnesec.so”, “网易易盾”);</p><p>(“libAPKProtect.so”, “APKProtect加固”);</p><p>(“libx3g.so”, “顶象技术加固”);</p><p>(“libitsec.so”, “海云安加固”);</p><p>(“libapssec.so”, “盛大加固”);</p><p>(“librsprotect.so”, “瑞星加固”);</p><p>(“libapktoolplus_jiagu.so”, “apktoolplus加固”);</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
            <tag> so </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E8%85%BE%E8%AE%AF%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E8%85%BE%E8%AE%AF%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android脱壳系列-阿里加固分析</title>
      <link href="/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E9%98%BF%E9%87%8C%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/18/Android-%E8%84%B1%E5%A3%B3%E7%B3%BB%E5%88%97-%E9%98%BF%E9%87%8C%E5%8A%A0%E5%9B%BA%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫-Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
            <tag> so </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="/2025/05/18/Javascript-%E7%9F%A5%E8%AF%86%E7%82%B9-Ajax/"/>
      <url>/2025/05/18/Javascript-%E7%9F%A5%E8%AF%86%E7%82%B9-Ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="XmlHttpRequest"><a href="#XmlHttpRequest" class="headerlink" title="XmlHttpRequest"></a>XmlHttpRequest</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var filexmlHttpRequest = new XMLHttpRequest();</span><br><span class="line">var filePath = &quot;file:///data/data/com.lang.tclient/shared_prefs/account.xml&quot;;</span><br><span class="line">filexmlHttpRequest.onreadystatechange = function()&#123;</span><br><span class="line">    if(filexmlHttpRequest.readyState == 4)&#123;</span><br><span class="line">        if(filexmlHttpRequest.status===200 || filexmlHttpRequest.status===0)&#123;</span><br><span class="line">            var xmlhttprequest = new XMLHttpRequest();</span><br><span class="line">            xmlhttprequest.open(&quot;POST&quot;, &quot;http://172.17.2.73:8080/tserver_war_exploded/fourbrother/cloneApp&quot;, true);</span><br><span class="line">            xmlhttprequest.onreadystatechange = function()&#123;</span><br><span class="line">                if(xmlhttprequest.readyState == 4)&#123;</span><br><span class="line">                    alert(&quot;up account data success!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            var content = filexmlHttpRequest.responseText;</span><br><span class="line">            var formData = new FormData();</span><br><span class="line">            var blob = new Blob([content], &#123;type:&quot;text/xml&quot;&#125;);</span><br><span class="line">            formData.append(&quot;file&quot;, blob);</span><br><span class="line">            xmlhttprequest.send(formData);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            alert(&quot;else-----ddd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filexmlHttpRequest.open(&quot;GET&quot;, filePath);</span><br><span class="line">filexmlHttpRequest.send(null);</span><br></pre></td></tr></table></figure><ol><li><p>var http&#x3D;new XmlHttpRequest()</p></li><li><p>http.open(param1,param2)<br> param1: POST or GET<br> param2: URL</p></li><li><p>http.onreadystatechange&#x3D;function(){}</p></li><li><p>http.readyState<br> (0)未初始化<br> 此阶段确认XMLHttpRequest对象是否创建，并为调用open()方法进行未初始化作好准备。值为0表示对象已经存在，否则浏览器会报错－－对象不存在。</p><p> (1)载入<br> 此阶段对XMLHttpRequest对象进行初始化，即调用open()方法，根据参数(method,url,true)完成对象状态的设置。并调用send()方法开始向服务端发送请求。值为1表示正在向服务端发送请求。</p><p> (2)载入完成<br> 此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为2表示已经接收完全部响应数据。并为下一阶段对数据解析作好准备。</p><p> (3)交互<br> 此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。状态3表示正在解析数据。</p><p> (4)完成<br> 此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为4表示数据解析完毕，可以通过XMLHttpRequest对象的相应属性取得数据。</p></li><li><p>http.send()<br> get: null<br> post: form表单<br> var form&#x3D;new FormData()</p></li></ol><h1 id="Ajax-hook-https-github-com-langgithub-Ajax-hook"><a href="#Ajax-hook-https-github-com-langgithub-Ajax-hook" class="headerlink" title="Ajax-hook https://github.com/langgithub/Ajax-hook"></a>Ajax-hook <a href="https://github.com/langgithub/Ajax-hook">https://github.com/langgithub/Ajax-hook</a></h1><pre><code>拦截XmlHttpRequst，窃取或修改相应参数</code></pre>]]></content>
      
      
      <categories>
          
          <category> code-javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-gcc编译</title>
      <link href="/2025/05/18/OS-Linux-gcc%E7%BC%96%E8%AF%91/"/>
      <url>/2025/05/18/OS-Linux-gcc%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-gcc编译"><a href="#Linux-gcc编译" class="headerlink" title="Linux-gcc编译"></a>Linux-gcc编译</h1><ol><li>gcc编译流程</li><li>ELF文件分类</li><li>总结</li></ol><h3 id="gcc编译流程"><a href="#gcc编译流程" class="headerlink" title="gcc编译流程"></a>gcc编译流程</h3><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/gcc%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.jpeg" alt="编译"><br>a. 头文件.h和.c源文件 通过gcc 编译成.o可重定位文件目标文件（如：gcc -c -fPIC process.c）<br>b. 可重定位文件.o 通过ar归档生成静态链接库.a文件（如：ar cr libstaticprocess.a process.o）。可执行程序编译： gcc -o staticcreateprocess createprocess.o -L. -lstaticprocess<br>c. 或者将.o文件编译成动态链接库.so文件 （如：gcc -shared -fPIC -o libdynamicprocess.so process.o）。可执行程序编译 （gcc -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess）。执行需要添加环境变量 export LD_LIBRARY_PATH&#x3D;.<br>d. 静态链接库.a 在编译过程就将函数调用情况链接。动态链接库.so在运行工作中动态链接函数</p><h3 id="ELF文件分类"><a href="#ELF文件分类" class="headerlink" title="ELF文件分类"></a>ELF文件分类</h3><p>a. 第一种.o可重定位目标文件<br>    * .text 放编译好的二进制可执行代码<br>    * .data  已经初始化好的全局变量<br>    * .rodata 只读数据，例如字符串常量、const 的变量<br>    * .bss 未初始化全局变量，运行时会置 0<br>    * .symtab 符号表，记录的则是函数和变量<br>    * .strtab 字符串表、字符串常量和变量名<br>    * .rel .text 与重定位相关<br>    * .rel .data 与重定位相关</p><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg" alt="first"></p><p>b. 第二种可执行文件 section节被分成了需要加载到内存里面的代码段、数据段和不需要加载到内存里面的部分，将小的 section 合成了大的段 segment，并且在最前面加一个段头表（Segment Header Table）。在 ELF 头里面，有一项 e_entry，也是个虚拟地址，是这个程序运行的入口。<br>c. 第三种动态链接库，也就是共享对象文件<br>    * 首先，多了一个.interp 的 Segment，这里面是 ld-linux.so，这是动态链接器，也就是说，运行时的链接动作都是它做的。<br>    * ELF 文件中还多了两个 section，一个是.plt，过程链接表（Procedure Linkage Table，PLT），一个是.got.plt，全局偏移量表（Global Offset Table，GOT）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.jpeg" alt="总结"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux免密钥登陆</title>
      <link href="/2025/05/18/OS-Linux-%E5%85%8D%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/"/>
      <url>/2025/05/18/OS-Linux-%E5%85%8D%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<p>免密钥登陆</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="生成了私钥-id-dsa-和公钥-id-dsa-pub"><a href="#生成了私钥-id-dsa-和公钥-id-dsa-pub" class="headerlink" title="生成了私钥 id_dsa 和公钥 id_dsa.pub"></a>生成了私钥 id_dsa 和公钥 id_dsa.pub</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install openssh-server</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><h3 id="将该密钥用作认证-进行访问授权"><a href="#将该密钥用作认证-进行访问授权" class="headerlink" title="将该密钥用作认证,进行访问授权"></a>将该密钥用作认证,进行访问授权</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 辅助工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux压缩工具命令行</title>
      <link href="/2025/05/18/OS-Linux-%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/2025/05/18/OS-Linux-%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>linux压缩工具命令行</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="7z"><a href="#7z" class="headerlink" title="7z"></a>7z</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install p7zip</span><br><span class="line">$ brew install p7zip (mac)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ 7z x manager.7z -r -o /home/xx  这里大家要注意-o后是没有空格的直接接目录</span><br><span class="line"># x 代表解压缩文件，并且是按原始目录解压（还有个参数 e 也是解压缩文件，但其会将所有文件都解压到根下，而不是自己原有的文件夹下）manager.7z 是压缩文件，这里大家要换成自己的。如果不在当前目录下要带上完整的目录</span><br><span class="line"># -r 表示递归所有的子文件夹</span><br><span class="line"># -o 是指定解压到的目录，这里大家要注意-o后是没有空格的直接接目录</span><br><span class="line"></span><br><span class="line">$ 7z a -t7z -r manager.7z /home/manager/*</span><br><span class="line"># a 代表添加文件／文件夹到压缩包</span><br><span class="line"># -t 是指定压缩类型 一般我们定为7z</span><br><span class="line"># -r 表示递归所有的子文件夹，manager.7z 是压缩好后的压缩包名，/home/manager/* 是要压缩的目录，＊是表示该目录下所有的文件。</span><br></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩</span></span><br><span class="line">$ zip -r filename.zip file1 file2 file3 /usr/work/school </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">unzip filename.zip</span><br></pre></td></tr></table></figure><h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩</span></span><br><span class="line">$ rar a fileName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">$ rar x fileName</span><br></pre></td></tr></table></figure><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ol><li>c-创建-create</li><li>v-复杂输出</li><li>f-文件-file</li><li>x-解压-extract</li><li>z-gz格式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 解压jdk到指定文件夹：</span><br><span class="line">$ tar -xzvf jdk-8u131-linux-x64.tar.gz -C /usr/local/java</span><br><span class="line"></span><br><span class="line"># 正常打包</span><br><span class="line">$ tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg </span><br><span class="line"></span><br><span class="line"># 压缩打包</span><br><span class="line">$ tar -czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 辅助工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 7z </tag>
            
            <tag> tar </tag>
            
            <tag> zip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux操作系统</title>
      <link href="/2025/05/18/OS-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/05/18/OS-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><ol><li>MBR分区<br> 存放开机记录和分区表，分区表64bytes最多存储4个分区，这4个分区为主分区和扩展分区。逻辑分区从5开始</li><li>GPT分区<br> GPT 没有扩展分区概念</li></ol><h1 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h1><ol><li><p>ls 查看信息<br> drwxr-xr-x 3 root root 17 May 6 00:14 .config，对这个信息的解释如下：</p><p> drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段<br> 3：链接数<br> root：文件拥有者<br> root：所属群组<br> 17：文件大小<br> May 6 00:14：文件最后被修改的时间<br> .config：文件名<br> 常见的文件类型及其含义有：</p><p> d：目录<br> -：文件<br> l：链接文件<br> 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p><p> 文件时间有以下三种：</p><p> modification time (mtime)：文件的内容更新就会更新；<br> status time (ctime)：文件的状态（权限、属性）更新就会更新；<br> access time (atime)：读取文件时就会更新。</p></li><li><p>cd<br> 更换当前目录。</p><p> cd [相对路径或绝对路径]</p></li><li><p>mkdir<br> 创建目录。<br> mkdir [-mp] 目录名称<br> -m ：配置目录权限<br> -p ：递归创建目录</p></li><li><p>rmdir<br> 删除目录，目录必须为空。</p><p> rmdir [-p] 目录名称<br> -p ：递归删除目录</p></li><li><p>touch<br> 更新文件时间或者建立新文件。</p><p> touch [-acdmt] filename<br> -a ： 更新 atime<br> -c ： 更新 ctime，若该文件不存在则不建立新文件<br> -m ： 更新 mtime<br> -d ： 后面可以接更新日期而不使用当前日期，也可以使用 –date&#x3D;”日期或时间”<br> -t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</p></li><li><p>cp<br> 复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p><p> cp [-adfilprsu] source destination<br> -a ：相当于 -dr –preserve&#x3D;all<br> -d ：若来源文件为链接文件，则复制链接文件属性而非文件本身<br> -i ：若目标文件已经存在时，在覆盖前会先询问<br> -p ：连同文件的属性一起复制过去<br> -r ：递归复制<br> -u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制<br> –preserve&#x3D;all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</p></li><li><p>rm<br> 删除文件。</p><p> rm [-fir] 文件或目录<br> -r ：递归删除</p></li><li><p>mv<br> 移动文件。</p><p> mv [-fiu] source destination<br> mv [options] source1 source2 source3 …. directory<br> -f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</p></li><li><p>chmod<br> 可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p><p> chmod [-R] xyz dirname&#x2F;filename<br> 示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。</p><p> chmod 754 .bashrc<br> 也可以使用符号来设定权限。</p><p> chmod [ugoa]  [+-&#x3D;] [rwx] dirname&#x2F;filename</p><ul><li>u：拥有者</li><li>g：所属群组</li><li>o：其他人</li><li>a：所有人</li><li>+：添加权限</li><li>-：移除权限</li><li>&#x3D;：设定权限<br> 示例：为 .bashrc 文件的所有用户添加写权限。</li></ul><p> chmod a+w .bashrc</p></li><li><p>硬连接与软连接<br>10.1 实体链接<br>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p><p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p><p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p><p>$ ln &#x2F;etc&#x2F;crontab .<br>$ ll -i &#x2F;etc&#x2F;crontab crontab<br>34474855 -rw-r–r–. 2 root root 451 Jun 10 2014 crontab<br>34474855 -rw-r–r–. 2 root root 451 Jun 10 2014 &#x2F;etc&#x2F;crontab<br>10.2 符号链接<br>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p><p>当源文件被删除了，链接文件就打不开了。</p><p>因为记录的是路径，所以可以为目录建立符号链接。</p><p>$ ll -i &#x2F;etc&#x2F;crontab &#x2F;root&#x2F;crontab2<br>34474855 -rw-r–r–. 2 root root 451 Jun 10 2014 &#x2F;etc&#x2F;crontab<br>53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 &#x2F;root&#x2F;crontab2 -&gt; &#x2F;etc&#x2F;crontab</p></li><li><p>获取文件内容</p><ol><li>cat<br>取得文件内容。</li></ol><p>$ cat [-AbEnTv] filename<br>-n ：打印出行号，连同空白行也会有行号，-b 不会<br>2. tac<br>是 cat 的反向操作，从最后一行开始打印。</p><ol start="3"><li><p>more<br>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p></li><li><p>less<br>和 more 类似，但是多了一个向前翻页的功能。</p></li><li><p>head<br>取得文件前几行。</p></li></ol><p>$ head [-n number] filename<br>-n ：后面接数字，代表显示几行的意思</p><ol start="6"><li><p>tail<br>是 head 的反向操作，只是取得是后几行。</p></li><li><p>od<br>以字符或者十六进制的形式显示二进制文件。</p></li></ol></li><li><p>指令与文件搜索</p><ol><li>which<br>指令搜索。</li></ol><p>$ which [-a] command<br>-a ：将所有指令列出，而不是只列第一个<br>2. whereis<br>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p><p>$ whereis [-bmsu] dirname&#x2F;filename<br>3. locate<br>文件搜索。可以用关键字或者正则表达式进行搜索。</p><p>locate 使用 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F; 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p><p>$ locate [-ir] keyword<br>-r：正则表达式<br>4. find<br>文件搜索。可以使用文件的属性和权限进行搜索。</p><p>find [basedir] [option]<br>example: find . -name “shadow*”</p></li><li><p>压缩与打包<br>压缩文件名<br>Linux 底下有很多压缩文件名，常见的如下：</p><p>扩展名 压缩程序<br>*.Z compress<br>*.zip   zip<br>*.gz    gzip<br>*.bz2   bzip2<br>*.xz    xz<br>*.tar   tar 程序打包的数据，没有经过压缩<br>*.tar.gz    tar 程序打包的文件，经过 gzip 的压缩<br>*.tar.bz2   tar 程序打包的文件，经过 bzip2 的压缩<br>*.tar.xz    tar 程序打包的文件，经过 xz 的压缩<br>压缩指令</p><ol><li><p>gzip<br> gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p><p> 经过 gzip 压缩过，源文件就不存在了。</p><p> 有 9 个不同的压缩等级可以使用。</p><p> 可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p><p> $ gzip [-cdtv#] filename<br> -c ：将压缩的数据输出到屏幕上<br> -d ：解压缩<br> -t ：检验压缩文件是否出错<br> -v ：显示压缩比等信息<br> -# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</p></li><li><p>bzip2<br> 提供比 gzip 更高的压缩比。</p><p> 查看命令：bzcat、bzmore、bzless、bzgrep。</p><p> $ bzip2 [-cdkzv#] filename<br> -k ：保留源文件</p></li><li><p>xz<br> 提供比 bzip2 更佳的压缩比。</p><p> 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p><p> 查看命令：xzcat、xzmore、xzless、xzgrep。</p><p> $ xz [-dtlkc#] filename</p></li><li><p>tar打包<br> 压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p><p> $ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename…  &#x3D;&#x3D;打包压缩<br> $ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              &#x3D;&#x3D;查看<br> $ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    &#x3D;&#x3D;解压缩<br> -z ：使用 zip；<br> -j ：使用 bzip2；<br> -J ：使用 xz；<br> -c ：新建打包文件；<br> -t ：查看打包文件里面有哪些文件；<br> -x ：解打包或解压缩的功能；<br> -v ：在压缩&#x2F;解压缩的过程中，显示正在处理的文件名；<br> -f : filename：要处理的文件；<br> -C 目录 ： 在特定目录解压缩。<br> 使用方式    命令<br> 打包压缩    tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称<br> 查 看 tar -jtv -f filename.tar.bz2<br> 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</p></li></ol></li><li><p>Bash<br>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p><p>特性<br>命令历史：记录使用过的命令<br>命令与文件补全：快捷键：tab<br>命名别名：例如 lm 是 ls -al 的别名<br>shell scripts<br>通配符：例如 ls -l &#x2F;usr&#x2F;bin&#x2F;X* 列出 &#x2F;usr&#x2F;bin 下面所有以 X 开头的文件<br>变量操作<br>对一个变量赋值直接使用 &#x3D;。<br>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p><p>数据流重定向<br>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p><p>1   代码  运算符<br>标准输入 (stdin)    0   &lt; 或 &lt;&lt;<br>标准输出 (stdout)   1   &gt; 或 &gt;&gt;<br>标准错误输出 (stderr) 2   2&gt; 或 2&gt;&gt;<br>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p><p>可以将不需要的标准输出以及标准错误输出重定向到 &#x2F;dev&#x2F;null，相当于扔进垃圾箱。</p><p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p><p>$ find &#x2F;home -name .bashrc &gt; list 2&gt;&amp;</p></li><li><p>管道指令 (cat file | grep “regex” | wc -l)<br>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p><p>选取命令:cut.grep<br>cut -d ‘分隔字符’ -f field &#x2F;&#x2F; 用于分隔字符<br>cut -c 字符范围<br>[参数说明]<br>-d : 后面接分隔字符,通常与 -f 一起使用<br>-f : 根据-d 将信息分隔成数段，-f 后接数字 表示取出第几段<br>-c : 以字符为单位取出固定字符区间的信息<br><br><br>栗子1：<br>打印&#x2F;etc&#x2F;passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和家目录<br>[root@izuf6i29flb2df231kt91hz &#x2F;]# cat etc&#x2F;passwd | cut -d ‘:’ -f 1,6<br>root:&#x2F;root<br>bin:&#x2F;bin<br>daemon:&#x2F;sbin<br>adm:&#x2F;var&#x2F;adm<br>lp:&#x2F;var&#x2F;spool&#x2F;lpd<br><br>栗子2：<br>打印&#x2F;etc&#x2F;passwd文件中每一行的前10个字符：<br>[root@izuf6i29flb2df231kt91hz &#x2F;]# cat &#x2F;etc&#x2F;passwd | cut -c 1-10<br>root:x:0:0<br>bin:x:1:1:<br>daemon:x:2<br>adm:x:3:4:<br>lp:x:4:7:l<br>排序命令：sort,wc,uniq<br>sort [-fbMnrtuk] [file or stdin]<br>[参数]<br>-f ：忽略大小写的差异，例如A 与a 视为编码相同<br>-b ：忽略最前面的空格部分<br>-M ：以月份的名字来排序，例如JAN, DEC 等等的排序方法<br>-n ：使用『纯数字』进行排序默认是以文字型态来排序的)<br>-r ：反向排序<br>-u ：就是uniq ，相同的资料中，仅出现一行代表<br>-t ：分隔符号，预设是用[tab] 键来分隔<br>-k ：以那个区间(field) 来进行排序的意思<br><br>uniq<br>uniq [-ic]<br>[参数]<br>-i ：忽略大小写的不同<br>-c ：进行计数<br><br>wc<br>wc [-lwm]<br>[参数]<br>-l ：仅列出行<br>-w ：仅列出多少字(英文单字)<br>-m ：多少字符<br>字符转换命令：tr,col,join,paste,expand<br>切割命令：split</p></li><li><p>进程管理 (ps -aux | grep tomcat 指定进程)（netstat -apn | grep 4000）(lsof -i tcp:4000)<br>查看进程</p><ol><li>ps<br>查看某个时间点的进程信息。</li></ol><p>示例一：查看自己的进程</p><p>$ ps -l<br>示例二：查看系统所有进程</p><p>$ ps aux<br>示例三：查看特定的进程</p><p>$ ps aux | grep threadx<br>2. pstree<br>查看进程树。</p><p>示例：查看所有进程树</p><p>$ pstree -A<br>3. top<br>实时显示进程信息。</p><p>示例：两秒钟刷新一次</p><p>$ top -d 2<br>4. netstat<br>查看占用端口的进程</p><p>示例：查看特定端口的进程<br>$ netstat -anp | grep port</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-系统初始化</title>
      <link href="/2025/05/18/OS-Linux-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2025/05/18/OS-Linux-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统初始化"><a href="#Linux-系统初始化" class="headerlink" title="Linux-系统初始化"></a>Linux-系统初始化</h1><ol><li>cpu工作流程</li><li>操作系统引导</li><li>linux内核启动</li></ol><h3 id="cpu工作流程"><a href="#cpu工作流程" class="headerlink" title="cpu工作流程"></a>cpu工作流程</h3><p>图一<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/cpu%E8%BF%90%E7%AE%97%E6%B5%81%E7%A8%8B.jpeg" alt="图一"></p><p>a. cpu 包含运算单元，控制单元，数据单元（控制单元如将数据单元中的代码，数据加载到运算单元运算）</p><p>图二<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/cpu%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%94%A8%E4%BA%86%E6%B6%89%E5%8F%8A%E5%AF%84%E5%AD%98%E5%99%A8.jpeg" alt="图二"></p><p>a. 8086架构cpu中有8个16位寄存器用于存放临时数据。通用寄存器（AX,BX,CX,DX）,指针变址寄存器（SP，BP，SI，DI）<br>b. cpu中的控制单元有ip指令指针寄存器，将指令加载到指令队列交给运算单元计算<br>c. cs代码段寄存器，DS数据段寄存器。8086架构中CS和BS 都是基地址。代码段，数据段偏移地址分别放在ip寄存器和通用寄存器。基地址+偏移地址&#x3D;要加载（代码或数据）。8086的地址总线为20位，寄存器为16位，所以计算目标位置函数&#x3D;（CS或DS）寄存器中值&lt;4位+通用寄存器的值或IP寄存器中<br>d. 32位cpu CS,DS存放的不是基地址，是寻找基地址的指针</p><h3 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h3><p>a. BIOS通电，检查硬件设备<br>b. 加载0x7c00 启动boot.img,boot.img 加载core.img,boot.img将控制权交给disboot.img,执行lzma_decompress.img（建立分段分页，打开地址线）。执行kernel.img,最后启动内核<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E5%90%AF%E5%8A%A8.jpeg" alt="图二"></p><h3 id="linux内核启动"><a href="#linux内核启动" class="headerlink" title="linux内核启动"></a>linux内核启动</h3><p>a. 内核入口在init&#x2F;main.c文件中start_kernel()<br>b. start_kernel启动了init_task第一个进程pid&#x3D;0的任务。接着是启动trap_init()中断管理,mm_init()内存分配,shed_init()进程调度<br>c. 最后进入reset_init(),通过kernel_thread 初始化kernel_init用户态进程pid&#x3D;1和kthreadadd内核态进程pid&#x3D;2。</p><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/kernel%E5%88%9D%E5%A7%8B%E5%8C%96.jpeg" alt="kernel"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-系统调用</title>
      <link href="/2025/05/18/OS-Linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>/2025/05/18/OS-Linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统调用"><a href="#Linux-系统调用" class="headerlink" title="Linux-系统调用"></a>Linux-系统调用</h1><ol><li>什么是系统调用?</li><li>系统调用流程</li></ol><h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><p>系统调用是操作系统提供给程序开发人员使用系统服务接口</p><h3 id="系统调用流程"><a href="#系统调用流程" class="headerlink" title="系统调用流程"></a>系统调用流程</h3><p>Linux 提供了 glibc 库, 它封装了系统调用接口, 对上层更友好的提供服务, 系统调用最终都会通过 DO_CALL 发起, 这是一个宏定义, 其 32 位和 64 位的定义是不同的</p><h5 id="32位系统调用"><a href="#32位系统调用" class="headerlink" title="32位系统调用"></a>32位系统调用</h5><h6 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h6><p>a. 将请求参数保存到寄存器<br>b. 将系统调用名称转换为调用号保存到eax中<br>c. 通过软中断ENTER_RETURN 进入内核态</p><h6 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h6><p>a. 将用户态的寄存器保存到pt_regs中<br>b. 在系统调用表 sys_call_table中根据调用号找到响应函数<br>c. 执行函数，将返回值写入pt_regs中ax位置<br>d. 通过INTERRUPT_RETURN 根据pt_regs恢复用户态进程</p><h5 id="64位系统调用"><a href="#64位系统调用" class="headerlink" title="64位系统调用"></a>64位系统调用</h5><h6 id="用户态-1"><a href="#用户态-1" class="headerlink" title="用户态"></a>用户态</h6><p>a. 将请求参数保存到寄存器<br>b. 将系统调用名称转换为系统调用号保存到寄存器rax中<br>c. 通过syscall进入内核态</p><h6 id="内核态-1"><a href="#内核态-1" class="headerlink" title="内核态"></a>内核态</h6><p>a. 将用户态寄存器保存到pt_regs中<br>b. 在系统调用表sys_call_table 中根据调用号查找对于函数<br>c. 执行函数，将返回值写入pt_regs中的ax位置<br>d. 通过sysretq返回用户态</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-线程和进程</title>
      <link href="/2025/05/18/OS-Linux-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
      <url>/2025/05/18/OS-Linux-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-线程和进程"><a href="#Linux-线程和进程" class="headerlink" title="Linux-线程和进程"></a>Linux-线程和进程</h1><ol><li>多线程编程与互斥</li><li>进程底层原理</li><li>进程与线程底层原理</li></ol><h3 id="多线程编程与互斥"><a href="#多线程编程与互斥" class="headerlink" title="多线程编程与互斥"></a>多线程编程与互斥</h3><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="多线程"></p><h3 id="进程底层原理"><a href="#进程底层原理" class="headerlink" title="进程底层原理"></a>进程底层原理</h3><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E8%BF%9B%E7%A8%8Bfork.jpeg" alt="进程fork"></p><h3 id="进程与线程底层原理"><a href="#进程与线程底层原理" class="headerlink" title="进程与线程底层原理"></a>进程与线程底层原理</h3><p>总结：创建进程的话，调用的系统调用是fork,在copy_process函数里面，会将五大结构，file_struct,fs_struct,sighand_struct,<br>signal_struct,mm_struct都会复制一遍，从此父进程和子进程各用各的数据结构，而创建线程的话，调用的是系统调用clone，在<br>copy_process函数里面，五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。tgid此时是进程的id,pid是线程id<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB.jpeg" alt="进程与线程底层原理"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-网络通讯</title>
      <link href="/2025/05/18/OS-Linux-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
      <url>/2025/05/18/OS-Linux-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-网络通讯"><a href="#Linux-网络通讯" class="headerlink" title="Linux-网络通讯"></a>Linux-网络通讯</h1><ol><li>tcp 三次握手建立链接</li><li>socket write</li><li>socket read</li><li>四次挥手释放链接</li></ol><h3 id="三次握手建立链接"><a href="#三次握手建立链接" class="headerlink" title="三次握手建立链接"></a>三次握手建立链接</h3><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手建立链接"></p><h3 id="socket-write"><a href="#socket-write" class="headerlink" title="socket write "></a><a href="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux网络发送.png">socket write </a></h3><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E7%BD%91%E7%BB%9C%E5%8F%91%E9%80%81.png" alt="socket write"></p><h3 id="socket-read"><a href="#socket-read" class="headerlink" title="socket read "></a><a href="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux网络读取.png">socket read </a></h3><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E7%BD%91%E7%BB%9C%E8%AF%BB%E5%8F%96.png" alt="socket read"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-虚拟文件系统</title>
      <link href="/2025/05/18/OS-Linux-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/05/18/OS-Linux-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><ol><li>文件系统结构图</li><li>文件系统挂载</li><li>虚拟文件底层代码结构</li></ol><h3 id="文件系统结构图"><a href="#文件系统结构图" class="headerlink" title="文件系统结构图"></a>文件系统结构图</h3><p>a. 文件读写进入内核态调用相应sys_open ,sys_read,sys_write<br>b. 内核态通过文件描述符找到struc file。判断file operation<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%BB%E5%86%99.jpg" alt="文件系统读写"></p><h3 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h3><p>c. struct file 如何关联struck dentry和struc mount的数据结构<br>d. struct dentry中存有inode相关信息<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD.jpeg" alt="文件系统挂载"></p><h3 id="虚拟文件底层代码结构"><a href="#虚拟文件底层代码结构" class="headerlink" title="虚拟文件底层代码结构"></a>虚拟文件底层代码结构</h3><p>f. 先look_up 然后找到最总的文件操作<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/Linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="虚拟文件底层代码结构"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-输入输出设备</title>
      <link href="/2025/05/18/OS-Linux-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/"/>
      <url>/2025/05/18/OS-Linux-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-输入输出设备"><a href="#Linux-输入输出设备" class="headerlink" title="Linux-输入输出设备"></a>Linux-输入输出设备</h1><ol><li>快设备在操作系统中的数据结构</li></ol><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F.png" alt="输入输出设备"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-进程调度</title>
      <link href="/2025/05/18/OS-Linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2025/05/18/OS-Linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-进程调度"><a href="#Linux-进程调度" class="headerlink" title="Linux-进程调度"></a>Linux-进程调度</h1><ol><li>进程调度算法</li><li>cpu如何进行进程调度</li><li>主动调度与抢占调度</li></ol><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ol><li>stop_sched_class 优先级最高的任务使用这种调度策略，会中断其他线程，不会被其他任务打断</li><li>dl_sched_class 对于deadline调度算法，DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务调度执行</li><li>rt_sched_class 对于RR算法（时间片轮转）和FIFO算法（先进先出）</li><li>fair_sched_class 就是普通进程调度策略（完全公平调度算法）</li><li>idle_sehed_class 空闲进程的调度算法</li></ol><h3 id="cpu如何进行进程调度"><a href="#cpu如何进行进程调度" class="headerlink" title="cpu如何进行进程调度"></a>cpu如何进行进程调度</h3><ol><li>cpu 会轮询进程调度类stop_sched_class，dl_sched_class，rt_sched_class，fair_sched_class，idle_sehed_class获取其中的rq队列，次rq队列是红黑树实现</li><li>获取当前红黑树最左叶子节点，每一个叶子节点都是一个sched_entiry.每个sched_entry里面都是有一个task_struct,<br>每一个task_struct 都有实现了响应调度算法类的函数</li></ol><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.jpeg" alt="进程调度"></p><h3 id="主动调度与抢占调度"><a href="#主动调度与抢占调度" class="headerlink" title="主动调度与抢占调度"></a>主动调度与抢占调度</h3><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A6%E5%92%8C%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6.png" alt="进程调度"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asyncio剖析—Task作用(二)</title>
      <link href="/2025/05/18/python-asyncio%E2%80%94Task%E4%BD%9C%E7%94%A8(%E4%BA%8C)%20copy/"/>
      <url>/2025/05/18/python-asyncio%E2%80%94Task%E4%BD%9C%E7%94%A8(%E4%BA%8C)%20copy/</url>
      
        <content type="html"><![CDATA[<h3 id="函数调用伪代码图"><a href="#函数调用伪代码图" class="headerlink" title="函数调用伪代码图"></a>函数调用伪代码图</h3><ol><li>ensure_future</li><li>wait</li><li>gather</li><li>协程链原因 Collection.deque+动态进行过程中将hand 挂在deque队列中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#案例一</span><br><span class="line">async def hello2():</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">    await asyncio.sleep(.0)</span><br><span class="line"></span><br><span class="line">loop=asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(hello2())</span><br></pre></td></tr></table></figure><img src="https://wx4.sinaimg.cn/mw690/005EpKr8ly1g18coy2m8pj30sz0ohwhq.jpg" alt="image"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#案例二</span><br><span class="line">async def hello2():</span><br><span class="line">    print(&quot;hello2 start&quot;)</span><br><span class="line">    # await pause(hello2.__name__)</span><br><span class="line">    print(&quot;hello2 end&quot;)</span><br><span class="line"></span><br><span class="line">async def pause(name):</span><br><span class="line">    print(&quot;pause&quot;,name)</span><br><span class="line"></span><br><span class="line">async def hello():</span><br><span class="line">    print(&quot;hello start&quot;)</span><br><span class="line">    # await pause(hello.__name__)</span><br><span class="line">    print(&quot;hello end&quot;)</span><br><span class="line"></span><br><span class="line">loop=asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait([hello(),hello2(),pause(&quot;pasue&quot;),hello()]))</span><br><span class="line"></span><br><span class="line">#asyncio.wait 核心</span><br><span class="line">#   fs = &#123;ensure_future(f, loop=loop) for f in set(fs)&#125;  task乱序</span><br><span class="line">#   return (yield from _wait(fs, timeout, return_when, loop))  协程生成器</span><br><span class="line">#   waiter = loop.create_future()  创建中断协程,标志这wait 协程任务已经完成</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">案例三</span><br><span class="line"></span><br><span class="line">async def hello2():</span><br><span class="line">    print(&quot;hello2 start&quot;)</span><br><span class="line">    # await pause(hello2.__name__)</span><br><span class="line">    print(&quot;hello2 end&quot;)</span><br><span class="line"></span><br><span class="line">async def pause(name):</span><br><span class="line">    print(&quot;pause&quot;,name)</span><br><span class="line"></span><br><span class="line">async def hello():</span><br><span class="line">    print(&quot;hello start&quot;)</span><br><span class="line">    # await pause(hello.__name__)</span><br><span class="line">    print(&quot;hello end&quot;)</span><br><span class="line"></span><br><span class="line">loop=asyncio.get_event_loop()</span><br><span class="line">tasks=[]</span><br><span class="line">for i in range(2):</span><br><span class="line">    if i==0:</span><br><span class="line">        tasks.append(asyncio.ensure_future(hello()))</span><br><span class="line">    else:</span><br><span class="line">        tasks.append(asyncio.ensure_future(hello2()))</span><br><span class="line"></span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br></pre></td></tr></table></figure><p><img src="https://wx4.sinaimg.cn/mw690/005EpKr8ly1g19ab9e4jaj30vo0gpq53.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> code-python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-进程间通信</title>
      <link href="/2025/05/18/OS-Linux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/05/18/OS-Linux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-进程间通信"><a href="#Linux-进程间通信" class="headerlink" title="Linux-进程间通信"></a>Linux-进程间通信</h1><ol><li>管道</li><li>消息队列</li><li>信号</li><li>共享内存模型和信号量</li></ol><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>a. 匿名管道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 1. 管道是父子进程间的通信</span><br><span class="line">// 2. fd[0] 代表读；fd[1] 代表写。一般是子进程写，即：先关闭fd[0]，在写入fd[1]。父进程读，即：先关闭fd[1],读取fd[0]</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int fds[2];</span><br><span class="line">  if (pipe(fds) == -1)</span><br><span class="line">    perror(&quot;pipe error&quot;);</span><br><span class="line"></span><br><span class="line">  pid_t pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  if (pid == -1)</span><br><span class="line">    perror(&quot;fork error&quot;);</span><br><span class="line"></span><br><span class="line">  if (pid == 0)&#123;</span><br><span class="line">    close(fds[0]);</span><br><span class="line">    char msg[] = &quot;hello world&quot;;</span><br><span class="line">    write(fds[1], msg, strlen(msg) + 1);</span><br><span class="line">    close(fds[1]);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    close(fds[1]);</span><br><span class="line">    char msg[128];</span><br><span class="line">    read(fds[0], msg, 128);</span><br><span class="line">    close(fds[0]);</span><br><span class="line">    printf(&quot;message : %s\n&quot;, msg);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E7%AE%A1%E9%81%931.png" alt="管道1"></p><p>b. linux 管道原理  (ps -ef|grep 进程|awk ‘{print $2}’|xargs kill -9)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 控制台标准输入转化成标准输出 写入到fd[1]端，另一个进程标准输入来自fd[0]端</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int fds[2];</span><br><span class="line">  if (pipe(fds) == -1)</span><br><span class="line">    perror(&quot;pipe error&quot;);</span><br><span class="line"></span><br><span class="line">  pid_t pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  if (pid == -1)</span><br><span class="line">    perror(&quot;fork error&quot;);</span><br><span class="line"></span><br><span class="line">  if (pid == 0)&#123;</span><br><span class="line">    dup2(fds[1], STDOUT_FILENO);</span><br><span class="line">    close(fds[1]);</span><br><span class="line">    close(fds[0]);</span><br><span class="line">    execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-ef&quot;, NULL);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    dup2(fds[0], STDIN_FILENO);</span><br><span class="line">    close(fds[0]);</span><br><span class="line">    close(fds[1]);</span><br><span class="line">    execlp(&quot;grep&quot;, &quot;grep&quot;, &quot;systemd&quot;, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E7%AE%A1%E9%81%932.png" alt="管道1"></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>a. ipcs -q 就能看到上面我们创建的消息队列对象。<br>b. msgget 函数创建消息队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int messagequeueid;</span><br><span class="line">  key_t key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if((key = ftok(&quot;/root/messagequeue/messagequeuekey&quot;, 1024)) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(&quot;ftok error&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Message Queue key: %d.\n&quot;, key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ((messagequeueid = msgget(key, IPC_CREAT|0777)) == -1)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(&quot;msgget error&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Message queue id: %d.\n&quot;, messagequeueid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. msgsnd发送msg到消息队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">#include &lt;getopt.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct msg_buffer &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[1024];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  int next_option;</span><br><span class="line">  const char* const short_options = &quot;i:t:m:&quot;;</span><br><span class="line">  const struct option long_options[] = &#123;</span><br><span class="line">    &#123; &quot;id&quot;, 1, NULL, &#x27;i&#x27;&#125;,</span><br><span class="line">    &#123; &quot;type&quot;, 1, NULL, &#x27;t&#x27;&#125;,</span><br><span class="line">    &#123; &quot;message&quot;, 1, NULL, &#x27;m&#x27;&#125;,</span><br><span class="line">    &#123; NULL, 0, NULL, 0 &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  int messagequeueid = -1;</span><br><span class="line">  struct msg_buffer buffer;</span><br><span class="line">  buffer.mtype = -1;</span><br><span class="line">  int len = -1;</span><br><span class="line">  char * message = NULL;</span><br><span class="line">  do &#123;</span><br><span class="line">    next_option = getopt_long (argc, argv, short_options, long_options, NULL);</span><br><span class="line">    switch (next_option)</span><br><span class="line">    &#123;</span><br><span class="line">      case &#x27;i&#x27;:</span><br><span class="line">        messagequeueid = atoi(optarg);</span><br><span class="line">        break;</span><br><span class="line">      case &#x27;t&#x27;:</span><br><span class="line">        buffer.mtype = atol(optarg);</span><br><span class="line">        break;</span><br><span class="line">      case &#x27;m&#x27;:</span><br><span class="line">        message = optarg;</span><br><span class="line">        len = strlen(message) + 1;</span><br><span class="line">        if (len &gt; 1024) &#123;</span><br><span class="line">          perror(&quot;message too long.&quot;);</span><br><span class="line">          exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        memcpy(buffer.mtext, message, len);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;while(next_option != -1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if(messagequeueid != -1 &amp;&amp; buffer.mtype != -1 &amp;&amp; len != -1 &amp;&amp; message != NULL)&#123;</span><br><span class="line">    if(msgsnd(messagequeueid, &amp;buffer, len, IPC_NOWAIT) == -1)&#123;</span><br><span class="line">      perror(&quot;fail to send message.&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    perror(&quot;arguments error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d.  msgrcv接受消息队列消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">#include &lt;getopt.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct msg_buffer &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[1024];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  int next_option;</span><br><span class="line">  const char* const short_options = &quot;i:t:&quot;;</span><br><span class="line">  const struct option long_options[] = &#123;</span><br><span class="line">    &#123; &quot;id&quot;, 1, NULL, &#x27;i&#x27;&#125;,</span><br><span class="line">    &#123; &quot;type&quot;, 1, NULL, &#x27;t&#x27;&#125;,</span><br><span class="line">    &#123; NULL, 0, NULL, 0 &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  int messagequeueid = -1;</span><br><span class="line">  struct msg_buffer buffer;</span><br><span class="line">  long type = -1;</span><br><span class="line">  do &#123;</span><br><span class="line">    next_option = getopt_long (argc, argv, short_options, long_options, NULL);</span><br><span class="line">    switch (next_option)</span><br><span class="line">    &#123;</span><br><span class="line">      case &#x27;i&#x27;:</span><br><span class="line">        messagequeueid = atoi(optarg);</span><br><span class="line">        break;</span><br><span class="line">      case &#x27;t&#x27;:</span><br><span class="line">        type = atol(optarg);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;while(next_option != -1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if(messagequeueid != -1 &amp;&amp; type != -1)&#123;</span><br><span class="line">    if(msgrcv(messagequeueid, &amp;buffer, 1024, type, IPC_NOWAIT) == -1)&#123;</span><br><span class="line">      perror(&quot;fail to recv message.&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;received message type : %d, text: %s.&quot;, buffer.mtype, buffer.mtext);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    perror(&quot;arguments error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>a. 信号值位于SIGRTMIN(&#x3D;32)和SIGRTMAX(&#x3D;63)之间的信号都是可靠信号,其他为不可靠信号<br>b. 信号注册与使用<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E4%BF%A1%E5%8F%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E4%BD%BF%E7%94%A8.png" alt="信号"></p><p>c. <a href="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux信号处理.png" style="">信号在操作系统中处理流程</a><br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86.png" alt="信号在操作系统中处理流程"></p><h3 id="共享内存模型和信号量"><a href="#共享内存模型和信号量" class="headerlink" title="共享内存模型和信号量"></a>共享内存模型和信号量</h3><p>a. 通过程序创建的共享内存和信号量集合，我们可以通过命令 ipcs 查看。当然，我们也可以通过 ipcrm 进行删除。<br>b. 共享内存与信号量初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/sem.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_NUM 128</span><br><span class="line"></span><br><span class="line">struct shm_data &#123;</span><br><span class="line">  int data[MAX_NUM];</span><br><span class="line">  int datalength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">union semun &#123;</span><br><span class="line">  int val; </span><br><span class="line">  struct semid_ds *buf; </span><br><span class="line">  unsigned short int *array; </span><br><span class="line">  struct seminfo *__buf; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int get_shmid()&#123;</span><br><span class="line">  int shmid;</span><br><span class="line">  key_t key;</span><br><span class="line">  </span><br><span class="line">  if((key = ftok(&quot;/root/sharememory/sharememorykey&quot;, 1024)) &lt; 0)&#123;</span><br><span class="line">      perror(&quot;ftok error&quot;);</span><br><span class="line">          return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  shmid = shmget(key, sizeof(struct shm_data), IPC_CREAT|0777);</span><br><span class="line">  return shmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_semaphoreid()&#123;</span><br><span class="line">  int semid;</span><br><span class="line">  key_t key;</span><br><span class="line">  </span><br><span class="line">  if((key = ftok(&quot;/root/sharememory/semaphorekey&quot;, 1024)) &lt; 0)&#123;</span><br><span class="line">      perror(&quot;ftok error&quot;);</span><br><span class="line">          return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  semid = semget(key, 1, IPC_CREAT|0777);</span><br><span class="line">  return semid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int semaphore_init (int semid) &#123;</span><br><span class="line">  union semun argument; </span><br><span class="line">  unsigned short values[1]; </span><br><span class="line">  values[0] = 1; </span><br><span class="line">  argument.array = values; </span><br><span class="line">  return semctl (semid, 0, SETALL, argument); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int semaphore_p (int semid) &#123;</span><br><span class="line">  struct sembuf operations[1]; </span><br><span class="line">  operations[0].sem_num = 0; </span><br><span class="line">  operations[0].sem_op = -1; </span><br><span class="line">  operations[0].sem_flg = SEM_UNDO; </span><br><span class="line">  return semop (semid, operations, 1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int semaphore_v (int semid) &#123;</span><br><span class="line">  struct sembuf operations[1]; </span><br><span class="line">  operations[0].sem_num = 0; </span><br><span class="line">  operations[0].sem_op = 1; </span><br><span class="line">  operations[0].sem_flg = SEM_UNDO; </span><br><span class="line">  return semop (semid, operations, 1); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>c. 生成者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;share.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  void *shm = NULL;</span><br><span class="line">  struct shm_data *shared = NULL;</span><br><span class="line">  int shmid = get_shmid();</span><br><span class="line">  int semid = get_semaphoreid();</span><br><span class="line">  int i;</span><br><span class="line">  </span><br><span class="line">  shm = shmat(shmid, (void*)0, 0);</span><br><span class="line">  if(shm == (void*)-1)&#123;</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  shared = (struct shm_data*)shm;</span><br><span class="line">  memset(shared, 0, sizeof(struct shm_data));</span><br><span class="line">  semaphore_init(semid);</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    semaphore_p(semid);</span><br><span class="line">    if(shared-&gt;datalength &gt; 0)&#123;</span><br><span class="line">      semaphore_v(semid);</span><br><span class="line">      sleep(1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      printf(&quot;how many integers to caculate : &quot;);</span><br><span class="line">      scanf(&quot;%d&quot;,&amp;shared-&gt;datalength);</span><br><span class="line">      if(shared-&gt;datalength &gt; MAX_NUM)&#123;</span><br><span class="line">        perror(&quot;too many integers.&quot;);</span><br><span class="line">        shared-&gt;datalength = 0;</span><br><span class="line">        semaphore_v(semid);</span><br><span class="line">        exit(1);</span><br><span class="line">      &#125;</span><br><span class="line">      for(i=0;i&lt;shared-&gt;datalength;i++)&#123;</span><br><span class="line">        printf(&quot;Input the %d integer : &quot;, i);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;shared-&gt;data[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      semaphore_v(semid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d. 消费者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;share.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  void *shm = NULL;</span><br><span class="line">  struct shm_data *shared = NULL;</span><br><span class="line">  int shmid = get_shmid();</span><br><span class="line">  int semid = get_semaphoreid();</span><br><span class="line">  int i;</span><br><span class="line">  </span><br><span class="line">  shm = shmat(shmid, (void*)0, 0);</span><br><span class="line">  if(shm == (void*)-1)&#123;</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  shared = (struct shm_data*)shm;</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    semaphore_p(semid);</span><br><span class="line">    if(shared-&gt;datalength &gt; 0)&#123;</span><br><span class="line">      int sum = 0;</span><br><span class="line">      for(i=0;i&lt;shared-&gt;datalength-1;i++)&#123;</span><br><span class="line">        printf(&quot;%d+&quot;,shared-&gt;data[i]);</span><br><span class="line">        sum += shared-&gt;data[i];</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;%d&quot;,shared-&gt;data[shared-&gt;datalength-1]);</span><br><span class="line">      sum += shared-&gt;data[shared-&gt;datalength-1];</span><br><span class="line">      printf(&quot;=%d\n&quot;,sum);</span><br><span class="line">      memset(shared, 0, sizeof(struct shm_data));</span><br><span class="line">      semaphore_v(semid);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      semaphore_v(semid);</span><br><span class="line">      printf(&quot;no tasks, waiting.\n&quot;);</span><br><span class="line">      sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e. 消费者与生成者结果图<br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png" alt="消费者与生成者结果图"></p><p>f. <a href="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux共享内存原理.png">共享内存原理</a><br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86.png" alt="共享内存原理"></p><p>g. <a href="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux信号量原理.png">信号量的本质</a><br><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/linux%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8E%9F%E7%90%86.png" alt="信号量的本质"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asyncio剖析—Task作用(二)</title>
      <link href="/2025/05/18/python-asyncio%E2%80%94Task%E4%BD%9C%E7%94%A8(%E4%BA%8C)/"/>
      <url>/2025/05/18/python-asyncio%E2%80%94Task%E4%BD%9C%E7%94%A8(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h3 id="函数调用伪代码图"><a href="#函数调用伪代码图" class="headerlink" title="函数调用伪代码图"></a>函数调用伪代码图</h3><ol><li>ensure_future</li><li>wait</li><li>gather</li><li>协程链原因 Collection.deque+动态进行过程中将hand 挂在deque队列中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#案例一</span><br><span class="line">async def hello2():</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">    await asyncio.sleep(.0)</span><br><span class="line"></span><br><span class="line">loop=asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(hello2())</span><br></pre></td></tr></table></figure><img src="https://wx4.sinaimg.cn/mw690/005EpKr8ly1g18coy2m8pj30sz0ohwhq.jpg" alt="image"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#案例二</span><br><span class="line">async def hello2():</span><br><span class="line">    print(&quot;hello2 start&quot;)</span><br><span class="line">    # await pause(hello2.__name__)</span><br><span class="line">    print(&quot;hello2 end&quot;)</span><br><span class="line"></span><br><span class="line">async def pause(name):</span><br><span class="line">    print(&quot;pause&quot;,name)</span><br><span class="line"></span><br><span class="line">async def hello():</span><br><span class="line">    print(&quot;hello start&quot;)</span><br><span class="line">    # await pause(hello.__name__)</span><br><span class="line">    print(&quot;hello end&quot;)</span><br><span class="line"></span><br><span class="line">loop=asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait([hello(),hello2(),pause(&quot;pasue&quot;),hello()]))</span><br><span class="line"></span><br><span class="line">#asyncio.wait 核心</span><br><span class="line">#   fs = &#123;ensure_future(f, loop=loop) for f in set(fs)&#125;  task乱序</span><br><span class="line">#   return (yield from _wait(fs, timeout, return_when, loop))  协程生成器</span><br><span class="line">#   waiter = loop.create_future()  创建中断协程,标志这wait 协程任务已经完成</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">案例三</span><br><span class="line"></span><br><span class="line">async def hello2():</span><br><span class="line">    print(&quot;hello2 start&quot;)</span><br><span class="line">    # await pause(hello2.__name__)</span><br><span class="line">    print(&quot;hello2 end&quot;)</span><br><span class="line"></span><br><span class="line">async def pause(name):</span><br><span class="line">    print(&quot;pause&quot;,name)</span><br><span class="line"></span><br><span class="line">async def hello():</span><br><span class="line">    print(&quot;hello start&quot;)</span><br><span class="line">    # await pause(hello.__name__)</span><br><span class="line">    print(&quot;hello end&quot;)</span><br><span class="line"></span><br><span class="line">loop=asyncio.get_event_loop()</span><br><span class="line">tasks=[]</span><br><span class="line">for i in range(2):</span><br><span class="line">    if i==0:</span><br><span class="line">        tasks.append(asyncio.ensure_future(hello()))</span><br><span class="line">    else:</span><br><span class="line">        tasks.append(asyncio.ensure_future(hello2()))</span><br><span class="line"></span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br></pre></td></tr></table></figure><p><img src="https://wx4.sinaimg.cn/mw690/005EpKr8ly1g19ab9e4jaj30vo0gpq53.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> code-python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asyncio剖析—认识awaitable(一)</title>
      <link href="/2025/05/18/python-asyncio%E2%80%94%E8%AE%A4%E8%AF%86awaitable(%E4%B8%80)/"/>
      <url>/2025/05/18/python-asyncio%E2%80%94%E8%AE%A4%E8%AF%86awaitable(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>Asyncio 我的理解</p><ol><li>__await__ 协议是啥？ 为啥Awaitable，Coroutine，Future，Task都有 __await__</li><li>asyncio 调用栈都有哪些,具体包含那几部</li></ol><h1 id="Awaitable源码"><a href="#Awaitable源码" class="headerlink" title="Awaitable源码"></a>Awaitable源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Awaitable(metaclass=ABCMeta):</span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def __await__(self):</span><br><span class="line">        yield</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def __subclasshook__(cls, C):</span><br><span class="line">        if cls is Awaitable:</span><br><span class="line">            return _check_methods(C, &quot;__await__&quot;)</span><br><span class="line">        return NotImplemented</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Coroutine源码"><a href="#Coroutine源码" class="headerlink" title="Coroutine源码"></a>Coroutine源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Coroutine(Awaitable):</span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def send(self, value):</span><br><span class="line">        &quot;&quot;&quot;Send a value into the coroutine.</span><br><span class="line">        Return next yielded value or raise StopIteration.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        raise StopIteration</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def throw(self, typ, val=None, tb=None):</span><br><span class="line">        &quot;&quot;&quot;Raise an exception in the coroutine.</span><br><span class="line">        Return next yielded value or raise StopIteration.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if val is None:</span><br><span class="line">            if tb is None:</span><br><span class="line">                raise typ</span><br><span class="line">            val = typ()</span><br><span class="line">        if tb is not None:</span><br><span class="line">            val = val.with_traceback(tb)</span><br><span class="line">        raise val</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        &quot;&quot;&quot;Raise GeneratorExit inside coroutine.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            self.throw(GeneratorExit)</span><br><span class="line">        except (GeneratorExit, StopIteration):</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            raise RuntimeError(&quot;coroutine ignored GeneratorExit&quot;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def __subclasshook__(cls, C):</span><br><span class="line">        if cls is Coroutine:</span><br><span class="line">            return _check_methods(C, &#x27;__await__&#x27;, &#x27;send&#x27;, &#x27;throw&#x27;, &#x27;close&#x27;)</span><br><span class="line">        return NotImplemented</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Coroutine.register(coroutine)</span><br></pre></td></tr></table></figure><h1 id="Future源码"><a href="#Future源码" class="headerlink" title="Future源码"></a>Future源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">class Future:</span><br><span class="line">    &quot;&quot;&quot;This class is *almost* compatible with concurrent.futures.Future.</span><br><span class="line"></span><br><span class="line">    Differences:</span><br><span class="line"></span><br><span class="line">    - This class is not thread-safe.</span><br><span class="line"></span><br><span class="line">    - result() and exception() do not take a timeout argument and</span><br><span class="line">      raise an exception when the future isn&#x27;t done yet.</span><br><span class="line"></span><br><span class="line">    - Callbacks registered with add_done_callback() are always called</span><br><span class="line">      via the event loop&#x27;s call_soon().</span><br><span class="line"></span><br><span class="line">    - This class is not compatible with the wait() and as_completed()</span><br><span class="line">      methods in the concurrent.futures package.</span><br><span class="line"></span><br><span class="line">    (In Python 3.4 or later we may be able to unify the implementations.)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # Class variables serving as defaults for instance variables.</span><br><span class="line">    _state = _PENDING</span><br><span class="line">    _result = None</span><br><span class="line">    _exception = None</span><br><span class="line">    _loop = None</span><br><span class="line">    _source_traceback = None</span><br><span class="line"></span><br><span class="line">    # This field is used for a dual purpose:</span><br><span class="line">    # - Its presence is a marker to declare that a class implements</span><br><span class="line">    #   the Future protocol (i.e. is intended to be duck-type compatible).</span><br><span class="line">    #   The value must also be not-None, to enable a subclass to declare</span><br><span class="line">    #   that it is not compatible by setting this to None.</span><br><span class="line">    # - It is set by __iter__() below so that Task._step() can tell</span><br><span class="line">    #   the difference between `yield from Future()` (correct) vs.</span><br><span class="line">    #   `yield Future()` (incorrect).</span><br><span class="line">    _asyncio_future_blocking = False</span><br><span class="line"></span><br><span class="line">    _log_traceback = False</span><br><span class="line"></span><br><span class="line">    def __init__(self, *, loop=None):</span><br><span class="line">        &quot;&quot;&quot;Initialize the future.</span><br><span class="line"></span><br><span class="line">        The optional event_loop argument allows explicitly setting the event</span><br><span class="line">        loop object used by the future. If it&#x27;s not provided, the future uses</span><br><span class="line">        the default event loop.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if loop is None:</span><br><span class="line">            self._loop = events.get_event_loop()</span><br><span class="line">        else:</span><br><span class="line">            self._loop = loop</span><br><span class="line">        self._callbacks = []</span><br><span class="line">        if self._loop.get_debug():</span><br><span class="line">            self._source_traceback = events.extract_stack(sys._getframe(1))</span><br><span class="line"></span><br><span class="line">    _repr_info = base_futures._future_repr_info</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#x27;&lt;%s %s&gt;&#x27; % (self.__class__.__name__, &#x27; &#x27;.join(self._repr_info()))</span><br><span class="line"></span><br><span class="line">    # On Python 3.3 and older, objects with a destructor part of a reference</span><br><span class="line">    # cycle are never destroyed. It&#x27;s not more the case on Python 3.4 thanks</span><br><span class="line">    # to the PEP 442.</span><br><span class="line">    if compat.PY34:</span><br><span class="line">        def __del__(self):</span><br><span class="line">            if not self._log_traceback:</span><br><span class="line">                # set_exception() was not called, or result() or exception()</span><br><span class="line">                # has consumed the exception</span><br><span class="line">                return</span><br><span class="line">            exc = self._exception</span><br><span class="line">            context = &#123;</span><br><span class="line">                &#x27;message&#x27;: (&#x27;%s exception was never retrieved&#x27;</span><br><span class="line">                            % self.__class__.__name__),</span><br><span class="line">                &#x27;exception&#x27;: exc,</span><br><span class="line">                &#x27;future&#x27;: self,</span><br><span class="line">            &#125;</span><br><span class="line">            if self._source_traceback:</span><br><span class="line">                context[&#x27;source_traceback&#x27;] = self._source_traceback</span><br><span class="line">            self._loop.call_exception_handler(context)</span><br><span class="line"></span><br><span class="line">    def cancel(self):</span><br><span class="line">        &quot;&quot;&quot;Cancel the future and schedule callbacks.</span><br><span class="line"></span><br><span class="line">        If the future is already done or cancelled, return False.  Otherwise,</span><br><span class="line">        change the future&#x27;s state to cancelled, schedule the callbacks and</span><br><span class="line">        return True.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._log_traceback = False</span><br><span class="line">        if self._state != _PENDING:</span><br><span class="line">            return False</span><br><span class="line">        self._state = _CANCELLED</span><br><span class="line">        self._schedule_callbacks()</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def _schedule_callbacks(self):</span><br><span class="line">        &quot;&quot;&quot;Internal: Ask the event loop to call all callbacks.</span><br><span class="line"></span><br><span class="line">        The callbacks are scheduled to be called as soon as possible. Also</span><br><span class="line">        clears the callback list.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        callbacks = self._callbacks[:]</span><br><span class="line">        if not callbacks:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        self._callbacks[:] = []</span><br><span class="line">        for callback in callbacks:</span><br><span class="line">            self._loop.call_soon(callback, self)</span><br><span class="line"></span><br><span class="line">    def cancelled(self):</span><br><span class="line">        &quot;&quot;&quot;Return True if the future was cancelled.&quot;&quot;&quot;</span><br><span class="line">        return self._state == _CANCELLED</span><br><span class="line"></span><br><span class="line">    # Don&#x27;t implement running(); see http://bugs.python.org/issue18699</span><br><span class="line"></span><br><span class="line">    def done(self):</span><br><span class="line">        &quot;&quot;&quot;Return True if the future is done.</span><br><span class="line"></span><br><span class="line">        Done means either that a result / exception are available, or that the</span><br><span class="line">        future was cancelled.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._state != _PENDING</span><br><span class="line"></span><br><span class="line">    def result(self):</span><br><span class="line">        &quot;&quot;&quot;Return the result this future represents.</span><br><span class="line"></span><br><span class="line">        If the future has been cancelled, raises CancelledError.  If the</span><br><span class="line">        future&#x27;s result isn&#x27;t yet available, raises InvalidStateError.  If</span><br><span class="line">        the future is done and has an exception set, this exception is raised.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self._state == _CANCELLED:</span><br><span class="line">            raise CancelledError</span><br><span class="line">        if self._state != _FINISHED:</span><br><span class="line">            raise InvalidStateError(&#x27;Result is not ready.&#x27;)</span><br><span class="line">        self._log_traceback = False</span><br><span class="line">        if self._exception is not None:</span><br><span class="line">            raise self._exception</span><br><span class="line">        return self._result</span><br><span class="line"></span><br><span class="line">    def exception(self):</span><br><span class="line">        &quot;&quot;&quot;Return the exception that was set on this future.</span><br><span class="line"></span><br><span class="line">        The exception (or None if no exception was set) is returned only if</span><br><span class="line">        the future is done.  If the future has been cancelled, raises</span><br><span class="line">        CancelledError.  If the future isn&#x27;t done yet, raises</span><br><span class="line">        InvalidStateError.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self._state == _CANCELLED:</span><br><span class="line">            raise CancelledError</span><br><span class="line">        if self._state != _FINISHED:</span><br><span class="line">            raise InvalidStateError(&#x27;Exception is not set.&#x27;)</span><br><span class="line">        self._log_traceback = False</span><br><span class="line">        return self._exception</span><br><span class="line"></span><br><span class="line">    def add_done_callback(self, fn):</span><br><span class="line">        &quot;&quot;&quot;Add a callback to be run when the future becomes done.</span><br><span class="line"></span><br><span class="line">        The callback is called with a single argument - the future object. If</span><br><span class="line">        the future is already done when this is called, the callback is</span><br><span class="line">        scheduled with call_soon.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self._state != _PENDING:</span><br><span class="line">            self._loop.call_soon(fn, self)</span><br><span class="line">        else:</span><br><span class="line">            self._callbacks.append(fn)</span><br><span class="line"></span><br><span class="line">    # New method not in PEP 3148.</span><br><span class="line"></span><br><span class="line">    def remove_done_callback(self, fn):</span><br><span class="line">        &quot;&quot;&quot;Remove all instances of a callback from the &quot;call when done&quot; list.</span><br><span class="line"></span><br><span class="line">        Returns the number of callbacks removed.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        filtered_callbacks = [f for f in self._callbacks if f != fn]</span><br><span class="line">        removed_count = len(self._callbacks) - len(filtered_callbacks)</span><br><span class="line">        if removed_count:</span><br><span class="line">            self._callbacks[:] = filtered_callbacks</span><br><span class="line">        return removed_count</span><br><span class="line"></span><br><span class="line">    # So-called internal methods (note: no set_running_or_notify_cancel()).</span><br><span class="line"></span><br><span class="line">    def set_result(self, result):</span><br><span class="line">        &quot;&quot;&quot;Mark the future done and set its result.</span><br><span class="line"></span><br><span class="line">        If the future is already done when this method is called, raises</span><br><span class="line">        InvalidStateError.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self._state != _PENDING:</span><br><span class="line">            raise InvalidStateError(&#x27;&#123;&#125;: &#123;!r&#125;&#x27;.format(self._state, self))</span><br><span class="line">        self._result = result</span><br><span class="line">        self._state = _FINISHED</span><br><span class="line">        self._schedule_callbacks()</span><br><span class="line"></span><br><span class="line">    def set_exception(self, exception):</span><br><span class="line">        &quot;&quot;&quot;Mark the future done and set an exception.</span><br><span class="line"></span><br><span class="line">        If the future is already done when this method is called, raises</span><br><span class="line">        InvalidStateError.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self._state != _PENDING:</span><br><span class="line">            raise InvalidStateError(&#x27;&#123;&#125;: &#123;!r&#125;&#x27;.format(self._state, self))</span><br><span class="line">        if isinstance(exception, type):</span><br><span class="line">            exception = exception()</span><br><span class="line">        if type(exception) is StopIteration:</span><br><span class="line">            raise TypeError(&quot;StopIteration interacts badly with generators &quot;</span><br><span class="line">                            &quot;and cannot be raised into a Future&quot;)</span><br><span class="line">        self._exception = exception</span><br><span class="line">        self._state = _FINISHED</span><br><span class="line">        self._schedule_callbacks()</span><br><span class="line">        if compat.PY34:</span><br><span class="line">            self._log_traceback = True</span><br><span class="line">        else:</span><br><span class="line">            self._tb_logger = _TracebackLogger(self, exception)</span><br><span class="line">            # Arrange for the logger to be activated after all callbacks</span><br><span class="line">            # have had a chance to call result() or exception().</span><br><span class="line">            self._loop.call_soon(self._tb_logger.activate)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        if not self.done():</span><br><span class="line">            self._asyncio_future_blocking = True</span><br><span class="line">            yield self  # This tells Task to wait for completion.</span><br><span class="line">        assert self.done(), &quot;yield from wasn&#x27;t used with future&quot;</span><br><span class="line">        return self.result()  # May raise too.</span><br><span class="line"></span><br><span class="line">    if compat.PY35:</span><br><span class="line">        __await__ = __iter__ # make compatible with &#x27;await&#x27; expression</span><br></pre></td></tr></table></figure><h1 id="Task源码"><a href="#Task源码" class="headerlink" title="Task源码"></a>Task源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">class Task(futures.Future):</span><br><span class="line">    &quot;&quot;&quot;A coroutine wrapped in a Future.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # An important invariant maintained while a Task not done:</span><br><span class="line">    #</span><br><span class="line">    # - Either _fut_waiter is None, and _step() is scheduled;</span><br><span class="line">    # - or _fut_waiter is some Future, and _step() is *not* scheduled.</span><br><span class="line">    #</span><br><span class="line">    # The only transition from the latter to the former is through</span><br><span class="line">    # _wakeup().  When _fut_waiter is not None, one of its callbacks</span><br><span class="line">    # must be _wakeup().</span><br><span class="line"></span><br><span class="line">    # Weak set containing all tasks alive.</span><br><span class="line">    _all_tasks = weakref.WeakSet()</span><br><span class="line"></span><br><span class="line">    # Dictionary containing tasks that are currently active in</span><br><span class="line">    # all running event loops.  &#123;EventLoop: Task&#125;</span><br><span class="line">    _current_tasks = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    # If False, don&#x27;t log a message if the task is destroyed whereas its</span><br><span class="line">    # status is still pending</span><br><span class="line">    _log_destroy_pending = True</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def current_task(cls, loop=None):</span><br><span class="line">        &quot;&quot;&quot;Return the currently running task in an event loop or None.</span><br><span class="line"></span><br><span class="line">        By default the current task for the current event loop is returned.</span><br><span class="line"></span><br><span class="line">        None is returned when called not in the context of a Task.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if loop is None:</span><br><span class="line">            loop = events.get_event_loop()</span><br><span class="line">        return cls._current_tasks.get(loop)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def all_tasks(cls, loop=None):</span><br><span class="line">        &quot;&quot;&quot;Return a set of all tasks for an event loop.</span><br><span class="line"></span><br><span class="line">        By default all tasks for the current event loop are returned.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if loop is None:</span><br><span class="line">            loop = events.get_event_loop()</span><br><span class="line">        return &#123;t for t in cls._all_tasks if t._loop is loop&#125;</span><br><span class="line"></span><br><span class="line">    def __init__(self, coro, *, loop=None):</span><br><span class="line">        assert coroutines.iscoroutine(coro), repr(coro)</span><br><span class="line">        super().__init__(loop=loop)</span><br><span class="line">        if self._source_traceback:</span><br><span class="line">            del self._source_traceback[-1]</span><br><span class="line">        self._coro = coro</span><br><span class="line">        self._fut_waiter = None</span><br><span class="line">        self._must_cancel = False</span><br><span class="line">        self._loop.call_soon(self._step)</span><br><span class="line">        self.__class__._all_tasks.add(self)</span><br><span class="line"></span><br><span class="line">    # On Python 3.3 or older, objects with a destructor that are part of a</span><br><span class="line">    # reference cycle are never destroyed. That&#x27;s not the case any more on</span><br><span class="line">    # Python 3.4 thanks to the PEP 442.</span><br><span class="line">    if compat.PY34:</span><br><span class="line">        def __del__(self):</span><br><span class="line">            if self._state == futures._PENDING and self._log_destroy_pending:</span><br><span class="line">                context = &#123;</span><br><span class="line">                    &#x27;task&#x27;: self,</span><br><span class="line">                    &#x27;message&#x27;: &#x27;Task was destroyed but it is pending!&#x27;,</span><br><span class="line">                &#125;</span><br><span class="line">                if self._source_traceback:</span><br><span class="line">                    context[&#x27;source_traceback&#x27;] = self._source_traceback</span><br><span class="line">                self._loop.call_exception_handler(context)</span><br><span class="line">            futures.Future.__del__(self)</span><br><span class="line"></span><br><span class="line">    def _repr_info(self):</span><br><span class="line">        return base_tasks._task_repr_info(self)</span><br><span class="line"></span><br><span class="line">    def get_stack(self, *, limit=None):</span><br><span class="line">        &quot;&quot;&quot;Return the list of stack frames for this task&#x27;s coroutine.</span><br><span class="line"></span><br><span class="line">        If the coroutine is not done, this returns the stack where it is</span><br><span class="line">        suspended.  If the coroutine has completed successfully or was</span><br><span class="line">        cancelled, this returns an empty list.  If the coroutine was</span><br><span class="line">        terminated by an exception, this returns the list of traceback</span><br><span class="line">        frames.</span><br><span class="line"></span><br><span class="line">        The frames are always ordered from oldest to newest.</span><br><span class="line"></span><br><span class="line">        The optional limit gives the maximum number of frames to</span><br><span class="line">        return; by default all available frames are returned.  Its</span><br><span class="line">        meaning differs depending on whether a stack or a traceback is</span><br><span class="line">        returned: the newest frames of a stack are returned, but the</span><br><span class="line">        oldest frames of a traceback are returned.  (This matches the</span><br><span class="line">        behavior of the traceback module.)</span><br><span class="line"></span><br><span class="line">        For reasons beyond our control, only one stack frame is</span><br><span class="line">        returned for a suspended coroutine.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return base_tasks._task_get_stack(self, limit)</span><br><span class="line"></span><br><span class="line">    def print_stack(self, *, limit=None, file=None):</span><br><span class="line">        &quot;&quot;&quot;Print the stack or traceback for this task&#x27;s coroutine.</span><br><span class="line"></span><br><span class="line">        This produces output similar to that of the traceback module,</span><br><span class="line">        for the frames retrieved by get_stack().  The limit argument</span><br><span class="line">        is passed to get_stack().  The file argument is an I/O stream</span><br><span class="line">        to which the output is written; by default output is written</span><br><span class="line">        to sys.stderr.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return base_tasks._task_print_stack(self, limit, file)</span><br><span class="line"></span><br><span class="line">    def cancel(self):</span><br><span class="line">        &quot;&quot;&quot;Request that this task cancel itself.</span><br><span class="line"></span><br><span class="line">        This arranges for a CancelledError to be thrown into the</span><br><span class="line">        wrapped coroutine on the next cycle through the event loop.</span><br><span class="line">        The coroutine then has a chance to clean up or even deny</span><br><span class="line">        the request using try/except/finally.</span><br><span class="line"></span><br><span class="line">        Unlike Future.cancel, this does not guarantee that the</span><br><span class="line">        task will be cancelled: the exception might be caught and</span><br><span class="line">        acted upon, delaying cancellation of the task or preventing</span><br><span class="line">        cancellation completely.  The task may also return a value or</span><br><span class="line">        raise a different exception.</span><br><span class="line"></span><br><span class="line">        Immediately after this method is called, Task.cancelled() will</span><br><span class="line">        not return True (unless the task was already cancelled).  A</span><br><span class="line">        task will be marked as cancelled when the wrapped coroutine</span><br><span class="line">        terminates with a CancelledError exception (even if cancel()</span><br><span class="line">        was not called).</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._log_traceback = False</span><br><span class="line">        if self.done():</span><br><span class="line">            return False</span><br><span class="line">        if self._fut_waiter is not None:</span><br><span class="line">            if self._fut_waiter.cancel():</span><br><span class="line">                # Leave self._fut_waiter; it may be a Task that</span><br><span class="line">                # catches and ignores the cancellation so we may have</span><br><span class="line">                # to cancel it again later.</span><br><span class="line">                return True</span><br><span class="line">        # It must be the case that self._step is already scheduled.</span><br><span class="line">        self._must_cancel = True</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def _step(self, exc=None):</span><br><span class="line">        assert not self.done(), \</span><br><span class="line">            &#x27;_step(): already done: &#123;!r&#125;, &#123;!r&#125;&#x27;.format(self, exc)</span><br><span class="line">        if self._must_cancel:</span><br><span class="line">            if not isinstance(exc, futures.CancelledError):</span><br><span class="line">                exc = futures.CancelledError()</span><br><span class="line">            self._must_cancel = False</span><br><span class="line">        coro = self._coro</span><br><span class="line">        self._fut_waiter = None</span><br><span class="line"></span><br><span class="line">        self.__class__._current_tasks[self._loop] = self</span><br><span class="line">        # Call either coro.throw(exc) or coro.send(None).</span><br><span class="line">        try:</span><br><span class="line">            if exc is None:</span><br><span class="line">                # We use the `send` method directly, because coroutines</span><br><span class="line">                # don&#x27;t have `__iter__` and `__next__` methods.</span><br><span class="line">                result = coro.send(None)</span><br><span class="line">            else:</span><br><span class="line">                result = coro.throw(exc)</span><br><span class="line">        except StopIteration as exc:</span><br><span class="line">            if self._must_cancel:</span><br><span class="line">                # Task is cancelled right before coro stops.</span><br><span class="line">                self._must_cancel = False</span><br><span class="line">                self.set_exception(futures.CancelledError())</span><br><span class="line">            else:</span><br><span class="line">                self.set_result(exc.value)</span><br><span class="line">        except futures.CancelledError:</span><br><span class="line">            super().cancel()  # I.e., Future.cancel(self).</span><br><span class="line">        except Exception as exc:</span><br><span class="line">            self.set_exception(exc)</span><br><span class="line">        except BaseException as exc:</span><br><span class="line">            self.set_exception(exc)</span><br><span class="line">            raise</span><br><span class="line">        else:</span><br><span class="line">            blocking = getattr(result, &#x27;_asyncio_future_blocking&#x27;, None)</span><br><span class="line">            if blocking is not None:</span><br><span class="line">                # Yielded Future must come from Future.__iter__().</span><br><span class="line">                if result._loop is not self._loop:</span><br><span class="line">                    self._loop.call_soon(</span><br><span class="line">                        self._step,</span><br><span class="line">                        RuntimeError(</span><br><span class="line">                            &#x27;Task &#123;!r&#125; got Future &#123;!r&#125; attached to a &#x27;</span><br><span class="line">                            &#x27;different loop&#x27;.format(self, result)))</span><br><span class="line">                elif blocking:</span><br><span class="line">                    if result is self:</span><br><span class="line">                        self._loop.call_soon(</span><br><span class="line">                            self._step,</span><br><span class="line">                            RuntimeError(</span><br><span class="line">                                &#x27;Task cannot await on itself: &#123;!r&#125;&#x27;.format(</span><br><span class="line">                                    self)))</span><br><span class="line">                    else:</span><br><span class="line">                        result._asyncio_future_blocking = False</span><br><span class="line">                        result.add_done_callback(self._wakeup)</span><br><span class="line">                        self._fut_waiter = result</span><br><span class="line">                        if self._must_cancel:</span><br><span class="line">                            if self._fut_waiter.cancel():</span><br><span class="line">                                self._must_cancel = False</span><br><span class="line">                else:</span><br><span class="line">                    self._loop.call_soon(</span><br><span class="line">                        self._step,</span><br><span class="line">                        RuntimeError(</span><br><span class="line">                            &#x27;yield was used instead of yield from &#x27;</span><br><span class="line">                            &#x27;in task &#123;!r&#125; with &#123;!r&#125;&#x27;.format(self, result)))</span><br><span class="line">            elif result is None:</span><br><span class="line">                # Bare yield relinquishes control for one event loop iteration.</span><br><span class="line">                self._loop.call_soon(self._step)</span><br><span class="line">            elif inspect.isgenerator(result):</span><br><span class="line">                # Yielding a generator is just wrong.</span><br><span class="line">                self._loop.call_soon(</span><br><span class="line">                    self._step,</span><br><span class="line">                    RuntimeError(</span><br><span class="line">                        &#x27;yield was used instead of yield from for &#x27;</span><br><span class="line">                        &#x27;generator in task &#123;!r&#125; with &#123;!r&#125;&#x27;.format(</span><br><span class="line">                            self, result)))</span><br><span class="line">            else:</span><br><span class="line">                # Yielding something else is an error.</span><br><span class="line">                self._loop.call_soon(</span><br><span class="line">                    self._step,</span><br><span class="line">                    RuntimeError(</span><br><span class="line">                        &#x27;Task got bad yield: &#123;!r&#125;&#x27;.format(result)))</span><br><span class="line">        finally:</span><br><span class="line">            self.__class__._current_tasks.pop(self._loop)</span><br><span class="line">            self = None  # Needed to break cycles when an exception occurs.</span><br><span class="line"></span><br><span class="line">    def _wakeup(self, future):</span><br><span class="line">        try:</span><br><span class="line">            future.result()</span><br><span class="line">        except Exception as exc:</span><br><span class="line">            # This may also be a cancellation.</span><br><span class="line">            self._step(exc)</span><br><span class="line">        else:</span><br><span class="line">            # Don&#x27;t pass the value of `future.result()` explicitly,</span><br><span class="line">            # as `Future.__iter__` and `Future.__await__` don&#x27;t need it.</span><br><span class="line">            # If we call `_step(value, None)` instead of `_step()`,</span><br><span class="line">            # Python eval loop would use `.send(value)` method call,</span><br><span class="line">            # instead of `__next__()`, which is slower for futures</span><br><span class="line">            # that return non-generator iterators from their `__iter__`.</span><br><span class="line">            self._step()</span><br><span class="line">        self = None  # Needed to break cycles when an exception occurs.</span><br></pre></td></tr></table></figure><h1 id="问题1-Awaitable-obj"><a href="#问题1-Awaitable-obj" class="headerlink" title="问题1 Awaitable obj"></a>问题1 Awaitable obj</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Coroutine 继承Awaitable</span><br><span class="line">Future 实现__await__ 协议</span><br><span class="line">        if compat.PY35:</span><br><span class="line">        __await__ = __iter__ # make compatible with &#x27;await&#x27; expression</span><br><span class="line">Task 继承Future</span><br><span class="line"></span><br><span class="line">我的理解 所有 Awaitable都可以变为coroutine</span><br><span class="line"></span><br><span class="line">tasks.py 中如下：</span><br><span class="line">@coroutine</span><br><span class="line">def _wrap_awaitable(awaitable):</span><br><span class="line">    &quot;&quot;&quot;Helper for asyncio.ensure_future().</span><br><span class="line"></span><br><span class="line">    Wraps awaitable (an object with __await__) into a coroutine</span><br><span class="line">    that will later be wrapped in a Task by ensure_future().</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return (yield from awaitable.__await__())</span><br></pre></td></tr></table></figure><h1 id="问题二-asyncio-调用栈"><a href="#问题二-asyncio-调用栈" class="headerlink" title="问题二 asyncio 调用栈"></a>问题二 asyncio 调用栈</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">asyncio 调用栈</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop() #根据操作系统生成select轮询 命名loop</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">asyncio.ensure_future(start_server) </span><br><span class="line">                | 函数作用：</span><br><span class="line">                | 1.future直接返回</span><br><span class="line">                | 2.iscoroutine封装成task</span><br><span class="line">                | 3.__await__对象 调用_wrap_awaitable封装成coroutine</span><br><span class="line">                | </span><br><span class="line">                v</span><br><span class="line">        task = tasks.Task(coro, loop=self) </span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">                | self=loop,callback是coro包装成的TaskStepMethWrapper</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">        handle = events.Handle(callback, args, self) #将task封装成event 放入loop 循环中</span><br><span class="line">        yeild future 挂起future自身等待轮询</span><br><span class="line">                |</span><br><span class="line">                | 重点（类似代码）：</span><br><span class="line">                |    self.coro.send(future.result) #初始化task，启动协程</span><br><span class="line">                |                  |</span><br><span class="line">                |                  v</span><br><span class="line">                |    yield from connect(sock, (&#x27;example.com&#x27;, 80)) #委托生成器到connect</span><br><span class="line">                |                  |</span><br><span class="line">                |                  v</span><br><span class="line">                |    selector.register(sock.fileno(), EVENT_WRITE,on_connected) #注册event 到loop</span><br><span class="line">                |    yield from f #委托生成器到future </span><br><span class="line">                |                  |</span><br><span class="line">                |                  v</span><br><span class="line">                |        def __iter__(self):</span><br><span class="line">                |            yield self  #挂起future自己，直到loop轮询过来进入下一步</span><br><span class="line">                |            return self.result</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">        return task</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">loop.run_until_complete() 启动loop</span><br></pre></td></tr></table></figure><ul><li>国外大神剖析 <a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html">http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html</a></li><li>学习博客 <a href="https://hatboy.github.io/archives/page/2/">https://hatboy.github.io/archives/page/2/</a></li><li>github async demo：<a href="https://github.com/langgithub/async-aiotutorial">https://github.com/langgithub/async-aiotutorial</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> code-python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy-scrapy如何循环(3)</title>
      <link href="/2025/05/18/python-scrapy-scrapy%E5%A6%82%E4%BD%95%E5%BE%AA%E7%8E%AF(3)/"/>
      <url>/2025/05/18/python-scrapy-scrapy%E5%A6%82%E4%BD%95%E5%BE%AA%E7%8E%AF(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy-scrapy如何循环"><a href="#scrapy-scrapy如何循环" class="headerlink" title="scrapy-scrapy如何循环"></a>scrapy-scrapy如何循环</h1><!-- TOC --><ul><li><ol><li>General</li></ol></li><li><ol start="2"><li>Scrapy 轮询逻辑</li></ol></li><li><ol start="3"><li>_next_request_from_scheduler</li></ol></li></ul><!-- /TOC --><h2 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h2><p>scrapy 循环核心是reactor 只的task.LoopingCall，并启动每隔slot.heartbeat.start(5) 5秒调度一次</p><h2 id="2-Scrapy-轮询逻辑"><a href="#2-Scrapy-轮询逻辑" class="headerlink" title="2. Scrapy 轮询逻辑"></a>2. Scrapy 轮询逻辑</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def _next_request(self, spider):</span><br><span class="line">    slot = self.slot</span><br><span class="line">    if not slot:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    if self.paused:</span><br><span class="line">        return</span><br><span class="line">    # 限制并发数的（如果request连接大于小于一个数，respons内容小于一个数）继续网络下载抓取</span><br><span class="line">    while not self._needs_backout(spider):</span><br><span class="line">        # 1. 网络下载</span><br><span class="line">        if not self._next_request_from_scheduler(spider):</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    if slot.start_requests and not self._needs_backout(spider):</span><br><span class="line">        try:</span><br><span class="line">            # 2. 第一次启动调用自己写的start_requests</span><br><span class="line">            request = next(slot.start_requests)</span><br><span class="line">        except StopIteration:</span><br><span class="line">            slot.start_requests = None</span><br><span class="line">        except Exception:</span><br><span class="line">            slot.start_requests = None</span><br><span class="line">            logger.error(&#x27;Error while obtaining start requests&#x27;,</span><br><span class="line">                            exc_info=True, extra=&#123;&#x27;spider&#x27;: spider&#125;)</span><br><span class="line">        else:</span><br><span class="line">            self.crawl(request, spider)</span><br><span class="line"></span><br><span class="line">    if self.spider_is_idle(spider) and slot.close_if_idle:</span><br><span class="line">        # 3. 开启redis新的调度</span><br><span class="line">        self._spider_idle(spider)</span><br></pre></td></tr></table></figure><ol><li>_next_request 相当于while true中的循环体</li><li>循环体中有3次集合用于获取种子<ul><li>self._next_request_from_scheduler(spider) 第一处也是最重要的一处</li><li>request &#x3D; next(slot.start_requests) 第二处获取种子，也就是自己重写的start_requests</li><li>self._spider_idle(spider) 注册了signals.spider_idle 信号的，比如scrapy-redis</li></ul></li><li>外层调度方式 self.crawler.engine.crawl 把种子传进来</li><li>self.heartbeat &#x3D; task.LoopingCall(nextcall.schedule)，slot.heartbeat.start(5) 这才是循环的核心</li></ol><h2 id="3-next-request-from-scheduler"><a href="#3-next-request-from-scheduler" class="headerlink" title="3. _next_request_from_scheduler"></a>3. _next_request_from_scheduler</h2>]]></content>
      
      
      <categories>
          
          <category> 爬虫-scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy-twisted分析</title>
      <link href="/2025/05/18/python-scrapy-twisted%E5%88%86%E6%9E%90(2)/"/>
      <url>/2025/05/18/python-scrapy-twisted%E5%88%86%E6%9E%90(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy-twisted分析"><a href="#scrapy-twisted分析" class="headerlink" title="scrapy-twisted分析"></a>scrapy-twisted分析</h1><!-- TOC --><ul><li><ol><li>General</li></ol></li><li><ol start="2"><li>twisted异步框架</li></ol><ul><li>2.1. reactor设计模式</li><li>2.2. Deferred延迟对象</li><li>2.3. @defer.inlineCallbacks的作用</li></ul></li></ul><!-- /TOC --><h2 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h2><p>scrapy 底层采用异步网络框架twisted来实现的，这一章主要讲解reactor defferd defferList @defer.inlineCallbacks等一些列异步开发api在scrapy中的应用</p><h2 id="2-twisted异步框架"><a href="#2-twisted异步框架" class="headerlink" title="2. twisted异步框架"></a>2. twisted异步框架</h2><h3 id="2-1-reactor设计模式"><a href="#2-1-reactor设计模式" class="headerlink" title="2.1. reactor设计模式"></a>2.1. reactor设计模式</h3><p>暂时不做详细讲解，研究中</p><h3 id="2-2-Deferred延迟对象"><a href="#2-2-Deferred延迟对象" class="headerlink" title="2.2. Deferred延迟对象"></a>2.2. Deferred延迟对象</h3><p>API: <a href="https://twistedmatrix.com/documents/10.1.0/core/howto/defer.html">https://twistedmatrix.com/documents/10.1.0/core/howto/defer.html</a></p><blockquote><ul><li>Deferred 底层数据结构是[tuple()],如</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def addCallbacks(self, callback, errback=None,</span><br><span class="line">                    callbackArgs=None, callbackKeywords=None,</span><br><span class="line">                    errbackArgs=None, errbackKeywords=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Add a pair of callbacks (success and error) to this L&#123;Deferred&#125;.</span><br><span class="line"></span><br><span class="line">    These will be executed when the &#x27;master&#x27; callback is run.</span><br><span class="line"></span><br><span class="line">    @return: C&#123;self&#125;.</span><br><span class="line">    @rtype: a L&#123;Deferred&#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    assert callable(callback)</span><br><span class="line">    assert errback is None or callable(errback)</span><br><span class="line">    cbs = ((callback, callbackArgs, callbackKeywords),</span><br><span class="line">            (errback or (passthru), errbackArgs, errbackKeywords))</span><br><span class="line">    self.callbacks.append(cbs)</span><br><span class="line"></span><br><span class="line">    if self.called:</span><br><span class="line">        self._runCallbacks()</span><br><span class="line">    return self</span><br></pre></td></tr></table></figure><blockquote><ul><li>addCallbacks是核心,向callbacks连表添加回调对象。addCallback-&gt;tuple(callback,passthru)，addErrback-&gt;(passthru,errback)，addBoth-&gt;(callback,errback)都会调用addCallbacks。只是addCallbacks中参数不一样.来看下_runCallbacks函数</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 核心逻辑</span><br><span class="line">def _runCallbacks(self):</span><br><span class="line">    ...忽略...</span><br><span class="line">    # 此处的self 是defferList连表</span><br><span class="line">    chain = [self]</span><br><span class="line">    while chain:</span><br><span class="line">        # 把list当作栈来使用 ，取出一个defferd对象</span><br><span class="line">        current = chain[-1]</span><br><span class="line">        ...忽略...</span><br><span class="line">        while current.callbacks:</span><br><span class="line">            # 获取其中的callbacks 列表</span><br><span class="line">            item = current.callbacks.pop(0)</span><br><span class="line">            callback, args, kw = item[</span><br><span class="line">                isinstance(current.result, failure.Failure)]</span><br><span class="line">            args = args or ()</span><br><span class="line">            kw = kw or &#123;&#125;</span><br><span class="line">            try:</span><br><span class="line">                current._runningCallbacks = True</span><br><span class="line">                try:</span><br><span class="line">                    # callback回调，传入上一次回调结果，保存当前结果</span><br><span class="line">                    current.result = callback(current.result, *args, **kw)</span><br><span class="line">                    ...忽略...</span><br><span class="line">                finally:</span><br><span class="line">                    current._runningCallbacks = False</span><br><span class="line">            except:</span><br><span class="line">                ...忽略...</span><br><span class="line">            else:</span><br><span class="line">                ...忽略...</span><br><span class="line">        if finished:</span><br><span class="line">            ...忽略...</span><br><span class="line">            # defferd完成，移除[-1]最后一个对象</span><br><span class="line">            chain.pop()</span><br></pre></td></tr></table></figure><h3 id="2-3-defer-inlineCallbacks的作用"><a href="#2-3-defer-inlineCallbacks的作用" class="headerlink" title="2.3. @defer.inlineCallbacks的作用"></a>2.3. @defer.inlineCallbacks的作用</h3><blockquote><p>@defer.inlineCallbacks封装成一个defferd对象然后返回，避免写defferd，callback。调用时启动生成器，判断返回内容是否是defferd对象，如果是继续递归调用当前方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@failure._extraneous</span><br><span class="line">def _inlineCallbacks(result, g, status):</span><br><span class="line">    waiting = [True, # waiting for result?</span><br><span class="line">               None] # result</span><br><span class="line"></span><br><span class="line">    while 1:</span><br><span class="line">        try:</span><br><span class="line">            # Send the last result back as the result of the yield expression.</span><br><span class="line">            isFailure = isinstance(result, failure.Failure)</span><br><span class="line">            if isFailure:</span><br><span class="line">                result = result.throwExceptionIntoGenerator(g)</span><br><span class="line">            else:</span><br><span class="line">                result = g.send(result)</span><br><span class="line">        except StopIteration as e:</span><br><span class="line">            # fell off the end, or &quot;return&quot; statement</span><br><span class="line">            status.deferred.callback(getattr(e, &quot;value&quot;, None))</span><br><span class="line">            return</span><br><span class="line">        except _DefGen_Return as e:</span><br><span class="line">            ...忽略...</span><br><span class="line">        except:</span><br><span class="line">            status.deferred.errback()</span><br><span class="line">            return</span><br><span class="line">        # 如果是defferd对象，递归调用</span><br><span class="line">        if isinstance(result, Deferred):</span><br><span class="line">            # a deferred was yielded, get the result.</span><br><span class="line">            def gotResult(r):</span><br><span class="line">                if waiting[0]:</span><br><span class="line">                    waiting[0] = False</span><br><span class="line">                    waiting[1] = r</span><br><span class="line">                else:</span><br><span class="line">                    # We are not waiting for deferred result any more</span><br><span class="line">                    _inlineCallbacks(r, g, status)</span><br><span class="line"></span><br><span class="line">            result.addBoth(gotResult)</span><br><span class="line">            if waiting[0]:</span><br><span class="line">                # Haven&#x27;t called back yet, set flag so that we get reinvoked</span><br><span class="line">                # and return from the loop</span><br><span class="line">                waiting[0] = False</span><br><span class="line">                status.waitingOn = result</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            result = waiting[1]</span><br><span class="line"></span><br><span class="line">            waiting[0] = True</span><br><span class="line">            waiting[1] = None</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫-scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy-中间件源码分析(4)</title>
      <link href="/2025/05/18/python-scrapy-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(4)/"/>
      <url>/2025/05/18/python-scrapy-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(4)/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy-中间件源码分析-3"><a href="#scrapy-中间件源码分析-3" class="headerlink" title="scrapy-中间件源码分析(3)"></a>scrapy-中间件源码分析(3)</h1><!-- TOC --><ul><li><ol><li>General</li></ol></li><li><ol start="2"><li>MiddlewareManager（父）</li></ol><ul><li>2.1. MiddlewareManager 是中间件的抽象类，他的子类包括.以及代码中加载顺序</li><li>2.2. MiddlewareManager 初始化</li><li>2.3. 存储数据结构</li></ul></li><li><ol start="3"><li>ExtensionManager（子）</li></ol><ul><li>3.1. 首先看下程序启动时的打印代码 </li><li>3.2. 扩展类中间件采用父类的加载</li><li>3.3. 中间件的key说明</li></ul></li><li><ol start="4"><li>DownloaderMiddlewareManager（子）</li></ol><ul><li>4.1. 首先看下程序启动时的打印代码 </li><li>4.2. DownloaderMiddleware加载源码</li><li>4.3. 中间件的key说明</li><li>4.4. 调用方式</li></ul></li><li><ol start="5"><li>SpiderMiddlewareManager（子）</li></ol><ul><li>5.1. 首先看下程序启动时的打印代码 </li><li>5.2. SpiderMiddleware加载源码</li><li>5.3. 中间件的key说明</li><li>5.4. 调用方式</li></ul></li><li><ol start="6"><li>ItemPipelineManager（子）</li></ol><ul><li>6.1. 首先看下程序启动时的打印代码 </li><li>6.2. ItemPipeline加载源码</li><li>6.3. 中间件的key说明</li><li>6.4. 调用方式</li></ul></li></ul><!-- /TOC --><h2 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h2><h2 id="2-MiddlewareManager（父）"><a href="#2-MiddlewareManager（父）" class="headerlink" title="2. MiddlewareManager（父）"></a>2. MiddlewareManager（父）</h2><h3 id="2-1-MiddlewareManager-是中间件的抽象类，他的子类包括-以及代码中加载顺序"><a href="#2-1-MiddlewareManager-是中间件的抽象类，他的子类包括-以及代码中加载顺序" class="headerlink" title="2.1. MiddlewareManager 是中间件的抽象类，他的子类包括.以及代码中加载顺序"></a>2.1. MiddlewareManager 是中间件的抽象类，他的子类包括.以及代码中加载顺序</h3><blockquote><ul><li>ExtensionManager 扩展中间件 1</li><li>DownloaderMiddlewareManager 下载中间件 2</li><li>SpiderMiddlewareManager 爬虫中间件 3</li><li>ItemPipelineManager pipline中间件 4</li></ul></blockquote><h3 id="2-2-MiddlewareManager-初始化"><a href="#2-2-MiddlewareManager-初始化" class="headerlink" title="2.2. MiddlewareManager 初始化"></a>2.2. MiddlewareManager 初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, *middlewares):</span><br><span class="line">    # 所有的中间件</span><br><span class="line">    self.middlewares = middlewares</span><br><span class="line">    # 中间件存放的数据结构，map ,每一个map位是一个队列</span><br><span class="line">    self.methods = defaultdict(deque)</span><br><span class="line">    for mw in middlewares:</span><br><span class="line">        self._add_middleware(mw)</span><br></pre></td></tr></table></figure><h3 id="2-3-存储数据结构"><a href="#2-3-存储数据结构" class="headerlink" title="2.3. 存储数据结构"></a>2.3. 存储数据结构</h3><blockquote><ul><li>所有的中间件中重写的方法都会放在 self.methods &#x3D; defaultdict(deque) 这个map</li><li>map的key做了分类，详细见每个中间件的key解释</li><li>中间件的顺序是排好序后 append，appendleft 来实现</li></ul></blockquote><h2 id="3-ExtensionManager（子）"><a href="#3-ExtensionManager（子）" class="headerlink" title="3. ExtensionManager（子）"></a>3. ExtensionManager（子）</h2><h3 id="3-1-首先看下程序启动时的打印代码"><a href="#3-1-首先看下程序启动时的打印代码" class="headerlink" title="3.1. 首先看下程序启动时的打印代码"></a>3.1. 首先看下程序启动时的打印代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-08-21 10:26:15 [scrapy.middleware] INFO: Enabled extensions:</span><br><span class="line">[&#x27;scrapy.extensions.corestats.CoreStats&#x27;, 核心统计收集器</span><br><span class="line"> &#x27;scrapy.extensions.telnet.TelnetConsole&#x27;, 监听控制台服务启动</span><br><span class="line"> &#x27;scrapy.extensions.memusage.MemoryUsage&#x27;,  监控内存做一些应急处理</span><br><span class="line"> &#x27;scrapy.extensions.logstats.LogStats&#x27;,  日志统计打印的</span><br><span class="line"> &#x27;social_spider.middlewares.SpiderCallBackErrCount&#x27;] 自定义收集器</span><br></pre></td></tr></table></figure><h3 id="3-2-扩展类中间件采用父类的加载"><a href="#3-2-扩展类中间件采用父类的加载" class="headerlink" title="3.2. 扩展类中间件采用父类的加载"></a>3.2. 扩展类中间件采用父类的加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 实际上扩展类中间件并没有保存到字典，直接在 from_crawler 中做处理，通过信号注册</span><br><span class="line">def _add_middleware(self, mw):</span><br><span class="line">    if hasattr(mw, &#x27;open_spider&#x27;):</span><br><span class="line">        self.methods[&#x27;open_spider&#x27;].append(mw.open_spider)</span><br><span class="line">    if hasattr(mw, &#x27;close_spider&#x27;):</span><br><span class="line">        self.methods[&#x27;close_spider&#x27;].appendleft(mw.close_spider)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-中间件的key说明"><a href="#3-3-中间件的key说明" class="headerlink" title="3.3. 中间件的key说明"></a>3.3. 中间件的key说明</h3><blockquote><p>open_spider<br>close_spider</p></blockquote><h2 id="4-DownloaderMiddlewareManager（子）"><a href="#4-DownloaderMiddlewareManager（子）" class="headerlink" title="4. DownloaderMiddlewareManager（子）"></a>4. DownloaderMiddlewareManager（子）</h2><h3 id="4-1-首先看下程序启动时的打印代码"><a href="#4-1-首先看下程序启动时的打印代码" class="headerlink" title="4.1. 首先看下程序启动时的打印代码"></a>4.1. 首先看下程序启动时的打印代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2020-08-21 10:29:00 [scrapy.middleware] INFO: Enabled downloader middlewares:</span><br><span class="line">[&#x27;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&#x27;,</span><br><span class="line"> &#x27;social_spider.middlewares.ProxyMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.retry.RetryMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&#x27;,</span><br><span class="line"> &#x27;social_spider.middlewares.StatMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.downloadermiddlewares.stats.DownloaderStats&#x27;]</span><br></pre></td></tr></table></figure><h3 id="4-2-DownloaderMiddleware加载源码"><a href="#4-2-DownloaderMiddleware加载源码" class="headerlink" title="4.2. DownloaderMiddleware加载源码"></a>4.2. DownloaderMiddleware加载源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 重写函数，所有的 DOWNLOADER_MIDDLEWARES 都会保存到process_request，process_response，process_response， 看你重写了啥就保存啥</span><br><span class="line">def _add_middleware(self, mw):</span><br><span class="line">    if hasattr(mw, &#x27;process_request&#x27;):</span><br><span class="line">        self.methods[&#x27;process_request&#x27;].append(mw.process_request)</span><br><span class="line">    if hasattr(mw, &#x27;process_response&#x27;):</span><br><span class="line">        self.methods[&#x27;process_response&#x27;].appendleft(mw.process_response)</span><br><span class="line">    if hasattr(mw, &#x27;process_exception&#x27;):</span><br><span class="line">        self.methods[&#x27;process_exception&#x27;].appendleft(mw.process_exception)</span><br></pre></td></tr></table></figure><h3 id="4-3-中间件的key说明"><a href="#4-3-中间件的key说明" class="headerlink" title="4.3. 中间件的key说明"></a>4.3. 中间件的key说明</h3><blockquote><p>process_request<br>process_response<br>process_exception</p></blockquote><h3 id="4-4-调用方式"><a href="#4-4-调用方式" class="headerlink" title="4.4. 调用方式"></a>4.4. 调用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def download(self, download_func, request, spider):</span><br><span class="line">    @defer.inlineCallbacks</span><br><span class="line">    def process_request(request):</span><br><span class="line">        for method in self.methods[&#x27;process_request&#x27;]:</span><br><span class="line">            response = yield deferred_from_coro(method(request=request, spider=spider))</span><br><span class="line">            if response is not None and not isinstance(response, (Response, Request)):</span><br><span class="line">                raise _InvalidOutput(&#x27;Middleware %s.process_request must return None, Response or Request, got %s&#x27; % \</span><br><span class="line">                                      (method.__self__.__class__.__name__, response.__class__.__name__))</span><br><span class="line">            if response:</span><br><span class="line">                defer.returnValue(response)</span><br><span class="line">        defer.returnValue((yield download_func(request=request, spider=spider)))</span><br><span class="line"></span><br><span class="line">    @defer.inlineCallbacks</span><br><span class="line">    def process_response(response):</span><br><span class="line">        assert response is not None, &#x27;Received None in process_response&#x27;</span><br><span class="line">        if isinstance(response, Request):</span><br><span class="line">            defer.returnValue(response)</span><br><span class="line"></span><br><span class="line">        for method in self.methods[&#x27;process_response&#x27;]:</span><br><span class="line">            response = yield deferred_from_coro(method(request=request, response=response, spider=spider))</span><br><span class="line">            if not isinstance(response, (Response, Request)):</span><br><span class="line">                raise _InvalidOutput(&#x27;Middleware %s.process_response must return Response or Request, got %s&#x27; % \</span><br><span class="line">                                      (method.__self__.__class__.__name__, type(response)))</span><br><span class="line">            if isinstance(response, Request):</span><br><span class="line">                defer.returnValue(response)</span><br><span class="line">        defer.returnValue(response)</span><br><span class="line"></span><br><span class="line">    @defer.inlineCallbacks</span><br><span class="line">    def process_exception(_failure):</span><br><span class="line">        exception = _failure.value</span><br><span class="line">        for method in self.methods[&#x27;process_exception&#x27;]:</span><br><span class="line">            response = yield deferred_from_coro(method(request=request, exception=exception, spider=spider))</span><br><span class="line">            if response is not None and not isinstance(response, (Response, Request)):</span><br><span class="line">                raise _InvalidOutput(&#x27;Middleware %s.process_exception must return None, Response or Request, got %s&#x27; % \</span><br><span class="line">                                      (method.__self__.__class__.__name__, type(response)))</span><br><span class="line">            if response:</span><br><span class="line">                defer.returnValue(response)</span><br><span class="line">        defer.returnValue(_failure)</span><br><span class="line"></span><br><span class="line">    deferred = mustbe_deferred(process_request, request)</span><br><span class="line">    deferred.addErrback(process_exception)</span><br><span class="line">    deferred.addCallback(process_response)</span><br><span class="line">    return deferred</span><br></pre></td></tr></table></figure><h2 id="5-SpiderMiddlewareManager（子）"><a href="#5-SpiderMiddlewareManager（子）" class="headerlink" title="5. SpiderMiddlewareManager（子）"></a>5. SpiderMiddlewareManager（子）</h2><h3 id="5-1-首先看下程序启动时的打印代码"><a href="#5-1-首先看下程序启动时的打印代码" class="headerlink" title="5.1. 首先看下程序启动时的打印代码"></a>5.1. 首先看下程序启动时的打印代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-08-21 10:37:21 [scrapy.middleware] INFO: Enabled spider middlewares:</span><br><span class="line">[&#x27;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.spidermiddlewares.referer.RefererMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&#x27;,</span><br><span class="line"> &#x27;scrapy.spidermiddlewares.depth.DepthMiddleware&#x27;]</span><br></pre></td></tr></table></figure><h3 id="5-2-SpiderMiddleware加载源码"><a href="#5-2-SpiderMiddleware加载源码" class="headerlink" title="5.2. SpiderMiddleware加载源码"></a>5.2. SpiderMiddleware加载源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def _add_middleware(self, mw):</span><br><span class="line">    super(SpiderMiddlewareManager, self)._add_middleware(mw)</span><br><span class="line">    if hasattr(mw, &#x27;process_spider_input&#x27;):</span><br><span class="line">        self.methods[&#x27;process_spider_input&#x27;].append(mw.process_spider_input)</span><br><span class="line">    if hasattr(mw, &#x27;process_start_requests&#x27;):</span><br><span class="line">        self.methods[&#x27;process_start_requests&#x27;].appendleft(mw.process_start_requests)</span><br><span class="line">    process_spider_output = getattr(mw, &#x27;process_spider_output&#x27;, None)</span><br><span class="line">    self.methods[&#x27;process_spider_output&#x27;].appendleft(process_spider_output)</span><br><span class="line">    process_spider_exception = getattr(mw, &#x27;process_spider_exception&#x27;, None)</span><br><span class="line">    self.methods[&#x27;process_spider_exception&#x27;].appendleft(process_spider_exception)</span><br></pre></td></tr></table></figure><h3 id="5-3-中间件的key说明"><a href="#5-3-中间件的key说明" class="headerlink" title="5.3. 中间件的key说明"></a>5.3. 中间件的key说明</h3><blockquote><p>open_spider<br>close_spider<br>process_spider_input<br>process_start_requests<br>process_spider_output<br>process_spider_exception</p></blockquote><h3 id="5-4-调用方式"><a href="#5-4-调用方式" class="headerlink" title="5.4. 调用方式"></a>5.4. 调用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def process_start_requests(self, start_requests, spider):</span><br><span class="line">    return self._process_chain(&#x27;process_start_requests&#x27;, start_requests, spider)</span><br></pre></td></tr></table></figure><h2 id="6-ItemPipelineManager（子）"><a href="#6-ItemPipelineManager（子）" class="headerlink" title="6. ItemPipelineManager（子）"></a>6. ItemPipelineManager（子）</h2><h3 id="6-1-首先看下程序启动时的打印代码"><a href="#6-1-首先看下程序启动时的打印代码" class="headerlink" title="6.1. 首先看下程序启动时的打印代码"></a>6.1. 首先看下程序启动时的打印代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-21 10:47:28 [scrapy.middleware] INFO: Enabled item pipelines:</span><br><span class="line">[&#x27;social_spider.pipelines.PipelineKafka&#x27;]</span><br></pre></td></tr></table></figure><h3 id="6-2-ItemPipeline加载源码"><a href="#6-2-ItemPipeline加载源码" class="headerlink" title="6.2. ItemPipeline加载源码"></a>6.2. ItemPipeline加载源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def _add_middleware(self, pipe):</span><br><span class="line">    super(ItemPipelineManager, self)._add_middleware(pipe)</span><br><span class="line">    if hasattr(pipe, &#x27;process_item&#x27;):</span><br><span class="line">        self.methods[&#x27;process_item&#x27;].append(deferred_f_from_coro_f(pipe.process_item))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-3-中间件的key说明"><a href="#6-3-中间件的key说明" class="headerlink" title="6.3. 中间件的key说明"></a>6.3. 中间件的key说明</h3><blockquote><p>open_spider<br>close_spider<br>process_item</p></blockquote><h3 id="6-4-调用方式"><a href="#6-4-调用方式" class="headerlink" title="6.4. 调用方式"></a>6.4. 调用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def process_item(self, item, spider):</span><br><span class="line">    return self._process_chain(&#x27;process_item&#x27;, item, spider)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫-scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy-信号(5)</title>
      <link href="/2025/05/18/python-scrapy-%E4%BF%A1%E5%8F%B7(5)/"/>
      <url>/2025/05/18/python-scrapy-%E4%BF%A1%E5%8F%B7(5)/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy-信号-5"><a href="#scrapy-信号-5" class="headerlink" title="scrapy-信号(5)"></a>scrapy-信号(5)</h1><h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><h2 id="操作系统-single"><a href="#操作系统-single" class="headerlink" title="操作系统 single"></a>操作系统 single</h2><blockquote><ul><li>操作系统信息即软中断，异步进行一些事件处理</li><li>信号总结 <a href="https://www.cnblogs.com/taobataoma/archive/2007/08/30/875743.html">https://www.cnblogs.com/taobataoma/archive/2007/08/30/875743.html</a></li></ul></blockquote><h2 id="scrapy-single"><a href="#scrapy-single" class="headerlink" title="scrapy single"></a>scrapy single</h2><h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><blockquote><ul><li>源码位置 .&#x2F;python3.6&#x2F;site-packages&#x2F;scrapy&#x2F;signalmanager.py</li><li>原理 通过from pydispatch import dispatcher来实现</li></ul></blockquote><h3 id="信号总结"><a href="#信号总结" class="headerlink" title="信号总结"></a>信号总结</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫-scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy-项目介绍(1)</title>
      <link href="/2025/05/18/python-scrapy-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D(1)/"/>
      <url>/2025/05/18/python-scrapy-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy项目介绍"><a href="#scrapy项目介绍" class="headerlink" title="scrapy项目介绍"></a>scrapy项目介绍</h1><!-- TOC --><ul><li><ol><li>General</li></ol></li><li><ol start="2"><li>项目基本使用</li></ol></li><li><ol start="3"><li>scrapy整体介绍</li></ol><ul><li>3.1. scrapy组件</li><li>3.2. scrapy组件总结</li></ul></li><li><ol start="4"><li>scrapy启动</li></ol><ul><li>4.1. Crawler-命令执行入口</li><li>4.2. Crawler.crawl 分析</li><li>4.3. ExecutionEngine.open_spider分析</li></ul></li><li><ol start="5"><li>总结</li></ol></li></ul><!-- /TOC --><h2 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h2><blockquote><p>scrapy是底层采用twsited基于事件驱动模型的通讯框架来实现，包含Engine，Scheduler，Spider，Downloader，Pipline五大部分组成</p></blockquote><h2 id="2-项目基本使用"><a href="#2-项目基本使用" class="headerlink" title="2. 项目基本使用"></a>2. 项目基本使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api: https://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html</span><br><span class="line">scrapy startproject doubanmovie</span><br><span class="line">cd doubanmovie</span><br><span class="line">scrapy genspider movie duoban.com</span><br></pre></td></tr></table></figure><h2 id="3-scrapy整体介绍"><a href="#3-scrapy整体介绍" class="headerlink" title="3. scrapy整体介绍"></a>3. scrapy整体介绍</h2><blockquote><p><img src="/img/scrapy%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="scrapy架构图"></p></blockquote><h3 id="3-1-scrapy组件"><a href="#3-1-scrapy组件" class="headerlink" title="3.1. scrapy组件"></a>3.1. scrapy组件</h3><blockquote><ol><li>Spiders -&gt; 用户自己编写的爬虫脚本，可自定义抓取意图</li><li>pipline -&gt; 负责输出结构化数据，可自定义输出位置</li><li>Scheduler -&gt; 负责管理任务、过滤任务、输出任务的调度器，存储、去重任务都在此控制</li><li>Downloader -&gt; 下载器，负责在网络上下载网页数据，输入待下载URL，输出下载结果</li><li>Scrapy Engine -&gt; 核心引擎，负责控制和调度各个组件，保证数据流转</li><li>Downloader middlewares -&gt; 介于引擎和下载器之间，可以在网页在下载前、后进行逻辑处理</li><li>Spider middlewares -&gt; 介于引擎和爬虫之间，可以在调用爬虫输入下载结果和输出请求&#x2F;数据时进行逻辑</li></ol></blockquote><h3 id="3-2-scrapy组件总结"><a href="#3-2-scrapy组件总结" class="headerlink" title="3.2. scrapy组件总结"></a>3.2. scrapy组件总结</h3><blockquote><ol><li>scrapy Engine启动调度Scheduler获取url种子</li><li>Engine将种子传递给download下载返回response</li><li>Engine将response传递给spider解析</li><li>Engine将解析回来的scrapy Item传递给pipline<br>其中在2中种子传递用Downloader middlewares进一步封装。</li></ol></blockquote><h2 id="4-scrapy启动"><a href="#4-scrapy启动" class="headerlink" title="4. scrapy启动"></a>4. scrapy启动</h2><h3 id="4-1-Crawler-命令执行入口"><a href="#4-1-Crawler-命令执行入口" class="headerlink" title="4.1. Crawler-命令执行入口"></a>4.1. Crawler-命令执行入口</h3><blockquote><ol><li>位于.&#x2F;python3.6&#x2F;site-packages&#x2F;scrapy&#x2F;commands&#x2F;crawl.py 中Command(ScrapyCommand) 是对scrapy命令解析执行. 调用逻辑run-&gt;self.crawler_process.crawl(spname, **opts.spargs)-&gt;self.crawler_process.start()。我们来看下crawler_process，该对象是在.&#x2F;python3.6&#x2F;site-packages&#x2F;scrapy&#x2F;cmdline.py 中144行创建cmd.crawler_process &#x3D; CrawlerProcess(settings)</li></ol></blockquote><blockquote><ol start="2"><li>接着看CrawlerProcess, 这理解之前先看下CrawlerProcess CrawlerRunner Crawler 三者的关系；首先从这里 class CrawlerProcess(CrawlerRunner) 看出CrawlerProcess继承CrawlerRunner，CrawlerRunner中的_create_crawler可以创建Crawler对象。而Crawler对象是加载全局配置文件Setting.py和爬虫文件的。   总结：.&#x2F;python3.6&#x2F;site-packages&#x2F;scrapy&#x2F;commands&#x2F;crawl.py 是解析scrapy命令的，第一步self.crawler_process.crawl(spname, **opts.spargs) 返回延迟对象，等待reactor轮询。第二部self.crawler_process.start() 启动轮询</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># CrawlerProcess函数说明</span><br><span class="line">class CrawlerProcess(CrawlerRunner):</span><br><span class="line">    # 操作系统信号量回调函数注册（也就是ctrl+c 后调用的函数）</span><br><span class="line">    def __init__(self, settings=None, install_root_handler=True):...</span><br><span class="line">    # 信号量回调函数，ctrl+c结束当前进程，优雅的退出进程</span><br><span class="line">    def _signal_shutdown(self, signum, _):...</span><br><span class="line">    # 如果一次ctrl+c没有退出，则会触发当前操作，强制退出</span><br><span class="line">    def _signal_kill(self, signum, _):...</span><br><span class="line">    # 进程启动(thradpool配置，操作系统事件注册)</span><br><span class="line">    def start(self, stop_after_crawl=True):...</span><br><span class="line">    # 优雅退出，将退出添加到callback调用链条</span><br><span class="line">    def _graceful_stop_reactor(self):...</span><br><span class="line">    # 强制退出，直接退出reactor.stop()</span><br><span class="line">    def _stop_reactor(self, _=None):...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-Crawler-crawl-分析"><a href="#4-2-Crawler-crawl-分析" class="headerlink" title="4.2. Crawler.crawl 分析"></a>4.2. Crawler.crawl 分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@defer.inlineCallbacks</span><br><span class="line">def crawl(self, *args, **kwargs):</span><br><span class="line">    assert not self.crawling, &quot;Crawling already taking place&quot;</span><br><span class="line">    self.crawling = True</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        # 加载自己写的Spieder</span><br><span class="line">        self.spider = self._create_spider(*args, **kwargs)</span><br><span class="line">        # 加载 ExecutionEngine 引擎</span><br><span class="line">        self.engine = self._create_engine()</span><br><span class="line">        # 自己写的start_requests会被执行，没有就走父类默认的start_requests </span><br><span class="line">        # 位于./python3.6/site-packages/scrapy/spiders/__init__.py</span><br><span class="line">        start_requests = iter(self.spider.start_requests())</span><br><span class="line">        # 启动引擎</span><br><span class="line">        yield self.engine.open_spider(self.spider, start_requests)</span><br><span class="line">        # 启动接受控制台命令</span><br><span class="line">        yield defer.maybeDeferred(self.engine.start)</span><br><span class="line">    except Exception:</span><br><span class="line">        self.crawling = False</span><br><span class="line">        if self.engine is not None:</span><br><span class="line">            yield self.engine.close()</span><br><span class="line">        raise</span><br></pre></td></tr></table></figure><h3 id="4-3-ExecutionEngine-open-spider分析"><a href="#4-3-ExecutionEngine-open-spider分析" class="headerlink" title="4.3. ExecutionEngine.open_spider分析"></a>4.3. ExecutionEngine.open_spider分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@defer.inlineCallbacks</span><br><span class="line">def open_spider(self, spider, start_requests=(), close_if_idle=True):</span><br><span class="line">  assert self.has_capacity(), &quot;No free spider slot when opening %r&quot; % \</span><br><span class="line">      spider.name</span><br><span class="line">  logger.info(&quot;Spider opened&quot;, extra=&#123;&#x27;spider&#x27;: spider&#125;)</span><br><span class="line">  # 调度要在下一个reactor循环中调用的函数，但前提是该函数自上次运行以来尚未被调度</span><br><span class="line">  nextcall = CallLaterOnce(self._next_request, spider)</span><br><span class="line">  # 调度器加载</span><br><span class="line">  scheduler = self.scheduler_cls.from_crawler(self.crawler)</span><br><span class="line">  # 中间件处理MiddleWare</span><br><span class="line">  start_requests = yield self.scraper.spidermw.process_start_requests(start_requests, spider)</span><br><span class="line">  # engine核心</span><br><span class="line">  slot = Slot(start_requests, close_if_idle, nextcall, scheduler)</span><br><span class="line">  self.slot = slot</span><br><span class="line">  self.spider = spider</span><br><span class="line">  # 打开调度器</span><br><span class="line">  yield scheduler.open(spider)</span><br><span class="line">  yield self.scraper.open_spider(spider)</span><br><span class="line">  self.crawler.stats.open_spider(spider)</span><br><span class="line">  # 发送信号，spider可以启动了</span><br><span class="line">  yield self.signals.send_catch_log_deferred(signals.spider_opened, spider=spider)</span><br><span class="line">  # reactor调度开始</span><br><span class="line">  slot.nextcall.schedule()</span><br><span class="line">  # 官网解释：Start running function every interval seconds. 也即是nextcall.schedule</span><br><span class="line">  slot.heartbeat.start(5)</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><blockquote><p>看完以上代码流程，心中肯定会有如下一些疑问？</p></blockquote><ul><li>@defer.inlineCallbacks 的作用是什么？reactor又是如何异步轮询？</li><li>self.scraper.spidermw.process_start_requests 中间件是如何加载起作用的？</li><li>yield self.signals.send_catch_log_deferred 的运作原理是什么，究竟是如何启动爬虫的？</li><li>scheduler 调度器倒是如何被调度的？</li><li>scrapy middelware 又是如何起作用的？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫-scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openpyxl</title>
      <link href="/2025/05/18/python-%E6%A8%A1%E5%9D%97-openpyxl/"/>
      <url>/2025/05/18/python-%E6%A8%A1%E5%9D%97-openpyxl/</url>
      
        <content type="html"><![CDATA[<h1 id="Excel读写"><a href="#Excel读写" class="headerlink" title="Excel读写"></a>Excel读写</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># encoding: utf-8</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">--------------------------------------</span><br><span class="line">@describe Excel python 读取</span><br><span class="line">@version: 1.0</span><br><span class="line">@project: test</span><br><span class="line">@file: excel.py</span><br><span class="line">@author: yuanlang </span><br><span class="line">@time: 2019-03-12 14:53</span><br><span class="line">---------------------------------------</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from openpyxl.reader.excel import load_workbook</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class ExcelReader(object):</span><br><span class="line"></span><br><span class="line">    def reader_all_file(self,root_path):</span><br><span class="line">        path = os.listdir(root_path)</span><br><span class="line">        for file in path:</span><br><span class="line">            self.reader_file(root_path+&quot;/&quot;+file)</span><br><span class="line"></span><br><span class="line">    def reader_file(self,path):</span><br><span class="line">        # 读取excel2007文件</span><br><span class="line">        wb = load_workbook(filename=r&#x27;&#123;0&#125;&#x27;.format(path))</span><br><span class="line">        # 显示有多少张表</span><br><span class="line">        # print (&quot;Worksheet range(s):&quot;, wb.get_named_ranges())</span><br><span class="line">        # print (&quot;Worksheet name(s):&quot;, wb.get_sheet_names())</span><br><span class="line"></span><br><span class="line">        # 取第一张表</span><br><span class="line">        sheetnames = wb.sheetnames</span><br><span class="line">        ws = wb[sheetnames[0]]</span><br><span class="line"></span><br><span class="line">        # 显示表名，表行数，表列数</span><br><span class="line">        # print (&quot;Work Sheet Titile:&quot;, ws.title)</span><br><span class="line">        # print (&quot;Work Sheet Rows:&quot;, ws.max_row)</span><br><span class="line">        # print (&quot;Work Sheet Cols:&quot;, ws.max_column)</span><br><span class="line">        # 建立存储数据的字典</span><br><span class="line">        data_dic = &#123;&#125;</span><br><span class="line">        data_list = []</span><br><span class="line">        # 把数据存到字典中</span><br><span class="line">        for rx in range(1, ws.max_row + 1):</span><br><span class="line">            temp_list = []</span><br><span class="line">            pid = rx</span><br><span class="line">            w1 = ws.cell(row=rx, column=1).value</span><br><span class="line">            w2 = ws.cell(row=rx, column=2).value</span><br><span class="line">            w3 = ws.cell(row=rx, column=3).value</span><br><span class="line">            w4 = ws.cell(row=rx, column=4).value</span><br><span class="line">            temp_list = [w1, w2, w3, w4]</span><br><span class="line"></span><br><span class="line">            data_dic[pid] = temp_list</span><br><span class="line">            if w2 is not None or w3 is not None or w4 is not None:</span><br><span class="line">                if w4 != &#x27;市辖区&#x27; and w1 != &#x27;代码&#x27;:</span><br><span class="line">                    data_list.append(temp_list)</span><br><span class="line"></span><br><span class="line">        # 打印字典数据个数</span><br><span class="line">        # print (&#x27;Total:%d&#x27; % len(data_dic))</span><br><span class="line">        #print(data_list)</span><br><span class="line">        for _list in data_list:</span><br><span class="line">            if _list[3] is not None:</span><br><span class="line">                print(str(_list[0])[:6]+&quot;,&quot;+_list[3]+&quot;,&quot;+str(_list[0])[:3]+&quot;000&quot;)</span><br><span class="line">                # print (json.dumps(data_dic, encoding=&quot;UTF-8&quot;, ensure_ascii=False))</span><br><span class="line"></span><br><span class="line">reader=ExcelReader()</span><br><span class="line">reader.reader_all_file(os.path.dirname(__file__)+&quot;/5w放款名单-20190312.xlsx&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code-python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pymongo</title>
      <link href="/2025/05/18/python-%E6%A8%A1%E5%9D%97-pymongo/"/>
      <url>/2025/05/18/python-%E6%A8%A1%E5%9D%97-pymongo/</url>
      
        <content type="html"><![CDATA[<h1 id="mongodb-读写"><a href="#mongodb-读写" class="headerlink" title="mongodb 读写"></a>mongodb 读写</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import pymongo</span><br><span class="line">from scrapy import log</span><br><span class="line">from scrapy.conf import settings</span><br><span class="line">import threading</span><br><span class="line">from openpyxl import Workbook</span><br><span class="line">import redis</span><br><span class="line">from scrapy.pipelines.images import ImagesPipeline</span><br><span class="line">from scrapy.exceptions import DropItem</span><br><span class="line">import scrapy</span><br><span class="line">import pymysql</span><br><span class="line">from twisted.enterprise import adbapi</span><br><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"># Define your item pipelines here</span><br><span class="line">#</span><br><span class="line"># Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting</span><br><span class="line"># See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html</span><br><span class="line"># 单例模式创建MongoPipline</span><br><span class="line"></span><br><span class="line">Lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MongoPipeline(object):</span><br><span class="line">    # 定义静态变量实例</span><br><span class="line">    __instance = None</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not cls.__instance:</span><br><span class="line">            try:</span><br><span class="line">                Lock.acquire()</span><br><span class="line">                # double check</span><br><span class="line">                if not cls.__instance:</span><br><span class="line">                    cls.client = pymongo.MongoClient(settings[&#x27;MONGO_URI&#x27;])</span><br><span class="line">                    cls.db = cls.client[settings[&#x27;MONGO_DATABASE&#x27;]]</span><br><span class="line">                    cls.__instance = super(MongoPipeline, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">            finally:</span><br><span class="line">                Lock.release()</span><br><span class="line">        return cls.__instance</span><br><span class="line"></span><br><span class="line">    def dorp_connection(self,db_name):</span><br><span class="line">        #删除数据库</span><br><span class="line">        return self.db[db_name].drop()</span><br><span class="line"></span><br><span class="line">    def ensure_index(self,db_name,unique_id):</span><br><span class="line">        #建立索引</span><br><span class="line">        return self.db[db_name].ensure_index(unique_id,unique=True)</span><br><span class="line"></span><br><span class="line">    def insert(self, items, db_name):</span><br><span class="line">        self.db[db_name].insert(items)</span><br><span class="line"></span><br><span class="line">    def find(self,db_name,conditions,return_range):</span><br><span class="line">        return self.db[db_name].find(conditions,return_range)</span><br><span class="line"></span><br><span class="line">    def update(self,db_name,conditions,info):</span><br><span class="line">        return self.db[db_name].update(conditions,info,False)</span><br><span class="line"></span><br><span class="line">    def upsert(self,db_name,conditions,info):</span><br><span class="line">        return self.db[db_name].update(conditions,info,True)</span><br><span class="line"></span><br><span class="line">    def update_many(self,db_name,conditions,info):</span><br><span class="line">        return self.db[db_name].update_many(conditions,info,False)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code-python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy</title>
      <link href="/2025/05/18/python-%E6%A8%A1%E5%9D%97Numpy/"/>
      <url>/2025/05/18/python-%E6%A8%A1%E5%9D%97Numpy/</url>
      
        <content type="html"><![CDATA[<h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><p>1.<a href="https://www.toutiao.com/a6458488956890645005/">https://www.toutiao.com/a6458488956890645005/</a><br>2.<a href="https://www.toutiao.com/a6350804864013271298/">https://www.toutiao.com/a6350804864013271298/</a></p><p>数组属性方法总结</p><p>作用</p><p>1基本属性</p><p>a.dtype数组元素类型float32,uint8,…</p><p>a.shape数组形状(m,n,o,…)</p><p>a.size数组元素数</p><p>a.itemsize每个元素占字节数</p><p>a.nbytes所有元素占的字节</p><p>a.ndim数组维度</p><p>2形状相关</p><p>a.flat所有元素的迭代器</p><p>a.flatten()返回一个1维数组的复制</p><p>a.ravel()返回一个1维数组，高效</p><p>a.resize(new_size)改变形状</p><p>a.swapaxes(axis1, axis2)交换两个维度的位置</p><p>a.transpose(*axex)交换所有维度的位置</p><p>a.T转置，a.transpose()</p><p>a.squeeze()去除所有长度为1的维度</p><p>3填充复制</p><p>a.copy()返回数组的一个复制</p><p>a.fill(value)将数组的元组设置为特定值</p><p>4转化</p><p>a.tolist()将数组转化为列表</p><p>a.tostring()转换为字符串</p><p>a.astype(dtype)转化为指定类型</p><p>a.byteswap(False)转换大小字节序</p><p>a.view(type_or_dtype)生成一个使用相同内存，但使用不同的表示方法的数组</p><p>5复数</p><p>a.imag虚部</p><p>a.real实部</p><p>a.conjugate()复共轭</p><p>a.conj()复共轭（缩写）</p><p>6保存</p><p>a.dump(file)将二进制数据存在file中</p><p>a.dump()将二进制数据表示成字符串</p><p>a.tofile(fid, sep&#x3D;””,format&#x3D;”%s”)格式化ASCⅡ码写入文件</p><p>7查找排序</p><p>a.nonzero()返回所有非零元素的索引</p><p>a.sort(axis&#x3D;-1)沿某个轴排序</p><p>a.argsort(axis&#x3D;-1)沿某个轴，返回按排序的索引</p><p>a.searchsorted(b)返回将b中元素插入a后能保持有序的索引值</p><p>8元素数学操作</p><p>a.clip(low, high)将数值限制在一定范围内</p><p>a.round(decimals&#x3D;0)近似到指定精度</p><p>a.cumsum(axis&#x3D;None)累加和</p><p>a.cumprod(axis&#x3D;None)累乘积</p><p>9约简操作</p><p>a.sum(axis&#x3D;None)求和</p><p>a.prod(axis&#x3D;None)求积</p><p>a.min(axis&#x3D;None)最小值</p><p>a.max(axis&#x3D;None)最大值</p><p>a.argmin(axis&#x3D;None)最小值索引</p><p>a.argmax(axis&#x3D;None)最大值索引</p><p>a.ptp(axis&#x3D;None)最大值减最小值</p><p>a.mean(axis&#x3D;None)平均值</p><p>a.std(axis&#x3D;None)标准差</p><p>a.var(axis&#x3D;None)方差</p><p>a.any(axis&#x3D;None)只要有一个不为0，返回真，逻辑或</p><p>a.all(axis&#x3D;None)所有都不为0，返回真，逻辑与</p><p>案例《一》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#array=np.array([[1,2],[5,2]],dtype=np.float32)</span><br><span class="line"></span><br><span class="line">#array=np.zeros((3,4),dtype=np.int16)</span><br><span class="line"></span><br><span class="line">#array=np.empty((3,4))</span><br><span class="line"></span><br><span class="line">#array=np.arange(2,12,2)</span><br><span class="line"></span><br><span class="line">#array=np.arange(12).reshape((3,4))</span><br><span class="line"></span><br><span class="line">#array=np.linspace(2,10,4)</span><br><span class="line"></span><br><span class="line">#array=10*np.sin(array)</span><br><span class="line"></span><br><span class="line">#print(array&lt;2)</span><br><span class="line"></span><br><span class="line">#array2=np.arange(4).reshape((2,2))</span><br><span class="line"></span><br><span class="line">#print(np.dot(array,array2))</span><br></pre></td></tr></table></figure><p>#随机数求和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">array=np.random.random((2,4))</span><br><span class="line"></span><br><span class="line">print(array)</span><br><span class="line"></span><br><span class="line">#print(np.sum(array,axis=1))</span><br><span class="line"></span><br><span class="line">#print(np.min(array,axis=0))</span><br><span class="line"></span><br><span class="line">#print(np.max(array))</span><br><span class="line"></span><br><span class="line">#统计</span><br><span class="line"></span><br><span class="line">A=np.argmax(array)</span><br><span class="line"></span><br><span class="line">B=np.argmin(array)</span><br><span class="line"></span><br><span class="line">C=np.average(array)</span><br><span class="line"></span><br><span class="line">D=np.median(array) #中位数</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"></span><br><span class="line">print(np.diff(array))</span><br><span class="line"></span><br><span class="line">print(np.nonzero(array))</span><br><span class="line"></span><br><span class="line">print(np.sort(array))</span><br><span class="line"></span><br><span class="line">print(np.transpose(array)) #行列转换</span><br><span class="line"></span><br><span class="line">print(np.clip(A,5,9))</span><br><span class="line"></span><br><span class="line">print(np.mean(array,axis=1))</span><br></pre></td></tr></table></figure><p>案例《二》</p>]]></content>
      
      
      <categories>
          
          <category> code-python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib</title>
      <link href="/2025/05/18/python-%E6%A8%A1%E5%9D%97-Matplotlib/"/>
      <url>/2025/05/18/python-%E6%A8%A1%E5%9D%97-Matplotlib/</url>
      
        <content type="html"><![CDATA[<h3 id="一：基本知识"><a href="#一：基本知识" class="headerlink" title="一：基本知识"></a>一：基本知识</h3><ol><li><p>第一层是底层的容器层，主要包括Canvas（画板）、Figure（画布）、Axes（绘画区）</p></li><li><p>第二层是辅助显示层，主要包括Axis（坐标）、Spines（边框线）、Tick（刻度）、Grid（网格）、Legend（图例）、Title（标题）等</p></li><li><p>第三层为图像层，即通过plot（折线）、hist（直方图）、contour、bar（条形图）、barbs、scatter（散点），pie(饼图)等方法绘制的图像。</p></li></ol><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p><img src="https://wx4.sinaimg.cn/mw690/005EpKr8ly1g1dslzabgzj30gd0fnwfb.jpg" alt="image"></p><h5 id="绘图参数《一》"><a href="#绘图参数《一》" class="headerlink" title="绘图参数《一》"></a>绘图参数《一》</h5><p><img src="https://wx1.sinaimg.cn/mw690/005EpKr8ly1g1dslza6zmj30dz0hkjrw.jpg" alt="image"></p><h5 id="绘图参数《二》"><a href="#绘图参数《二》" class="headerlink" title="绘图参数《二》"></a>绘图参数《二》</h5><p><img src="https://wx1.sinaimg.cn/mw690/005EpKr8ly1g1dslzbha2j30ej04mmx1.jpg" alt="image"></p><h3 id="二-案例"><a href="#二-案例" class="headerlink" title="二.案例"></a>二.案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplotasplt</span><br><span class="line"></span><br><span class="line">importnumpyasnp</span><br><span class="line"></span><br><span class="line">fig=plt.figure()</span><br><span class="line"></span><br><span class="line">fig.set_figwidth(1200)</span><br><span class="line"></span><br><span class="line">########饼图############</span><br><span class="line"></span><br><span class="line">axes=fig.add_subplot(2,3,1)</span><br><span class="line"></span><br><span class="line">labels=&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;</span><br><span class="line"></span><br><span class="line">fracs=[15,30,45,10]</span><br><span class="line"></span><br><span class="line">axes.set_aspect(aspect=1)#plt.axes(aspect=1)使x y轴比例相同</span><br><span class="line"></span><br><span class="line">explode=[0,0.05,0,0]#突出某一部分区域</span><br><span class="line"></span><br><span class="line">axes.pie(x=fracs,labels=labels,autopct=&#x27;%.0f%%&#x27;,explode=explode)#autopct显示百分比</span><br><span class="line"></span><br><span class="line">########线图###########</span><br><span class="line"></span><br><span class="line">axes=fig.add_subplot(2,3,2)</span><br><span class="line"></span><br><span class="line">x=np.arange(1,5)</span><br><span class="line"></span><br><span class="line">y=x*2</span><br><span class="line"></span><br><span class="line">axes.plot(x,y)</span><br><span class="line"></span><br><span class="line">axes.grid(True,color=&#x27;g&#x27;,linestyle=&#x27;--&#x27;,linewidth=&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">#########多条线#########</span><br><span class="line"></span><br><span class="line">axes=fig.add_subplot(2,3,3)</span><br><span class="line"></span><br><span class="line">x=np.arange(1,11,1)</span><br><span class="line"></span><br><span class="line">axes.plot(x,x*2)</span><br><span class="line"></span><br><span class="line">axes.plot(x,x*3)</span><br><span class="line"></span><br><span class="line">axes.plot(x,x*4)</span><br><span class="line"></span><br><span class="line">axes.legend([&#x27;Normal&#x27;,&#x27;Fast&#x27;,&#x27;Faster&#x27;])</span><br><span class="line"></span><br><span class="line">########散点图##########</span><br><span class="line"></span><br><span class="line">axes=fig.add_subplot(2,3,4)</span><br><span class="line"></span><br><span class="line">x=np.random.randn(1000)</span><br><span class="line"></span><br><span class="line">y=x+np.random.randn(1000)*0.5</span><br><span class="line"></span><br><span class="line">axes.scatter(x,y,s=5,marker=&#x27;&lt;&#x27;)# s表示面积，marker表示图形</span><br><span class="line"></span><br><span class="line">#########条形图##########</span><br><span class="line"></span><br><span class="line">axes=fig.add_subplot(2,3,5)</span><br><span class="line"></span><br><span class="line">y=[20,10,40,25,15]</span><br><span class="line"></span><br><span class="line">index=np.arange(5)</span><br><span class="line"></span><br><span class="line">axes.bar(left=index,height=y,color=&#x27;green&#x27;)</span><br><span class="line"></span><br><span class="line">#########箱形图##########</span><br><span class="line"></span><br><span class="line">axes=fig.add_subplot(2,3,6)</span><br><span class="line"></span><br><span class="line">data=np.random.normal(size=(1000,4),loc=0,scale=1)#标准整体分布</span><br><span class="line"></span><br><span class="line">labels=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;]</span><br><span class="line"></span><br><span class="line">axes.boxplot(data,labels=labels)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">#########直方图##########</span><br><span class="line"></span><br><span class="line">mu=100</span><br><span class="line"></span><br><span class="line">sigma=20</span><br><span class="line"></span><br><span class="line">x=mu+sigma*np.random.randn(20000)#样本数量</span><br><span class="line"></span><br><span class="line">plt.hist(x,bins=100,color=&#x27;green&#x27;,normed=True)# bins显示有几个直方,normed是否对数据进行标准化</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">#########等高线##########</span><br><span class="line"></span><br><span class="line">#定义等高线图的横纵坐标x，y</span><br><span class="line"></span><br><span class="line">#从左边取值为从-3到3，各取5个点，一共取5*5 = 25个点</span><br><span class="line"></span><br><span class="line">x=np.linspace(-3,3,5)</span><br><span class="line"></span><br><span class="line">y=np.linspace(-3,3,5)</span><br><span class="line"></span><br><span class="line">#将原始数据变成网格数据</span><br><span class="line"></span><br><span class="line">X, Y=np.meshgrid(x, y)</span><br><span class="line"></span><br><span class="line">#各地点对应的高度数据</span><br><span class="line"></span><br><span class="line">#Height是个5*5的数组，记录地图上25个点的高度汇总</span><br><span class="line"></span><br><span class="line">Height= [[0,0,1,2,2],[0,-2,-2,1,5],[4,2,6,8,1],[3,-3,-3,0,5],[1,-5,-2,0,3]]</span><br><span class="line"></span><br><span class="line">#填充颜色</span><br><span class="line"></span><br><span class="line">plt.contourf(X, Y, Height,10,alpha=0.6,cmap=plt.cm.hot)</span><br><span class="line"></span><br><span class="line">#绘制等高线</span><br><span class="line"></span><br><span class="line">C=plt.contour(X, Y, Height,10,colors=&#x27;black&#x27;,linewidth=0.5)</span><br><span class="line"></span><br><span class="line">#显示各等高线的数据标签</span><br><span class="line"></span><br><span class="line">plt.clabel(C,inline=True,fontsize=10)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://wx2.sinaimg.cn/mw690/005EpKr8ly1g1dslza9qrj30hs0dcab2.jpg" alt="image"><br>figure布局<br><img src="https://wx1.sinaimg.cn/mw690/005EpKr8ly1g1dslz9qg1j30hs0dcdfn.jpg" alt="image"><br>figure图2<br><img src="https://wx1.sinaimg.cn/mw690/005EpKr8ly1g1dslzaknuj30hs0dcq4n.jpg" alt="image"><br>figure图3</p><h3 id="三-自定义函数图形"><a href="#三-自定义函数图形" class="headerlink" title="三.自定义函数图形"></a>三.自定义函数图形</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">importmatplotlib.pyplotasplt</span><br><span class="line"></span><br><span class="line">importnumpyasnp</span><br><span class="line"></span><br><span class="line">x=np.linspace(-3,3,50)</span><br><span class="line"></span><br><span class="line">y1=2*x+1</span><br><span class="line"></span><br><span class="line">y2=x**2</span><br><span class="line"></span><br><span class="line"># plt.figure()</span><br><span class="line"></span><br><span class="line"># plt.plot(x,y1)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">l1=plt.plot(x,y2,label=&#x27;up&#x27;)</span><br><span class="line"></span><br><span class="line">l2=plt.plot(x,y1,color=&#x27;red&#x27;,linewidth=1.0,linestyle=&#x27;--&#x27;,label=&#x27;down&#x27;)</span><br><span class="line"></span><br><span class="line">plt.xlim((-1,2))</span><br><span class="line"></span><br><span class="line">plt.ylim((-3,5))</span><br><span class="line"></span><br><span class="line">plt.ylabel(&#x27;I am y&#x27;)</span><br><span class="line"></span><br><span class="line">plt.xlabel(&#x27;I am x&#x27;)</span><br><span class="line"></span><br><span class="line">new_ticks=np.linspace(-1,2,5)</span><br><span class="line"></span><br><span class="line">print(new_ticks)</span><br><span class="line"></span><br><span class="line">plt.xticks(new_ticks)</span><br><span class="line"></span><br><span class="line">plt.yticks([-2,-1.8,-1,1,3],[r&#x27;$re\ bad$&#x27;,r&#x27;$re2\alpha$&#x27;,r&#x27;$re3$&#x27;,&#x27;re4&#x27;,&#x27;re5&#x27;])</span><br><span class="line"></span><br><span class="line">ax=plt.gca()</span><br><span class="line"></span><br><span class="line">ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)</span><br><span class="line"></span><br><span class="line">ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)</span><br><span class="line"></span><br><span class="line">#ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)</span><br><span class="line"></span><br><span class="line">#ax.yaxis.set_ticks_position(&#x27;left&#x27;)</span><br><span class="line"></span><br><span class="line">ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;,0))</span><br><span class="line"></span><br><span class="line">ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;,0))</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">#plt.legend(handles=[l1,],labels=[&#x27;aa&#x27;,],loc=&#x27;best&#x27;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://wx3.sinaimg.cn/mw690/005EpKr8ly1g1dslzamsej30hs0dcq3b.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> code-python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-源码阅读(1)-python代码编译</title>
      <link href="/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(1)-python%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(1)-python%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="python-源码编译"><a href="#python-源码编译" class="headerlink" title="python 源码编译"></a>python 源码编译</h1><ol><li>PyTokenizer_FromFile函数位于Parser&#x2F;parsetok.c从左到右扫描python源文件，从上到下标记文件的内容</li><li>解析树生成规则都在Include&#x2F;token.h（终端）和Include&#x2F;graminit.h（终端）头文件中指定</li><li>PyAST_FromNode函数Python&#x2F;ast.c处理从给定的解析树生成AST。生成AST后，现在可以从AST生成字节码了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import parser</span><br><span class="line">cst = parser.suite(&#x27;print &quot;Hello World&quot;&#x27;)</span><br><span class="line">print cst.tolist()</span><br><span class="line"># [257, [267, [268, [269, [272, [1, &#x27;print&#x27;], [304, [305, [306, [307, [308, [310, [311, [312, [313, [314, [315, [316, [317, [318, [3, &#x27;&quot;Hello World&quot;&#x27;]]]]]]]]]]]]]]]]], [4, &#x27;&#x27;]]], [4, &#x27;&#x27;], [0, &#x27;&#x27;]]</span><br><span class="line"> </span><br><span class="line">import ast</span><br><span class="line">astrst = ast.parse(&#x27;print &quot;Hello World&quot;&#x27;)</span><br><span class="line">print ast.dump(astrst)</span><br><span class="line"># Module(body=[Print(dest=None, values=[Str(s=&#x27;Hello World&#x27;)], nl=True)])</span><br></pre></td></tr></table></figure></li><li>构建符号表（不懂）作用域相关识别</li><li>从AST到代码对象(表达式是中序遍历，在计算机运算是采用后序遍历) pyc</li></ol><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>Python的整体架构可分为3个模块,一个是内建模块. 一个是python内核, 一个是python虚拟机.</p><p>内建模块就诸如 import os 时,这个os就是Python的内建模块.Python内核就包括定义Python的对象&#x2F;类型系统,处理垃圾回收机制等.虚拟机就是解释器,对Python代码进行词法语法分析等.</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-源码阅读(2)-pyObject</title>
      <link href="/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(2)-pyObject/"/>
      <url>/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(2)-pyObject/</url>
      
        <content type="html"><![CDATA[<h1 id="pyObject"><a href="#pyObject" class="headerlink" title="pyObject"></a>pyObject</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[object.h]</span><br><span class="line">typedef struct _object &#123;</span><br><span class="line">    # Py_DEBUG implies Py_TRACE_REFS</span><br><span class="line">    # Py_TRACE_REFS 则对象结构会变成是一个双向列表, 所有堆中活动的对象都在这列表中,Py_TRACE_REFS 则对象结构会变成是一个双向列表,所有堆中活动的对象都在这列表中,与debug相关</span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line"></span><br><span class="line">    # typedef int Py_ssize_t;</span><br><span class="line">    # ob_refcnt 为int类型的应用计数</span><br><span class="line">    Py_ssize_t ob_refcnt; </span><br><span class="line"></span><br><span class="line">    # type 结构体</span><br><span class="line">    struct _typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">[typestruct.h]</span><br><span class="line">typedef struct _typeobject &#123;</span><br><span class="line"></span><br><span class="line">    # 扩展 ob_size 为对象提供长度的概念</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line"></span><br><span class="line">    # 开发引用的</span><br><span class="line">    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span><br><span class="line"></span><br><span class="line">    # 计算该类型实例的字节大小</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */</span><br><span class="line"></span><br><span class="line">    /* Methods to implement standard operations */</span><br><span class="line"></span><br><span class="line">    # 指向实例析构函数的指针</span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line"></span><br><span class="line">    # 保留插槽，以前用于Python 2.x中的打印格式。</span><br><span class="line">    printfunc tp_print;</span><br><span class="line"></span><br><span class="line">    # 指向get-attribute-string函数的可选指针。</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line"></span><br><span class="line">    # 指向get-attribute-string函数的可选指针。</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line"></span><br><span class="line">    # 指向另一个结构的指针</span><br><span class="line">    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)</span><br><span class="line">                                    or tp_reserved (Python 3) */</span><br><span class="line">    # 指向实现内置函数的函数的可选指针 repr()。</span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    /* Method suites for standard classes */</span><br><span class="line"></span><br><span class="line">    # 该结构包含仅与实现数字协议的对象相关的字段</span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line"></span><br><span class="line">    # 该结构包含仅与实现数字协议的对象相关的字段</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line"></span><br><span class="line">    # 该结构包含仅与实现数字协议的对象相关的字段</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    /* More standard operations (here for binary compatibility) */</span><br><span class="line"></span><br><span class="line">    # 指向实现内置函数的函数的可选指针 hash()。</span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    /* Functions to access object as input/output buffer */</span><br><span class="line">    # 结构包含仅与实现缓冲区接口的对象相关的字段</span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    /* Flags to define presence of optional/expanded features */</span><br><span class="line">    # 如果这样的标志位是清除的，则不能访问它所保护的类型字段，</span><br><span class="line">    unsigned long tp_flags;</span><br><span class="line"></span><br><span class="line">    const char *tp_doc; /* Documentation string */</span><br><span class="line"></span><br><span class="line">    /* call function for all accessible objects */</span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    /* delete references to contained objects */</span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    /* rich comparisons */</span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    /* weak reference enabler */</span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    /* Iterators */</span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    /* Attribute descriptor and subclassing stuff */</span><br><span class="line">    struct PyMethodDef *tp_methods;</span><br><span class="line">    struct PyMemberDef *tp_members;</span><br><span class="line">    struct PyGetSetDef *tp_getset;</span><br><span class="line">    struct _typeobject *tp_base;</span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; /* Low-level free-memory routine */</span><br><span class="line">    inquiry tp_is_gc; /* For PyObject_IS_GC */</span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; /* method resolution order */</span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    /* Type attribute cache version tag. Added in version 2.6 */</span><br><span class="line">    unsigned int tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><pre><code>这些字段中还包括其他python协议的字段，如下所示。1.数字协议 - 实现此协议的类型将具有PyNumberMethods *tp_as_number 字段的实现。此字段是对一组实现数字操作的函数的引用，这意味着该类型将支持具有包含在tp_as_number 集合中的实现的算法。例如，非数字set类型在此字段中有一个条目，因为它支持算术运算，例如-，&lt;=等等。2.序列协议 - 实现此协议的类型将在PySequenceMethods *tp_as_sequence 字段中具有值。这意味着该类型将支持部分或全部的的序列的操作 ，例如len，in等3.映射协议 - 实现此协议的类型将具有一个值PyMappingMethods *tp_as_mapping。这将使这种类型的实例像python词典一样使用字典下标语法来设置和访问键值映射。4.迭代器协议 - 实现此协议的类型将在getiterfunc tp_iter 可能的iternextfunc tp_iternext字段中具有值，并且可以使用类型的实例，如python迭代器。5.缓冲协议 - 实现此协议的类型将在该PyBufferProcs *tp_as_buffer 字段中具有值。这些函数将允许访问类型的实例作为输入/输出缓冲区。</code></pre><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>源码中, 通过 Py_INCREF(op) 和 Py_DECREF(op) 两个宏来增加和较少引用计数的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[object.h]</span><br><span class="line"></span><br><span class="line">#define Py_INCREF(op) (                         \</span><br><span class="line">    ((PyObject *)(op))-&gt;ob_refcnt++)</span><br><span class="line"></span><br><span class="line">#define Py_DECREF(op)                                   \</span><br><span class="line">    do &#123;                                                \</span><br><span class="line">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</span><br><span class="line">        if (--(_py_decref_tmp)-&gt;ob_refcnt != 0)             \</span><br><span class="line">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span><br><span class="line">        else                                            \</span><br><span class="line">            _Py_Dealloc(_py_decref_tmp);                \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure><p>当一个对象的引用计数减少到0后,Py_DECREF(op)会调用该对象”析构函数”进行释放.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define _Py_Dealloc(op) (                               \</span><br><span class="line">(*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-源码阅读(4)-python字节码</title>
      <link href="/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(4)-python%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(4)-python%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="PyCodeObject-虚拟机运行时，常量，环境，字节码信息"><a href="#PyCodeObject-虚拟机运行时，常量，环境，字节码信息" class="headerlink" title="PyCodeObject (虚拟机运行时，常量，环境，字节码信息)"></a>PyCodeObject (虚拟机运行时，常量，环境，字节码信息)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* code.h */</span><br><span class="line">/* Bytecode object */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int co_argcount;        /* #arguments, except *args */</span><br><span class="line">    int co_nlocals;     /* #local variables */</span><br><span class="line">    int co_stacksize;       /* #entries needed for evaluation stack */</span><br><span class="line">    int co_flags;       /* CO_..., see below */</span><br><span class="line">    PyObject *co_code;      /* instruction opcodes */</span><br><span class="line">    PyObject *co_consts;    /* list (constants used) */</span><br><span class="line">    PyObject *co_names;     /* list of strings (names used) */</span><br><span class="line">    PyObject *co_varnames;  /* tuple of strings (local variable names) */</span><br><span class="line">    PyObject *co_freevars;  /* tuple of strings (free variable names) */</span><br><span class="line">    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */</span><br><span class="line">    /* The rest doesn&#x27;t count for hash/cmp */</span><br><span class="line">    PyObject *co_filename;  /* string (where it was loaded from) */</span><br><span class="line">    PyObject *co_name;      /* string (name, for reference) */</span><br><span class="line">    int co_firstlineno;     /* first source line number */</span><br><span class="line">    PyObject *co_lnotab;    /* string (encoding addr&lt;-&gt;lineno mapping) See Objects/lnotab_notes.txt for details. */</span><br><span class="line">    void *co_zombieframe;     /* for optimization only (see frameobject.c) */</span><br><span class="line">    PyObject *co_weakreflist;   /* to support weakrefs to code objects */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure><h1 id="pyc文件（PyCodeObject持久化）"><a href="#pyc文件（PyCodeObject持久化）" class="headerlink" title="pyc文件（PyCodeObject持久化）"></a>pyc文件（PyCodeObject持久化）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*import.c*/</span><br><span class="line">static void write_compiled_module(PyCodeObject *co, char *cpathname, struct stat *srcstat, time_t mtime)</span><br><span class="line">&#123;</span><br><span class="line">    PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    /* First write a 0 for mtime */</span><br><span class="line">    PyMarshal_WriteLongToFile(0L, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1           0 LOAD_CONST               0 (&#x27;A&#x27;)</span><br><span class="line">              3 LOAD_NAME                0 (object)</span><br><span class="line">              6 BUILD_TUPLE              1</span><br><span class="line">              9 LOAD_CONST               1 (&lt;code object A at 0x7f993a73adb0, file &quot;demo.py&quot;, line 1&gt;)</span><br><span class="line">             12 MAKE_FUNCTION            0</span><br><span class="line">             15 CALL_FUNCTION            0</span><br><span class="line">             18 BUILD_CLASS         </span><br><span class="line">             19 STORE_NAME               1 (A)</span><br><span class="line"></span><br><span class="line">  4          22 LOAD_CONST               2 (&lt;code object func at 0x7f993a662a30, file &quot;demo.py&quot;, line 4&gt;)</span><br><span class="line">             25 MAKE_FUNCTION            0</span><br><span class="line">             28 STORE_NAME               2 (func)</span><br><span class="line"></span><br><span class="line">  9          31 LOAD_NAME                1 (A)</span><br><span class="line">             34 CALL_FUNCTION            0</span><br><span class="line">             37 STORE_NAME               3 (a)</span><br><span class="line"></span><br><span class="line"> 10          40 LOAD_NAME                2 (func)</span><br><span class="line">             43 CALL_FUNCTION            0</span><br><span class="line">             46 POP_TOP             </span><br><span class="line">             47 LOAD_CONST               3 (None)</span><br><span class="line">             50 RETURN_VALUE  </span><br><span class="line"></span><br><span class="line">注：左边第一列代表指令对应源码中的行号. 第二列代表当前字节码再co_code中的偏移量, 第三列是当前的字节码指令, 最后一列是当前字节码指令的参数.</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>pyc文件是对PyCodeObject的持久化，存放在硬盘，包含了除字节码意外的其他参数。每次执行后会将pyCodeObject持久化下来 使用 python demo.py启动脚步，若demo.py中无import 不会持久化</li></ol><h1 id="PyFrameObject"><a href="#PyFrameObject" class="headerlink" title="PyFrameObject"></a>PyFrameObject</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[frameobject.h]</span><br><span class="line">typedef struct _frame &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    struct _frame *f_back;      // 执行环境链的上一个frame</span><br><span class="line">    PyCodeObject *f_code;       // PyCodeObject对象</span><br><span class="line">    PyObject *f_builtins;       // builtin名字空间</span><br><span class="line">    PyObject *f_globals;        // global 名字空间</span><br><span class="line">    PyObject *f_locals;         // local 名字空间</span><br><span class="line">    PyObject **f_valuestack;    // 运行栈的栈底</span><br><span class="line">    PyObject **f_stacktop;      // 运行栈的栈顶</span><br><span class="line">    PyObject *f_trace;          // 异常时调用的句柄</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    int f_lasti;                // 上一条字节码指令在f_code中的偏移位置</span><br><span class="line">    int f_lineno;               // 当前字节码对应的源代码行</span><br><span class="line">    int f_iblock;               // 当前指令在栈f_blockstack中的索引</span><br><span class="line">    ...</span><br><span class="line">    PyObject *f_localsplus[1];  // locals+stack, 动态内存, 维护(局部变量+运行时栈)所需要的空间 */</span><br><span class="line">&#125; PyFrameObject;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>python只有一个interpreter, 其中维护了一个或多个PyThreadState对象, 这些对象对应的线程轮流使用一个字节码执行引擎. 为了实现线程同步, python通过一个全局解释器锁GIL.</li><li>线程执行栈帧（PyFrameObject）,PyFrameObject 对象也是一个变长对象, 每次创建PyFrameObject对象的大小可能是不一样的. 每个栈帧对象都维护了一个PyCodeObject对象,f_builtins, f_globals 和 f_locals 是3个独立的名字空间,</li><li>LOAD_NAME 将以此从local, global, builtin 3个名字空间顺序查找, 如果都没找到说明名字未定义, 抛出异常, 终止python虚拟机的运行. 搜索规则也就是 LGB 规则.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 有删改</span><br><span class="line">TARGET(LOAD_NAME) &#123;</span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    PyObject *locals = f-&gt;f_locals;</span><br><span class="line">    PyObject *v;</span><br><span class="line"></span><br><span class="line">    v = PyDict_GetItem(locals, name);</span><br><span class="line">    Py_XINCREF(v);</span><br><span class="line"></span><br><span class="line">    if (v == NULL) &#123;</span><br><span class="line">        v = PyDict_GetItem(f-&gt;f_globals, name);</span><br><span class="line">        Py_XINCREF(v);</span><br><span class="line">        if (v == NULL) &#123;</span><br><span class="line">            v = PyDict_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">            if (v == NULL) &#123;</span><br><span class="line">                format_exc_check_arg(</span><br><span class="line">                            PyExc_NameError,</span><br><span class="line">                            NAME_ERROR_MSG, name);</span><br><span class="line">                goto error;</span><br><span class="line">            &#125;</span><br><span class="line">            Py_INCREF(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(v);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>python的异常机制处理中, 最重要的是why所表示的虚拟机状态及PyFrameObject对象中f_blockstack里存放的PyTryBlock对象. 变量why将指明python虚拟机当前是否发生了异常, 而PyTryBlock对象则指示程序员是否为异常设置了 except 代码块和 finally 代码块. python虚拟机处理异常的过程就是 why 和 PyTryBlock 的共同作用下完成的.<br><img src="https://wx3.sinaimg.cn/mw690/005EpKr8ly1g4dftzrftnj30jw0l1jw2.jpg" alt="except"></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-源码阅读(3)-python中基本类型</title>
      <link href="/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(3)-python%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(3)-python%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;int&quot;,                                      /* tp_name */</span><br><span class="line">    offsetof(PyLongObject, ob_digit),           /* tp_basicsize */</span><br><span class="line">    sizeof(digit),                              /* tp_itemsize */</span><br><span class="line">    long_dealloc,                               /* tp_dealloc */</span><br><span class="line">    0,                                          /* tp_print */</span><br><span class="line">    0,                                          /* tp_getattr */</span><br><span class="line">    0,                                          /* tp_setattr */</span><br><span class="line">    0,                                          /* tp_reserved */</span><br><span class="line">    long_to_decimal_string,                     /* tp_repr */</span><br><span class="line">    &amp;long_as_number,                            /* tp_as_number */</span><br><span class="line">    0,                                          /* tp_as_sequence */</span><br><span class="line">    0,                                          /* tp_as_mapping */</span><br><span class="line">    (hashfunc)long_hash,                        /* tp_hash */</span><br><span class="line">    0,                                          /* tp_call */</span><br><span class="line">    long_to_decimal_string,                     /* tp_str */</span><br><span class="line">    PyObject_GenericGetAttr,                    /* tp_getattro */</span><br><span class="line">    0,                                          /* tp_setattro */</span><br><span class="line">    0,                                          /* tp_as_buffer */</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               /* tp_flags */</span><br><span class="line">    long_doc,                                   /* tp_doc */</span><br><span class="line">    0,                                          /* tp_traverse */</span><br><span class="line">    0,                                          /* tp_clear */</span><br><span class="line">    long_richcompare,                           /* tp_richcompare */</span><br><span class="line">    0,                                          /* tp_weaklistoffset */</span><br><span class="line">    0,                                          /* tp_iter */</span><br><span class="line">    0,                                          /* tp_iternext */</span><br><span class="line">    long_methods,                               /* tp_methods */</span><br><span class="line">    0,                                          /* tp_members */</span><br><span class="line">    long_getset,                                /* tp_getset */</span><br><span class="line">    0,                                          /* tp_base */</span><br><span class="line">    0,                                          /* tp_dict */</span><br><span class="line">    0,                                          /* tp_descr_get */</span><br><span class="line">    0,                                          /* tp_descr_set */</span><br><span class="line">    0,                                          /* tp_dictoffset */</span><br><span class="line">    0,                                          /* tp_init */</span><br><span class="line">    0,                                          /* tp_alloc */</span><br><span class="line">    long_new,                                   /* tp_new */</span><br><span class="line">    PyObject_Del,                               /* tp_free */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>python3统一采用长整型8 bit</li><li>id() 内存地址; is 是判断内存地址id是否相等，&#x3D;&#x3D;判断内容是否相等</li><li>相同代码块的缓存机制 int str bool 使用相同的常量池对象</li><li>在不同代码块下，采用小整数驻留机制[-5,256]</li><li>该tp_new函数应该调用subtype-&gt;tp_alloc(subtype, nitems)为对象分配空间。于不可变类型，所有初始化都应该在tp_new，而对于可变类型，大多数初始化应该延迟到tp_init。</li></ol><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyUnicode_FromString(const char *u)</span><br><span class="line">&#123;</span><br><span class="line">    size_t size = strlen(u);</span><br><span class="line">    if (size &gt; PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, &quot;input too long&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return PyUnicode_DecodeUTF8Stateful(u, (Py_ssize_t)size, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>字符串对象的共享机制intern</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"># 字符串创建</span><br><span class="line">void PyUnicode_InternInPlace(PyObject **p)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *s = *p;</span><br><span class="line">    PyObject *t;</span><br><span class="line"></span><br><span class="line">    if (s == NULL || !PyUnicode_Check(s))</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 对PyUnicodeObjec进行类型和状态检查</span><br><span class="line">    if (!PyUnicode_CheckExact(s))</span><br><span class="line">        return;</span><br><span class="line">    if (PyUnicode_CHECK_INTERNED(s))</span><br><span class="line">        return;</span><br><span class="line">    // 创建intern机制的dict</span><br><span class="line">    if (interned == NULL) &#123;</span><br><span class="line">        interned = PyDict_New();</span><br><span class="line">        if (interned == NULL) &#123;</span><br><span class="line">            PyErr_Clear(); /* Don&#x27;t leave an exception */</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对象是否存在于inter中</span><br><span class="line">    t = PyDict_SetDefault(interned, s, s);</span><br><span class="line"></span><br><span class="line">    // 存在， 调整引用计数</span><br><span class="line">    if (t != s) &#123;</span><br><span class="line">        Py_INCREF(t);</span><br><span class="line">        Py_SETREF(*p, t);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /* The two references in interned are not counted by refcnt.</span><br><span class="line">       The deallocator will take care of this */</span><br><span class="line">    Py_REFCNT(s) -= 2;</span><br><span class="line">    _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[unicodeobjec.c]</span><br><span class="line">PyObject * PyUnicode_DecodeUTF8Stateful(const char *s,</span><br><span class="line">                             Py_ssize_t size,</span><br><span class="line">                             const char *errors,</span><br><span class="line">                             Py_ssize_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* ASCII is equivalent to the first 128 ordinals in Unicode. */</span><br><span class="line">    if (size == 1 &amp;&amp; (unsigned char)s[0] &lt; 128) &#123;</span><br><span class="line">        if (consumed)</span><br><span class="line">            *consumed = 1;</span><br><span class="line">        return get_latin1_char((unsigned char)s[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">static PyObject *unicode_latin1[256] = &#123;NULL&#125;;</span><br><span class="line">static PyObject* get_latin1_char(unsigned char ch)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *unicode = unicode_latin1[ch];</span><br><span class="line">    if (!unicode) &#123;</span><br><span class="line">        unicode = PyUnicode_New(1, ch);</span><br><span class="line">        if (!unicode)</span><br><span class="line">            return NULL;</span><br><span class="line">        PyUnicode_1BYTE_DATA(unicode)[0] = ch;</span><br><span class="line">        assert(_PyUnicode_CheckConsistency(unicode, 1));</span><br><span class="line">        unicode_latin1[ch] = unicode;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(unicode);</span><br><span class="line">    return unicode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总结：先对所创建的字符串（只有一个字符）对象进行intern操作，再将inter的结果缓存到字符缓冲池 unicode_latin1 中,两者都是指向同一个字符对象。</span><br></pre></td></tr></table></figure></li><li><p>intern机制中的PyUnicodObject采用了特殊的引用计数机制。将一个PyUnicodeObject对象a的PyObject指针作为key和valu添加到intered中时，PyDictObjec对象会通过这两个指针对a的引用计数进行两次+1操作。这会造成a的引用计数在python程序结束前永远不会为0，这也是 Py_REFCNT(s) -&#x3D; 2; 将计数减2的原因。</p></li><li><p>字符串对象有两种状态，一个是 SSTATE_INTERNED_IMMORTAL 另一个是 SSTATE_INTERNED_MORTAL， 处于SSTATE_INTERNED_IMMORTAL这种状态的字符串永远不会被销毁，它将与python虚拟机共存亡。 PyUnicode_InternInPlace 函数只能创建SSTATE_INTERNED_MORTAL 状态的对象</p></li><li><p>python中使用 “+” 符号进行字符串拼接， 这种方法效率极低，建议使用jion</p></li></ol><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    // ob_item为指向元素列表的指针，实际上python中list[0]就是ob_item[0]</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br><span class="line"></span><br><span class="line">PyObject * PyList_New(Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *op;</span><br><span class="line">    ...</span><br><span class="line">    // 缓冲池是否可用</span><br><span class="line">    if (numfree) &#123;</span><br><span class="line">        numfree--;</span><br><span class="line">        op = free_list[numfree];</span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 缓冲池不可用时</span><br><span class="line">        op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">        if (op == NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // 申请为PyListObject对象中维护的元素列表空间</span><br><span class="line">    if (size &lt;= 0)</span><br><span class="line">        op-&gt;ob_item = NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 空间申请size个空间的数组并重置0</span><br><span class="line">        op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_SIZE(op) = size;</span><br><span class="line">    op-&gt;allocated = size;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>缓冲池 free_list 中最多会维护80个PyListObject对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PyList_MAXFREELIST 80</span><br><span class="line">static PyListObject *free_list[PyList_MAXFREELIST];</span><br><span class="line">static int numfree = 0;</span><br></pre></td></tr></table></figure></li><li>设置元素 list[2] &#x3D; 200<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int PyList_SetItem(PyObject *op, Py_ssize_t i,</span><br><span class="line">               PyObject *newitem)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject **p;</span><br><span class="line"></span><br><span class="line">    // 索引越界检查</span><br><span class="line">    if (i &lt; 0 || i &gt;= Py_SIZE(op)) &#123;</span><br><span class="line">        Py_XDECREF(newitem);</span><br><span class="line">        PyErr_SetString(PyExc_IndexError,</span><br><span class="line">                        &quot;list assignment index out of range&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到ob_item[i]</span><br><span class="line">    p = ((PyListObject *)op) -&gt; ob_item + i;</span><br><span class="line">    Py_XSETREF(*p, newitem);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define Py_XSETREF(op, op2)                     \</span><br><span class="line">    do &#123;                                        \</span><br><span class="line">        PyObject *_py_tmp = (PyObject *)(op);   \</span><br><span class="line">        (op) = (op2);                           \</span><br><span class="line">        Py_XDECREF(_py_tmp);                    \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure></li><li>插入元素<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[longobject.c]</span><br><span class="line">int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem)</span><br><span class="line">&#123;</span><br><span class="line">    // 类型检查</span><br><span class="line">    if (!PyList_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ins1((PyListObject *)op, where, newitem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">ins1(PyListObject *self, Py_ssize_t where, PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i, n = Py_SIZE(self);</span><br><span class="line">    PyObject **items;</span><br><span class="line"></span><br><span class="line">    if (list_resize(self, n+1) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    // 确定插入点</span><br><span class="line">    if (where &lt; 0) &#123;</span><br><span class="line">        where += n;</span><br><span class="line">        if (where &lt; 0)</span><br><span class="line">            where = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (where &gt; n)</span><br><span class="line">        where = n;</span><br><span class="line">    items = self-&gt;ob_item;</span><br><span class="line">    // 元素后移</span><br><span class="line">    for (i = n; --i &gt;= where; )</span><br><span class="line">        items[i+1] = items[i];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    items[where] = v;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>删除元素<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">listremove(PyListObject *self, PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);</span><br><span class="line">        // 如果相等, 删除元素</span><br><span class="line">        if (cmp &gt; 0) &#123;</span><br><span class="line">            if (list_ass_slice(self, i, i+1,</span><br><span class="line">                               (PyObject *)NULL) == 0)</span><br><span class="line">                Py_RETURN_NONE;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (cmp &lt; 0)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_SetString(PyExc_ValueError, &quot;list.remove(x): x not in list&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h1><p>闭散列法也称为开放定址法.当产生冲突时,python会通过一个二次探测函数f,计算下一个候选索引, 如果索引不可用,就再次用f探测.直到找到一个可用的位置.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[dict-common.h]</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value;</span><br><span class="line">&#125; PyDictKeyEntry;</span><br><span class="line"></span><br><span class="line">[dictobject.h]</span><br><span class="line">PyObject * PyDict_New(void)</span><br><span class="line">&#123;</span><br><span class="line">    PyDictKeysObject *keys = new_keys_object(PyDict_MINSIZE);</span><br><span class="line">    if (keys == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    return new_dict(keys, NULL);</span><br><span class="line">&#125;</span><br><span class="line">static PyDictKeysObject *new_keys_object(Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    Py_ssize_t es, usable;</span><br><span class="line"></span><br><span class="line">    usable = USABLE_FRACTION(size);</span><br><span class="line">    es = 4;</span><br><span class="line"></span><br><span class="line">    if (size == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; 0) &#123;</span><br><span class="line">        // 使用缓冲池</span><br><span class="line">        dk = keys_free_list[--numfreekeys];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        dk = PyObject_MALLOC(sizeof(PyDictKeysObject)</span><br><span class="line">                             - Py_MEMBER_SIZE(PyDictKeysObject, dk_indices)</span><br><span class="line">                             + es * size</span><br><span class="line">                             + sizeof(PyDictKeyEntry) * usable);</span><br><span class="line">    &#125;</span><br><span class="line">    DK_DEBUG_INCREF dk-&gt;dk_refcnt = 1;</span><br><span class="line">    dk-&gt;dk_size = size;</span><br><span class="line">    dk-&gt;dk_usable = usable;</span><br><span class="line">    dk-&gt;dk_lookup = lookdict_unicode_nodummy;</span><br><span class="line">    dk-&gt;dk_nentries = 0;</span><br><span class="line">    // hash table 初始化</span><br><span class="line">    memset(&amp;dk-&gt;dk_indices.as_1[0], 0xff, es * size);</span><br><span class="line">    memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable);</span><br><span class="line">    return dk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>PyDict_MINSIZE 值为8, 默认情况下, PyDict_New会创建8个entry</p></li><li><p> Unused： me_key &#x3D;&#x3D; me_value &#x3D;&#x3D; NULL (Unused是entry的初始状态，key和value都为NULL。插入元素时，Unused状态转换成Active状态。这是me_key为NULL的唯一情况。)</p><p> Active： me_key !&#x3D; NULL and me_key !&#x3D; dummy 且 me_value !&#x3D; NULL(插入元素后，entry就成了Active状态，这是me_value唯一不为NULL的情况，删除元素时Active状态刻转换成Dummy状态。)</p><p> Dummy： me_key &#x3D;&#x3D; dummy 且 me_value &#x3D;&#x3D; NULL(Dummy是一种类似的伪删除方式，保证探测链的连续性 ABC 删除B 保证A-&gt;c)</p></li><li><p> lookdict(k,v)</p><pre><code> 1. index &lt;- hash1(k)，freeslot&lt;-Null,根据me_key与me_value选择2、3、4一个执行; 2. 查看index处的值处于’有效元素占据‘状态，判断data[index]与v是否一致(地址或内容),一致,则返回查找成功;否则转5 3. index所指向的位置处于’原始空‘状态，查找失败，若freeslot==Null返回index;否则返回freeslot;转5 4. index所指向的位置处于’有效元素离去‘状态，freeslot&lt;-index, 转5 5. index &lt;- hash2(index),，转2</code></pre></li><li><p>加载因子 2&#x2F;3 ，大于则扩容</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-源码阅读(5)-python线程</title>
      <link href="/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(5)-python%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(5)-python%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全局解释器锁(Global Interpreter Lock) 当CPython创建变量时，它会分配内存然后计算对</span><br><span class="line">该变量的引用数量，大家通常称之为“引用计数”。 如果引用计数变为0，则从系统中释放该内存。引用 计数变量时需要保护竞争条件，多个线程同时增加 或减少变量引用计数时，可能导致内存泄漏或者错 误的内存释放。 CPython引入了GIL，线程在执行代码时，必须首先 获得解释器的使用权，虽然保证了数据安全，也意 味着单进程下Python多线程的性能没有那么好。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[ceval_gil.h]</span><br><span class="line">static _Py_atomic_int gil_locked = &#123;-1&#125;;</span><br><span class="line">static _Py_atomic_address gil_last_holder = &#123;0&#125;;</span><br><span class="line">static COND_T gil_cond;</span><br><span class="line">static MUTEX_T gil_mutex;</span><br><span class="line"></span><br><span class="line">static void create_gil(void)</span><br><span class="line">&#123;</span><br><span class="line">    MUTEX_INIT(gil_mutex);</span><br><span class="line">    MUTEX_INIT(switch_mutex);</span><br><span class="line">    COND_INIT(gil_cond);</span><br><span class="line">    COND_INIT(switch_cond);</span><br><span class="line">    _Py_atomic_store_relaxed(&amp;gil_last_holder, 0);</span><br><span class="line">    _Py_ANNOTATE_RWLOCK_CREATE(&amp;gil_locked);</span><br><span class="line">    _Py_atomic_store_explicit(&amp;gil_locked, 0, _Py_memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ceval_gil.h]</span><br><span class="line">static void take_gil(PyThreadState *tstate)</span><br><span class="line">&#123;</span><br><span class="line">    int err;</span><br><span class="line">    err = errno;</span><br><span class="line">    MUTEX_LOCK(gil_mutex);</span><br><span class="line">    if (!_Py_atomic_load_relaxed(&amp;gil_locked))</span><br><span class="line">        goto _ready;</span><br><span class="line"></span><br><span class="line">    while (_Py_atomic_load_relaxed(&amp;gil_locked)) &#123;</span><br><span class="line">        int timed_out = 0;</span><br><span class="line">        COND_TIMED_WAIT(gil_cond, gil_mutex, INTERVAL, timed_out);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">_ready:</span><br><span class="line">    ...</span><br><span class="line">    _Py_atomic_store_relaxed(&amp;gil_locked, 1);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[Modules/_threadmodule.c]</span><br><span class="line">static PyMethodDef thread_methods[] = &#123;</span><br><span class="line">    &#123;&quot;start_new_thread&quot;,        (PyCFunction)thread_PyThread_start_new_thread,</span><br><span class="line">     METH_VARARGS, start_new_doc&#125;,</span><br><span class="line">    &#123;&quot;start_new&quot;,               (PyCFunction)thread_PyThread_start_new_thread,</span><br><span class="line">     METH_VARARGS, start_new_doc&#125;,</span><br><span class="line">    &#123;&quot;allocate_lock&quot;,           (PyCFunction)thread_PyThread_allocate_lock,</span><br><span class="line">     METH_NOARGS, allocate_doc&#125;,</span><br><span class="line">    &#123;&quot;allocate&quot;,                (PyCFunction)thread_PyThread_allocate_lock,</span><br><span class="line">     METH_NOARGS, allocate_doc&#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#123;NULL,                      NULL&#125;           /* sentinel */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[cveal.c]</span><br><span class="line">static PyThread_type_lock pending_lock = 0; /* for pending calls */</span><br><span class="line">static unsigned long main_thread = 0;</span><br><span class="line">/* Request for dropping the GIL */</span><br><span class="line">static _Py_atomic_int gil_drop_request = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void PyEval_InitThreads(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (gil_created())  // 如果初始化过了</span><br><span class="line">        return;</span><br><span class="line">    create_gil();</span><br><span class="line">    take_gil(PyThreadState_GET());</span><br><span class="line">    main_thread = PyThread_get_thread_ident();</span><br><span class="line">    if (!pending_lock)</span><br><span class="line">        pending_lock = PyThread_allocate_lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从GIL到字节码"><a href="#从GIL到字节码" class="headerlink" title="从GIL到字节码"></a>从GIL到字节码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[pystate.c]</span><br><span class="line">PyThreadState * PyThreadState_New(PyInterpreterState *interp)</span><br><span class="line">&#123;</span><br><span class="line">    return new_threadstate(interp, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static PyThreadState * new_threadstate(PyInterpreterState *interp, int init)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(sizeof(PyThreadState));</span><br><span class="line"></span><br><span class="line">    if (_PyThreadState_GetFrame == NULL)    // 设置获得线程中函数调用栈的操作</span><br><span class="line">        _PyThreadState_GetFrame = threadstate_getframe;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (init)</span><br><span class="line">        _PyThreadState_Init(tstate);</span><br><span class="line">    ...</span><br><span class="line">    return tstate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _PyThreadState_Init(PyThreadState *tstate)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef WITH_THREAD</span><br><span class="line">    _PyGILState_NoteThreadState(tstate);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子线程在创建了自身的线程状态对象后, 通过 _PyGILState_NoteThreadState 将这个线程对象设置到 autoTLSkey 中.</p><p>有意思的是, 这时候当前活动的python线程不一定是获得GIL的线程. 这是因为主线程和子线程都是操作系统原生线程, 所以操作系统可能在主线程和子线程之间切换. 这里要区分的一点是, 系统级别的线程调度与GIL无关. 而python级的线程调度才与GIL有关, 前面也说了, python自己模拟一套线程的调度方式. 所以操作系统级的并不一定意味着GIL的得手, 当所有的线程都完成了初始化的动作之后, 操作系统的线程调度和python的线程调度才会同一. 那时, python的线程调度会强制当前活动线程释放GIL, 而这一操作会触发Event内核对象, 这个触发进而触发操作系统进行线程调度. 这个GIL其实是起到了从python级线程到操作系统级线程调度的桥梁作用.</p><p>真正争夺GIL的是在 t_bootstrap 中, 透过 PyEval_AcquireThread 获得GIL的话语权. 到了这一步, 子线程将自己挂起, 操作系统的线程调度不能唤起它, 只有等待python的线程调度强制主线程放弃GIL后, 子线程才回被唤醒. 而子线程被唤醒后, 主线程又将陷入等待中.</p><p>当子线程被python的线程调度唤醒后, 做的第一件事就是通过 PyThreadState_Swap(tstate) 设置python维护当前线程状态对象, 如操作系统的进程上下文环境恢复一样.</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-源码阅读(7)-Cpython调试</title>
      <link href="/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(7)-Cpython%E8%B0%83%E8%AF%95/"/>
      <url>/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(7)-Cpython%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一-工作准备"><a href="#一-工作准备" class="headerlink" title="一. 工作准备"></a>一. 工作准备</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># locally clone the repo.</span><br><span class="line">git clone https://github.com/python/cpython</span><br><span class="line"># Navigate to the repo directory</span><br><span class="line">cd cpython</span><br><span class="line"># Switch to the version of python you want to work on</span><br><span class="line">git checkout 3.6</span><br><span class="line"># configure a debug build for CPython</span><br><span class="line">./configure --with-pydebug</span><br><span class="line"># build without echoing commands and use 2 cores</span><br><span class="line">make -s -j2</span><br></pre></td></tr></table></figure><p>注意：<br>最好是linux系统</p><h1 id="二-了解python字节码"><a href="#二-了解python字节码" class="headerlink" title="二. 了解python字节码"></a>二. 了解python字节码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...     a = 1</span><br><span class="line">...     a.x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dis.dis(foo)</span><br><span class="line">  2           0 LOAD_CONST               1 (1)</span><br><span class="line">              3 STORE_FAST               0 (a)</span><br><span class="line">  3           6 LOAD_FAST                0 (a)</span><br><span class="line">              9 LOAD_ATTR                0 (x)</span><br><span class="line">             12 POP_TOP</span><br><span class="line">             13 LOAD_CONST               0 (None)</span><br><span class="line">             16 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>使用dis模块查看python字节码，其中LOAD_CONST指令对于如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Python/ceval.c</span><br><span class="line">   2862 TARGET(LOAD_ATTR) &#123;</span><br><span class="line">   2863     PyObject *name = GETITEM(names, oparg);</span><br><span class="line">   2864     PyObject *owner = TOP();</span><br><span class="line">   2865     PyObject *res = PyObject_GetAttr(owner, name);</span><br><span class="line">   2866     Py_DECREF(owner);</span><br><span class="line">   2867     SET_TOP(res);</span><br><span class="line">   2868     if (res == NULL)</span><br><span class="line">   2869         goto error;</span><br><span class="line">   2870     DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h1><ol><li>启动dgb，编写代码例子<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sabbas@sabbas-VirtualBox:~/Documents/pythondev/cpython</span><br><span class="line">$ gdb python</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/sabbas/Documents/pythondev/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Python 3.6.2+ (heads/3.6:cb7fdf6, Aug 23 2017, 22:24:16) </span><br><span class="line">[GCC 5.4.0 20160609] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...     x = 1</span><br><span class="line">...     x.a</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li>另外启动一个终端 暂停python执行器，提供打入断点机会<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sabbas@sabbas-VirtualBox:~/Documents/pythondev/cpython</span><br><span class="line">$ pkill python -SIGTRAP</span><br></pre></td></tr></table></figure></li><li>回到dgb调试打断点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sabbas@sabbas-VirtualBox:~/Documents/pythondev/cpython</span><br><span class="line">$ gdb python</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/sabbas/Documents/pythondev/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Python 3.6.2+ (heads/3.6:cb7fdf6, Aug 23 2017, 22:24:16) </span><br><span class="line">[GCC 5.4.0 20160609] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...     x = 1</span><br><span class="line">...     x.a</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Program received signal SIGTRAP, Trace/breakpoint trap.</span><br><span class="line">0x00007ffff71dd573 in __select_nocancel () at ../sysdeps/unix/syscall-template.S:84</span><br><span class="line">84 ../sysdeps/unix/syscall-template.S: No such file or directory.</span><br><span class="line">(gdb) b Python/ceval.c:2855</span><br><span class="line">Breakpoint 1 at 0x5418d7: file Python/ceval.c, line 2855.</span><br><span class="line">(gdb)c</span><br><span class="line">Continuing.</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure></li><li>函数调用,断在cpython中了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; foo()</span><br><span class="line">Breakpoint 1, _PyEval_EvalFrameDefault (f=&lt;optimized out&gt;, throwflag=&lt;optimized out&gt;) at Python/ceval.c:2855</span><br><span class="line">2855             PyObject *name = GETITEM(names, oparg);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li><li>使用dbg相关命令查看cpython中变量，等等等</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-源码阅读(6)-python垃圾回收</title>
      <link href="/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(6)-python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2025/05/18/python-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(6)-python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="引用计数与垃圾收集"><a href="#引用计数与垃圾收集" class="headerlink" title="引用计数与垃圾收集"></a>引用计数与垃圾收集</h1><p>引用计数机制所带来的维护引用计数的额外操作与python运行中所进行的内存分配和释放, 引用赋值次数是成正比的, 这也是引用计数执行效率较慢的原因(软肋).为了与引用计数机制搭配, 在内存的分配和释放上获得最高的效率, python因此设计了很多内存池机制, 如上一篇的小块内存池. 而且在一些PyObject中如PyLongObject, PyUnicodeObject, PyDictObject, PyListObject等都有与各个对象相关的内存池机制. 这些大量使用的面向特定对象内存池机制正式为了弥补引用计数的软肋.</p><p>引用计数还需要处理一个致命的弱点, 就是循环引用. 当若干对象相互引用, 会造成每一个对象的引用计数都不会0, 因此这些对象所占用的内存永远不会回收.</p><h1 id="python中的标记-清除"><a href="#python中的标记-清除" class="headerlink" title="python中的标记-清除"></a>python中的标记-清除</h1><p>对与循环应用问题，python采用标记-清除。</p><ol><li>container对象之间如list, dict, class等. 当python的垃圾收集机制运行时, 只需要检测这些container对象，这些container对象包含一个双向链表</li><li>python 通过ref_count计算应用计数垃圾回收，gc_ref是ref_count副本，用于循环应用的垃圾回收，GC时分两步，一是gc_ref自减1，摘除循环引用；二是从root根出发标记是否可达。最后gc_ref为0且不可达将被回收</li></ol><h1 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h1><p>分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</p><p>python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-黑魔法-python基础</title>
      <link href="/2025/05/18/python-%E9%BB%91%E9%AD%94%E6%B3%95-python%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/05/18/python-%E9%BB%91%E9%AD%94%E6%B3%95-python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="python-LEGB原则"><a href="#python-LEGB原则" class="headerlink" title="python LEGB原则"></a>python LEGB原则</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所谓LEGB是指 local&lt; enClosed&lt; global&lt; buind in</span><br></pre></td></tr></table></figure><h1 id="nonloacl-与-global"><a href="#nonloacl-与-global" class="headerlink" title="nonloacl 与 global"></a>nonloacl 与 global</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nonloacl 处在函数嵌套中 非global对象</span><br></pre></td></tr></table></figure><h1 id="实例属性-与-类属性"><a href="#实例属性-与-类属性" class="headerlink" title="实例属性 与 类属性"></a>实例属性 与 类属性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例属性 从属于实例  类属性从属于类</span><br></pre></td></tr></table></figure><h1 id="python-内存分析"><a href="#python-内存分析" class="headerlink" title="python 内存分析"></a>python 内存分析</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈：对象引用放入栈</span><br><span class="line"></span><br><span class="line">堆：类对象（也叫模具 即type）（存放类属性，类方法，静态方法）和实例对象（存放 id ，type，实例属性 方法地址）</span><br></pre></td></tr></table></figure><h1 id="垃圾回收机制（引用计数-del-）垃圾回收器调用"><a href="#垃圾回收机制（引用计数-del-）垃圾回收器调用" class="headerlink" title="垃圾回收机制（引用计数 __del__）垃圾回收器调用"></a>垃圾回收机制（引用计数 __del__）垃圾回收器调用</h1><h1 id="私有属性-属性和方法-dir查看所有属性（方法也是属性）"><a href="#私有属性-属性和方法-dir查看所有属性（方法也是属性）" class="headerlink" title="私有属性 (属性和方法) dir查看所有属性（方法也是属性）"></a>私有属性 (属性和方法) dir查看所有属性（方法也是属性）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">双下划线： 私有属性</span><br><span class="line">私有属性外部如何访问 实例._类名.__私有属性</span><br></pre></td></tr></table></figure><h1 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作用是将方法变属性使用</span><br></pre></td></tr></table></figure><h1 id="mro"><a href="#mro" class="headerlink" title="mro()"></a>mro()</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看内存结构，类的继承关系</span><br><span class="line">python中继承方法重写安广度优先算法</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-黑魔法-python不一样的懒加载</title>
      <link href="/2025/05/18/python-%E9%BB%91%E9%AD%94%E6%B3%95-python%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2025/05/18/python-%E9%BB%91%E9%AD%94%E6%B3%95-python%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><h3 id="一-一般方式懒加载"><a href="#一-一般方式懒加载" class="headerlink" title="一.一般方式懒加载"></a>一.一般方式懒加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance=None</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(clz):</span><br><span class="line">        if clz._instance is None:</span><br><span class="line">            clz._instance=Singleton()</span><br><span class="line">        return clz._instance</span><br><span class="line"></span><br><span class="line">print(Singleton.instance()==Singleton.instance())</span><br><span class="line"></span><br><span class="line"># 弊端是直接Singleton()就不一样</span><br></pre></td></tr></table></figure><h3 id="二-new-来实现懒加载"><a href="#二-new-来实现懒加载" class="headerlink" title="二.__new__来实现懒加载"></a>二.__new__来实现懒加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    def __new__(clz):</span><br><span class="line">        if not hasattr(clz,&quot;_instance&quot;):</span><br><span class="line">            clz._instance=super(Singleton,clz).__new__(clz)</span><br><span class="line">        return clz._instance</span><br><span class="line"></span><br><span class="line">print(Singleton()==Singleton())</span><br><span class="line"># 注意： __init__ 与 __new__区别与联系 </span><br><span class="line"># 1. 在调用__init__前是先调用__new__方法</span><br><span class="line"># 2. __new__一定会有return</span><br><span class="line"># 3. __new__可以自定义类的实例化</span><br><span class="line">    # 如：</span><br><span class="line">    class PositiveInteger(int):</span><br><span class="line">        def __new__(clz,value):</span><br><span class="line">            return super(PositiveInteger,clz).__new__(clz,abs(value))</span><br><span class="line">    i=PositiveInteger(-3)</span><br><span class="line"># 4.__new__可以实现mateclass</span><br></pre></td></tr></table></figure><h3 id="三-new-mateclass实现懒加载"><a href="#三-new-mateclass实现懒加载" class="headerlink" title="三.new + mateclass实现懒加载"></a>三.<strong>new</strong> + mateclass实现懒加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TypeSingleton(type):</span><br><span class="line"></span><br><span class="line">    def __new__(clz, name, base, attrs):</span><br><span class="line">        # 这里可用用super 即object来创建 ，也可以直接tpye创建类</span><br><span class="line">        clz._instance = type.__new__(clz, name, base, attrs)</span><br><span class="line">        return clz._instance</span><br><span class="line"></span><br><span class="line">class Singleton(metaclass=TypeSingleton):</span><br><span class="line">    _instance = None</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(clz):</span><br><span class="line">        return clz._instance</span><br><span class="line"></span><br><span class="line">print(Singleton.instance() == Singleton.instance())</span><br><span class="line">#注意：</span><br><span class="line">#1. object类是所有内的父类（包含type类）</span><br><span class="line">#2. type类是所有实例的父类（object也是type类创建）</span><br></pre></td></tr></table></figure><h3 id="四-高阶写法-多线程下懒加载"><a href="#四-高阶写法-多线程下懒加载" class="headerlink" title="四.高阶写法 多线程下懒加载"></a>四.高阶写法 多线程下懒加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import threading</span><br><span class="line">lock=threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(cls,&quot;_instance&quot;):</span><br><span class="line">            try:</span><br><span class="line">                lock.acquire()</span><br><span class="line">                if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">                    cls._instance=super(Singleton,cls).__new__(cls,*args, **kwargs)</span><br><span class="line">            finally:</span><br><span class="line">                lock.release()</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">print(Singleton() == Singleton())</span><br><span class="line"># 双重检查+单例</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-黑魔法-上下文管理器</title>
      <link href="/2025/05/18/python-%E9%BB%91%E9%AD%94%E6%B3%95-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2025/05/18/python-%E9%BB%91%E9%AD%94%E6%B3%95-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="python-上下文管理器"><a href="#python-上下文管理器" class="headerlink" title="python 上下文管理器"></a>python 上下文管理器</h1><ol><li>with的作用是什么</li><li>@contextlib.contextmanager与with有什么关系</li><li>上下文管理器使用案例</li><li>多个管理器嵌套 nested函数</li></ol><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>with是一款语法糖 大致执行分为三个阶段</p><ol><li><strong>enter</strong>(self): with进入前</li><li>with 内部代码</li><li><strong>exit</strong>(self, type, value, traceback) with 退出后</li></ol><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><ul><li>在理解 @contextlib.contextmanager内部先看下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#未使用上下文管理器，handle_query代码啰嗦</span><br><span class="line">class Database(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.connected = False</span><br><span class="line"></span><br><span class="line">    def connect(self):</span><br><span class="line">        self.connected = True</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        self.connected = False</span><br><span class="line"></span><br><span class="line">    def query(self):</span><br><span class="line">        if self.connected:</span><br><span class="line">            return &#x27;query data&#x27;</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#x27;DB not connected &#x27;)</span><br><span class="line"></span><br><span class="line">def handle_query():</span><br><span class="line">    db = Database()</span><br><span class="line">    db.connect()</span><br><span class="line">    print &#x27;handle --- &#x27;, db.query()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    handle_query()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>使用上下文管理器后</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#handle_query 简单多了</span><br><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Database(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.connected = False</span><br><span class="line"></span><br><span class="line">    def connect(self):</span><br><span class="line">        self.connected = True</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        self.connected = False</span><br><span class="line"></span><br><span class="line">    def query(self):</span><br><span class="line">        if self.connected:</span><br><span class="line">            return &#x27;query data&#x27;</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#x27;DB not connected &#x27;)</span><br><span class="line"></span><br><span class="line">@contextlib.contextmanager</span><br><span class="line">def database():</span><br><span class="line">    db = Database()</span><br><span class="line">    try:</span><br><span class="line">        if not db.connected:</span><br><span class="line">            db.connect()</span><br><span class="line">        yield db</span><br><span class="line">    except Exception as e:</span><br><span class="line">        db.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_query():</span><br><span class="line">    with database() as db:</span><br><span class="line">        print(&#x27;handle ---&#x27;, db.query())</span><br><span class="line"></span><br><span class="line">handle_query()</span><br></pre></td></tr></table></figure><ul><li>分析下代码执行逻辑</li></ul><ol><li>进入@contextlib.contextmanager 实质是contextlib.contextmanager(database)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#进入装饰器后又来一个装饰器wrap</span><br><span class="line">#简单说明下wrap装饰器的作用是将 要装饰的方法相关属性的指针指向装饰器，也就是将func的属性地址给 helper</span><br><span class="line">@wraps(func)</span><br><span class="line">def helper(*args, **kwds):</span><br><span class="line">    return _GeneratorContextManager(func, args, kwds)</span><br><span class="line">return helper</span><br></pre></td></tr></table></figure></li><li>执行到whit database() 的database()时候进入到return _GeneratorContextManager(func, args, kwds)，初始化 _GeneratorContextManager过程中 func（&#x3D;&#x3D;database）协程初始化完成</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class _GeneratorContextManager(ContextDecorator, AbstractContextManager):</span><br><span class="line">    &quot;&quot;&quot;Helper for @contextmanager decorator.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, func, args, kwds):</span><br><span class="line">        self.gen = func(*args, **kwds)</span><br><span class="line">        self.func, self.args, self.kwds = func, args, kwds</span><br><span class="line">        # Issue 19330: ensure context manager instances have good docstrings</span><br><span class="line">        doc = getattr(func, &quot;__doc__&quot;, None)</span><br><span class="line">        if doc is None:</span><br><span class="line">            doc = type(self).__doc__</span><br><span class="line">        self.__doc__ = doc</span><br><span class="line">        # Unfortunately, this still doesn&#x27;t provide good help output when</span><br><span class="line">        # inspecting the created context manager instances, since pydoc</span><br><span class="line">        # currently bypasses the instance docstring and shows the docstring</span><br><span class="line">        # for the class instead.</span><br><span class="line">        # See http://bugs.python.org/issue19404 for more details.</span><br><span class="line"></span><br><span class="line">    def _recreate_cm(self):</span><br><span class="line">        # _GCM instances are one-shot context managers, so the</span><br><span class="line">        # CM must be recreated each time a decorated function is</span><br><span class="line">        # called</span><br><span class="line">        return self.__class__(self.func, self.args, self.kwds)</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        try:</span><br><span class="line">            return next(self.gen)</span><br><span class="line">        except StopIteration:</span><br><span class="line">            raise RuntimeError(&quot;generator didn&#x27;t yield&quot;) from None</span><br><span class="line"></span><br><span class="line">    def __exit__(self, type, value, traceback):</span><br><span class="line">        if type is None:</span><br><span class="line">            try:</span><br><span class="line">                next(self.gen)</span><br><span class="line">            except StopIteration:</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                raise RuntimeError(&quot;generator didn&#x27;t stop&quot;)</span><br><span class="line">        else:</span><br><span class="line">            if value is None:</span><br><span class="line">                # Need to force instantiation so we can reliably</span><br><span class="line">                # tell if we get the same exception back</span><br><span class="line">                value = type()</span><br><span class="line">            try:</span><br><span class="line">                self.gen.throw(type, value, traceback)</span><br><span class="line">            except StopIteration as exc:</span><br><span class="line">                # Suppress StopIteration *unless* it&#x27;s the same exception that</span><br><span class="line">                # was passed to throw().  This prevents a StopIteration</span><br><span class="line">                # raised inside the &quot;with&quot; statement from being suppressed.</span><br><span class="line">                return exc is not value</span><br><span class="line">            except RuntimeError as exc:</span><br><span class="line">                # Don&#x27;t re-raise the passed in exception. (issue27122)</span><br><span class="line">                if exc is value:</span><br><span class="line">                    return False</span><br><span class="line">                # Likewise, avoid suppressing if a StopIteration exception</span><br><span class="line">                # was passed to throw() and later wrapped into a RuntimeError</span><br><span class="line">                # (see PEP 479).</span><br><span class="line">                if type is StopIteration and exc.__cause__ is value:</span><br><span class="line">                    return False</span><br><span class="line">                raise</span><br><span class="line">            except:</span><br><span class="line">                # only re-raise if it&#x27;s *not* the exception that was</span><br><span class="line">                # passed to throw(), because __exit__() must not raise</span><br><span class="line">                # an exception unless __exit__() itself failed.  But throw()</span><br><span class="line">                # has to raise the exception to signal propagation, so this</span><br><span class="line">                # fixes the impedance mismatch between the throw() protocol</span><br><span class="line">                # and the __exit__() protocol.</span><br><span class="line">                #</span><br><span class="line">                if sys.exc_info()[1] is value:</span><br><span class="line">                    return False</span><br><span class="line">                raise</span><br><span class="line">            raise RuntimeError(&quot;generator didn&#x27;t stop after throw()&quot;)</span><br></pre></td></tr></table></figure><ol start="3"><li>触发__enter__ ，通过next(self.gen)启动协程</li><li>进入函数database yield db 挂起自己，释放控制权返回db<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def database():</span><br><span class="line">    db = Database()</span><br><span class="line">    try:</span><br><span class="line">        if not db.connected:</span><br><span class="line">            db.connect()</span><br><span class="line">        yield db</span><br><span class="line">    except Exception as e:</span><br><span class="line">        db.close()</span><br></pre></td></tr></table></figure></li><li>进入with内部 print(‘handle —‘, db.query())</li><li>触发__exit__ 继续回到协程 yeild db，关闭连接 退出with</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">问题二：</span><br><span class="line">可以看到 with 是要与具有__enter__，__exit__的对象一起使用，而contextlib.contextmanager就是那个对象</span><br></pre></td></tr></table></figure><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#锁资源</span><br><span class="line">@contextmanager</span><br><span class="line">def locked(lock):</span><br><span class="line">    lock.acquire()</span><br><span class="line">    try:</span><br><span class="line">        yield</span><br><span class="line">    finally:</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">with locked(myLock):</span><br><span class="line">    #代码执行到这里时，myLock已经自动上锁</span><br><span class="line">    pass</span><br><span class="line">    #执行完后会，会自动释放锁</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#文件资源</span><br><span class="line">@contextmanager</span><br><span class="line">def myopen(filename, mode=&quot;r&quot;):</span><br><span class="line">    f = open(filename,mode)</span><br><span class="line">    try:</span><br><span class="line">        yield f</span><br><span class="line">    finally:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">with myopen(&quot;test.txt&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#数据库资源</span><br><span class="line">@contextmanager</span><br><span class="line">def transaction(db):</span><br><span class="line">    db.begin()</span><br><span class="line">    try：</span><br><span class="line">        yield </span><br><span class="line">    except:</span><br><span class="line">        db.rollback()</span><br><span class="line">        raise</span><br><span class="line">    else:</span><br><span class="line">        db.commit()</span><br><span class="line"></span><br><span class="line">with transaction(mydb):</span><br><span class="line">    mydb.cursor.execute(sql)</span><br><span class="line">    mydb.cursor.execute(sql)</span><br><span class="line">    mydb.cursor.execute(sql)</span><br><span class="line">    mydb.cursor.execute(sql)</span><br></pre></td></tr></table></figure><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line">from contextlib import nested</span><br><span class="line">from contextlib import closing</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def my_context(name):</span><br><span class="line">    print(&quot;enter&quot;)</span><br><span class="line">    try:</span><br><span class="line">        yield name</span><br><span class="line">    finally:</span><br><span class="line">        print(&quot;exit&quot;)</span><br><span class="line"></span><br><span class="line">#使用nested函数来调用多个管理器</span><br><span class="line">print(&quot;---------使用nested函数调用多个管理器-----------&quot;)</span><br><span class="line">with nested(my_context(&quot;管理器一&quot;), my_context(&quot;管理器二&quot;),my_context(&quot;管理器三&quot;)) as (m1,m2,m3):</span><br><span class="line">    print(m1)</span><br><span class="line">    print(m2)</span><br><span class="line">    print(m3)</span><br><span class="line"></span><br><span class="line">#直接使用with来调用调用多个管理器</span><br><span class="line">print(&quot;---------使用with调用多个管理器-----------&quot;)</span><br><span class="line">with my_context(&quot;管理器一&quot;) as m1, my_context(&quot;管理器二&quot;) as m2, my_context(&quot;管理器三&quot;) as m3:</span><br><span class="line">    print(m1)</span><br><span class="line">    print(m2)</span><br><span class="line">    print(m3)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-黑魔法-装饰器</title>
      <link href="/2025/05/18/python-%E9%BB%91%E9%AD%94%E6%B3%95-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2025/05/18/python-%E9%BB%91%E9%AD%94%E6%B3%95-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰器剖析"><a href="#装饰器剖析" class="headerlink" title="装饰器剖析"></a>装饰器剖析</h1><ol><li>不带参数的装饰器</li><li>带参数的装饰器</li><li>类装饰器</li><li>利用functools.wrap 将wapped 的属性赋值给wapper</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"># encoding: utf-8</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">--------------------------------------</span><br><span class="line">@describe </span><br><span class="line">@version: 1.0</span><br><span class="line">@project: websockets</span><br><span class="line">@file: test.py</span><br><span class="line">@author: yuanlang </span><br><span class="line">@time: 2019-03-18 14:29</span><br><span class="line">---------------------------------------</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 先看看函数复制</span><br><span class="line">def a():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">x = a</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结论</span><br><span class="line"># a方法地址给了 x</span><br><span class="line"># 两个地址都是 a方法</span><br><span class="line">print(&quot;---------------------------------------&quot;)</span><br><span class="line"></span><br><span class="line">def log_track(func):</span><br><span class="line">    def wapper(*args, **kwargs):</span><br><span class="line">        print(func.__name__)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    return wapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def hello2():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@log_track</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(hello)</span><br><span class="line">hello = wapper = log_track(hello)  # 和 @log_track效果一样</span><br><span class="line">print(hello)</span><br><span class="line">print(hello2.__name__)</span><br><span class="line">print(hello.__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结论</span><br><span class="line"># hello指针指向的hello函数地址进入到wapper作用域中，返回的wapper函数地址给 hello</span><br><span class="line">print(&quot;---------------------------------------&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 带参数的装饰器</span><br><span class="line">def user_loggin(level):</span><br><span class="line">    print(level)</span><br><span class="line"></span><br><span class="line">    def decoration(func):</span><br><span class="line">        print(func.__name__)</span><br><span class="line"></span><br><span class="line">        def wrapper(*args,**kwargs):</span><br><span class="line">            print(func.__name__)</span><br><span class="line">            func(*args,**kwargs)</span><br><span class="line">        print(&quot;return wrapper&quot;)</span><br><span class="line">        return wrapper</span><br><span class="line">    print(&quot;return decoration&quot;)</span><br><span class="line">    return decoration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    return &quot;foo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func = decoration = user_loggin(level=&quot;debug&quot;)</span><br><span class="line">print(func)</span><br><span class="line">print(&quot;func.__name__ &gt;&gt;&gt;&gt;&gt; &quot;,func.__name__)</span><br><span class="line">print(&quot;######################&quot;)</span><br><span class="line">func = wrapper = user_loggin(level=&quot;debug&quot;)(foo)</span><br><span class="line">print(func)</span><br><span class="line">print(&quot;func.__name__  &gt;&gt;&gt;&gt;&gt;&quot;,func.__name__)</span><br><span class="line">print(&quot;######################&quot;)</span><br><span class="line"></span><br><span class="line">@user_loggin(level=&quot;debug&quot;)</span><br><span class="line">def foo2():</span><br><span class="line">    print(&quot;fool&quot;)</span><br><span class="line"># 总结</span><br><span class="line"># 带参数的装饰器比不带参数的装饰器多一层，需先解压出装饰器</span><br><span class="line">print(&quot;---------------------------------------&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类装饰器</span><br><span class="line">class Foo():</span><br><span class="line"></span><br><span class="line">    def __init__(self,func):</span><br><span class="line">        self.__func=func</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;before call&quot;)</span><br><span class="line">        self.__func(*args,**kwargs)</span><br><span class="line">        print(&quot;after call&quot;)</span><br><span class="line">        return self.__func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    print(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo_obj=Foo(test)</span><br><span class="line">print(foo_obj)</span><br><span class="line">print(&quot;__call__&quot;,foo_obj())</span><br><span class="line">print(&quot;######################&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;__call__&quot;,foo_obj.__call__())</span><br><span class="line">print(&quot;######################&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Foo</span><br><span class="line">def test1():</span><br><span class="line">    print(&quot;test1&quot;)</span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line"># 总结</span><br><span class="line"># 类装饰器 实质是将 类的__call__地址 负值给要装饰的函数  test1=Foo(test1).__call__</span><br><span class="line">print(&quot;---------------------------------------&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">##  可以发现 需要被装饰的函数的 docstring、__name__ 被装饰器替代了</span><br><span class="line">##  所以引出 functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中</span><br><span class="line">##</span><br><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">def logged(func):</span><br><span class="line"></span><br><span class="line">    #func=decoration=wraps(func)(with_logging)</span><br><span class="line">    #wraps(func)解压并调用类装饰器</span><br><span class="line">    #func=partial().__call__</span><br><span class="line">    #update_wapper 将with_loggin 的某些参数负值给f return 的 with_logging 变为 f</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def with_logging(*args, **kwargs):</span><br><span class="line">        print(func.__name__ + &quot; was called&quot;)</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    return with_logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@logged</span><br><span class="line">def f(x):</span><br><span class="line">    &quot;&quot;&quot;does some math&quot;&quot;&quot;</span><br><span class="line">    return x + x * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(f.__name__ ) # prints &#x27;f&#x27;</span><br><span class="line">print(f.__doc__ ) # prints &#x27;does some math1&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDH安装</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-hadoop-CDH%E5%AE%89%E8%A3%85/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-hadoop-CDH%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<ol><li>系统环境准备</li></ol><p>1、网络配置 </p><p>vi &#x2F;etc&#x2F;sysconfig&#x2F;network  </p><p>vi &#x2F;etc&#x2F;hosts</p><p>2、SSH免密钥登录</p><p>虚拟机的环境准备非常重要：免密钥的master需要和slave免密钥；那么cloudera manager的server需要和agent免密钥；</p><p>那么具体的软件比如hdfs的namenode所在的节点就需要和它的datanode节点免密钥；</p><p>全部会话 ：ssh-keygen -t rsa -P ‘’ -f ~&#x2F;.ssh&#x2F;id_rsa</p><p>ssh-copy-id node11&#x2F;node12&#x2F;node13</p><p>3、防火墙关闭</p><p>Service iptables  stop</p><p>Chkconfig iptables off</p><p>4、SELINUX关闭 setenforce 0</p><p>vi &#x2F;etc&#x2F;selinux&#x2F;config (SELINUX&#x3D;disabled) </p><p>5.安装JDK配置环境变量</p><p>三台机器都需要</p><p>将jdk上传到node11的&#x2F;home&#x2F;tools目录下</p><p>Node11执行：scp  jdk+Tab node12:<code>pwd</code></p><p> scp  jdk+Tab node13:<code>pwd</code></p><p>全部会话：rpm -ivh jdk*</p><p>修改 vi&#x2F;etc&#x2F;profile 添加环境变量（一个一个添加）</p><p>source .&#x2F;etc&#x2F;profile</p><p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;default &#x2F;&#x2F;注意java的路径</p><p>export PATH&#x3D;JAVAHOME&#x2F;bin:JAVAHOME&#x2F;bin:PATH</p><p>6.安装NTP</p><p>Yum install ntp -y</p><p>设置开机启动 chkconfig ntpd on</p><p>设置时间同步 – ntpdate -u s2c.time.edu.cn（全部会话）</p><p>7.安装配置mysql</p><p>yum install mysql-server -y</p><p>设置开机启动：chkconfig mysqld on</p><p>启动mysql：  service mysqld start</p><p>查看状态：  service mysqld status</p><p>mysql 进入</p><p>use mysql</p><p>select host,user from user</p><p>修改 mysql 权限： GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ IDENTIFIED BY ‘123’ WITH GRANT OPTION;</p><p>刷新：flush privileges;</p><p>删除多余会对权限造成影响的数据：delete from user where host !&#x3D;’%’;</p><p>刷新权限</p><p>select host,user from user;</p><p>quit 退出</p><p>重新登录：mysql -u root -p</p><p>密码：123</p><p>8.下载第三方依赖包</p><p>最后一步安装第三方依赖包的时候，主要针对的是centos，公司中还是要看使用的linux发行版缺少那些版本；</p><p>yum install chkconfig python bind-utils psmisc libxslt zlib sqlite cyrus-sasl-plain cyrus-sasl-gssapi fuse fuse-libs redhat-lsb -y</p><ol start="2"><li><p>CM安装</p></li><li><p>安装Cloudera Manager Server、Agent</p></li></ol><p>上传到&#x2F;home&#x2F;toolsx下 (三台机器都要安装)</p><p>mkdir &#x2F;opt&#x2F;cloudera-manager</p><p>tar xvzf cloudera-manager*.tar.gz -C &#x2F;opt&#x2F;cloudera-manager</p><ol start="2"><li>创建用户cloudera-scm</li></ol><p>全部会话：useradd –system –no-create-home –shell&#x3D;&#x2F;bin&#x2F;false –comment “Cloudera SCM User” cloudera-scm</p><ol start="3"><li>配置CM Agent</li></ol><p>cm的安装包的server和agent都是同一个包，启动的时候启动命令指定为server还是agent；cm有一个工作目录，需要</p><p>我们来创建；创建一个用户；修改agent的配置，给它指定server的位置；那个端口7182是server和agent通信的端口；</p><p>server_host配置为server的名字；</p><p>修改文件&#x2F;opt&#x2F;cloudera-manager&#x2F;cm-5.4.3&#x2F;etc&#x2F;cloudera-scm-agent&#x2F;config.ini中 server_host(三台机器)</p><ol start="4"><li>配置CM Server数据库</li></ol><p>拷贝mysql jar文件到目录 &#x2F;usr&#x2F;share&#x2F;java&#x2F;</p><p>注意jar包名称要修改为mysql-connector-java.jar</p><p>mysql -u root -p</p><p>use mysql;</p><p>grant all on <em>.</em> to ‘temp‘@’%’ identified by ‘temp’ with grant option;</p><p>cd &#x2F;opt&#x2F;cloudera-manager&#x2F;cm-5.4.3&#x2F;share&#x2F;cmf&#x2F;schema&#x2F;</p><p> .&#x2F;scm_prepare_database.sh mysql temp -h CDH1 -utemp -ptemp –scm-host CDH1 scm scm scm</p><p>格式：数据库类型、数据库、数据库服务器、用户名、密码、cm server服务器</p><ol start="5"><li>创建Parcel目录</li></ol><p>创建parcel目录，这些目录是server和agent用来接收和发送数据的目录，server端的parcel-repo这个目录会把所有</p><p>的安装文件全部下载到此目录，而agent也需要安装包，parcels就是用来存储指定的安装包的，当然需要有权限能操作</p><p>这些目录；</p><p>Server节点</p><p> – mkdir -p &#x2F;opt&#x2F;cloudera&#x2F;parcel-repo</p><p>– chown cloudera-scm:cloudera-scm &#x2F;opt&#x2F;cloudera&#x2F;parcel-repo</p><p>Agent节点</p><p>– mkdir -p &#x2F;opt&#x2F;cloudera&#x2F;parcels</p><p>– chown cloudera-scm:cloudera-scm &#x2F;opt&#x2F;cloudera&#x2F;parcels</p><ol start="6"><li>制作CDH本地源</li></ol><p>下载好文件CDH-5.4.0-1.cdh5.4.0.p0.27-el6.parcel以及manifest.json，将这两个文件放到server节点的 &#x2F;opt&#x2F;cloudera&#x2F;parcel-repo下。</p><p>实际上这个三个文件</p><p>打开manifest.json文件，里面是json格式的配置，找到与下载版本相对应的hash码，新建文件，文件名与你的 parel包名一致，并加上.sha后缀，将hash码复制到文件中保存。</p><ol start="7"><li>关机做快照。</li></ol><p>init 0 || power off</p><ol start="8"><li>启动CM Server、Agent</li></ol><p>我们的系统需要预留内存；保证自己的系统能够跑起来，关闭所有的安全卫士；保证第一台节点的内存很多，以后可以</p><p>在cdh1有很多东西；虚拟机默认都采用单核单线，如果cpu可以，采用双核双线；老师使用的是16g内存，虚拟机在固态</p><p>硬盘上面，启动cloudera manager都需要几分钟，如果机器不好，可能需要启动一节课；如果实在不行，就需要单台转载</p><p>所有节点的功能；</p><p>当我们使用server start 会立马返回一个ok，这个只是表明该命令提交成功而已；毕竟server会在linux和mysql中创建</p><p>目录和数据库表，所以第一次启动的时候如果时间很长，千万不要关闭；不然下一次启动的话，依旧会创建这些目录</p><p>然后就会冲突；启动成功与否，可以通过一个日志文件来查看；当看到以下命令的时候，说明启动完成：</p><p>先确保启动了mysql  service mysqld start</p><p>全部会话：cd &#x2F;opt&#x2F;cloudera-manager&#x2F;cm-5.4.3&#x2F;etc&#x2F;init.d&#x2F;</p><p>CDH1:执行.&#x2F;cloudera-scm-server start</p><p>CDH1,2,3执行：.&#x2F;cloudera-scm-agent start</p><p>观察启动server的日志</p><p>cd &#x2F;opt&#x2F;cloudera-manager&#x2F;cm-5.4.3&#x2F;log&#x2F;cloudera-scm-server</p><p>tail -f 上面目录下的log的文件</p><p>出现如下内容表明启动成功</p><p>2017-02-22 19:57:04,638 INFO WebServerImpl:org.mortbay.log: Started <a href="mailto:&#83;&#101;&#108;&#x65;&#x63;&#x74;&#x43;&#104;&#x61;&#x6e;&#110;&#101;&#108;&#x43;&#111;&#x6e;&#x6e;&#x65;&#99;&#x74;&#x6f;&#114;&#64;&#48;&#46;&#x30;&#x2e;&#x30;&#46;&#x30;">&#83;&#101;&#108;&#x65;&#x63;&#x74;&#x43;&#104;&#x61;&#x6e;&#110;&#101;&#108;&#x43;&#111;&#x6e;&#x6e;&#x65;&#99;&#x74;&#x6f;&#114;&#64;&#48;&#46;&#x30;&#x2e;&#x30;&#46;&#x30;</a>:7180</p><p>2017-02-22 19:57:04,638 INFO WebServerImpl:com.cloudera.server.cmf.WebServerImpl: Started Jetty server.</p><p>进入web浏览器进行访问，端口号：7180</p><p>至此。CM安装成功。</p><p>9.关闭CDH</p><p>先关闭浏览器页面的服务。</p><p>上下两个一次关闭。</p><p>再关闭虚拟机命令行的服务。</p><p>搭建CDH集群</p><p>通过CM把CDH集群部署起来，部署的方式有四种：cm,yum,rpm,tarball,其中我们采用的是离线cdh</p><p>下面所有的操作都是在web界面上操作的；9个步骤，</p><p>如果不小心点击了外网的版本，那么就会从外网下载，这个时候点击返回，依旧会下载，那么唯一的解决办法</p><p>就是停掉server,进去之后会出现已下载，也就是我们早就下载好到了parcels-repo，当然会是100%；然后第二</p><p>个步骤是分配，就是把parcels-repo里面的软件分发到agent的parcel目录去；</p><p>cloudera建议我们的&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness交换内存为0，将这个文件设置为0即可；当然这样修改只是本次开机</p><p>下次开机依旧不会改成这样；可以改另一个文件；</p><p>我们后面看到的图表，监控都是来自于CM service;从最开始那个ppt图上面可以看到</p><p>在使用cm配置cdh的时候，默认是没有给我们做高可用，虽然我们使用的是cm版本五，使用的hadoop是2.x,但是</p><p>还是会有snn，只有在做了高可用之后snn才会消失；当我们只在cm上面安装hadoop的时候，有一个步骤，数据库检测</p><p>，由于安装hadoop不需要数据库，所以会一闪而过；</p><p>以下利用CM搭建CDH</p><p>Jar包存放位置：</p><p>&#x2F;opt&#x2F;cloudera&#x2F;parcels&#x2F;CDH-5.4.0-1.cdh5.4.0.p0.27</p><p>查看任务管理器–观察内存使用状况</p><p>注：添加新主机需重在新主机上装agent，步骤与上述步骤一样</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储-bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HADOOP——HA</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-hadoop-HA/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-hadoop-HA/</url>
      
        <content type="html"><![CDATA[<p><strong>一概述</strong></p><p><strong>（一）HDFS</strong></p><p>1）基础架构</p><p>（1）NameNode（Master）</p><ul><li>命名空间管理：命名空间支持对HDFS中的目录、文件和块做类似文件系统的创建、修改、删除、列表文件和目录等基本操作。</li><li>块存储管理</li></ul><p>（2）DataNode（Slaver）</p><p>namenode和client的指令进行存储或者检索block，并且周期性的向namenode节点报告它存了哪些文件的block</p><p>2）HA架构</p><p><img src="http://upload-images.jianshu.io/upload_images/3451200-d69f996fb6105a02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>使用Active NameNode，Standby NameNode 两个结点解决单点问题，两个结点通过JounalNode共享状态，通过ZKFC 选举Active ，监控状态，自动备援。</p><p>（1）Active NameNode：</p><p>接受client的RPC请求并处理，同时写自己的Editlog和共享存储上的Editlog，接收DataNode的Block report, block location updates和heartbeat；</p><p>（2）Standby NameNode：</p><p>同样会接到来自DataNode的Block report, block location updates和heartbeat，同时会从共享存储的Editlog上读取并执行这些log操作，使得自己的NameNode中的元数据（Namespcae information + Block locations map）都是和Active NameNode中的元数据是同步的。所以说Standby模式的NameNode是一个热备（Hot Standby NameNode），一旦切换成Active模式，马上就可以提供NameNode服务</p><p>（3）JounalNode：</p><p>用于Active NameNode ， Standby NameNode 同步数据，本身由一组JounnalNode结点组成，该组结点基数个，支持Paxos协议，保证高可用，是CDH5唯一支持的共享方式（相对于CDH4 促在NFS共享方式）</p><p>（4）ZKFC：</p><p>监控NameNode进程，自动备援。</p><p><strong>（二）YARN</strong></p><p>1）基础架构</p><p>（1）ResourceManager(RM)</p><p>接收客户端任务请求，接收和监控NodeManager(NM)的资源情况汇报，负责资源的分配与调度，启动和监控ApplicationMaster(AM)。</p><p>（2）NodeManager</p><p>节点上的资源管理，启动Container运行task计算，上报资源、container情况给RM和任务处理情况给AM。</p><p>（3）ApplicationMaster</p><p>单个Application(Job)的task管理和调度，向RM进行资源的申请，向NM发出launch Container指令，接收NM的task处理状态信息。NodeManager</p><p>（4）Web Application Proxy</p><p>用于防止Yarn遭受Web攻击，本身是ResourceManager的一部分，可通过配置独立进程。ResourceManager Web的访问基于守信用户，当Application Master运行于一个非受信用户，其提供给ResourceManager的可能是非受信连接，Web Application Proxy可以阻止这种连接提供给RM。</p><p>（5）Job History Server</p><p>NodeManager在启动的时候会初始化LogAggregationService服务, 该服务会在把本机执行的container log (在container结束的时候)收集并存放到hdfs指定的目录下. ApplicationMaster会把jobhistory信息写到hdfs的jobhistory临时目录下, 并在结束的时候把jobhisoty移动到最终目录, 这样就同时支持了job的recovery.History会启动web和RPC服务, 用户可以通过网页或RPC方式获取作业的信息</p><p>2）HA架构</p><p><img src="http://upload-images.jianshu.io/upload_images/3451200-8810986d1583c794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>ResourceManager HA 由一对Active，Standby结点构成，通过RMStateStore存储内部数据和主要应用的数据及标记。目前支持的可替代的RMStateStore实现有：基于内存的MemoryRMStateStore，基于文件系统的FileSystemRMStateStore，及基于zookeeper的ZKRMStateStore。</p><p>ResourceManager HA的架构模式同NameNode HA的架构模式基本一致，数据共享由RMStateStore，而ZKFC成为 ResourceManager进程的一个服务，非独立存在。</p><p>转载：<a href="http://shihlei.iteye.com/blog/2084711">http://shihlei.iteye.com/blog/2084711</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储-bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HADOOP——HDFS</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-hadoop-HDFS/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-hadoop-HDFS/</url>
      
        <content type="html"><![CDATA[<p>Namenode主要维护两个文件，一个是fsimage，一个是editlog。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://wx2.sinaimg.cn/mw690/005EpKr8ly1g1e8d4fiw6j30u00vpk7j.jpg" alt="img"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>fsimage保存了最新的元数据检查点，包含了整个HDFS文件系统的所有目录和文件的信息。对于文件来说包括了数据块描述信息、修改时间、访问时间等；对于目录来说包括修改时间、访问权限控制信息(目录所属用户，所在组)等。</p><p>editlog主要是在NameNode已经启动情况下对HDFS进行的各种更新操作进行记录，HDFS客户端执行所有的写操作都会被记录到editlog中。</p><p>简单来想，NameNode维护了文件与数据块的映射表以及数据块与数据节点的映射表，什么意思呢？就是一个文件，它切分成了几个数据块，以及这些数据块分别存储在哪些datanode上，namenode一清二楚。Fsimage就是在某一时刻，整个hdfs 的快照，就是这个时刻hdfs上所有的文件块和目录，分别的状态，位于哪些个datanode，各自的权限，各自的副本个数。然后客户端对hdfs所有的更新操作，比如说移动数据，或者删除数据，都会记录在editlog中。</p><p>为了避免editlog不断增大，secondary namenode会周期性合并fsimage和edits成新的fsimage，新的操作记录会写入新的editlog中，这个周期可以自己设置（editlog到达一定大小或者定时）。</p><p>可以很清晰看出，第一步：将hdfs更新记录写入一个新的文件——edits.new。</p><p>第二步：将fsimage和editlog通过http协议发送至secondary namenode。</p><p>第三步：将fsimage与editlog合并，生成一个新的文件——fsimage.ckpt。这步之所以要在secondary namenode中进行，是因为比较耗时，如果在namenode中进行，或导致整个系统卡顿。</p><p>第四步：将生成的fsimage.ckpt通过http协议发送至namenode。</p><p>第五步：重命名fsimage.ckpt为fsimage，edits.new为edits。</p><p>这样的话，fsimage与editlog合并的过程就完成了。所以如果namenode宕机，其实secondary namenode还保存这一份不久前的fsimage，还能挽回一些损失吧。</p><p>另外上篇中说，一旦有datanode挂掉了（宕机或者是网络阻塞），namenode能很快感知到，并且将宕机的节点上的数据块转移至其余空闲节点。这点是因为hdfs中心跳机制（heartbeat）。</p><p>心跳机制默认3s中一次，datanode会向namenode发送一次一跳，告知namenode当前节点上存放的数据文件是什么。如果namenode中记录的是该datanode存放了文件A的两个数据块和文件B的一个数据块，但是心跳中只有文件A的一个数据块信息，namenode就会知道该datanode数据块损坏了，会把损坏的数据块在别的datanode上补充。</p><p>转载：http:&#x2F;&#x2F;</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储-bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HADOOP——MapReduce</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-hadoop-MapReduce/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-hadoop-MapReduce/</url>
      
        <content type="html"><![CDATA[<p>问题导读</p><p>1.hadoop1.x中mapreduce框架与yarn有什么共同点？<br>2.它们有什么不同点？<br>3.yarn中有哪些改变？<br>4.yarn中有哪些术语？</p><p><img src="http://upload-images.jianshu.io/upload_images/3451200-27fd1512e63bfbdc.gif?imageMogr2/auto-orient/strip" alt="image"></p><p>原文：<a href="http://www.aboutyun.com/forum.php?mod=viewthread&tid=20891">Hadoop2.x 让你真正明白yarn</a></p><p><img src="http://upload-images.jianshu.io/upload_images/3451200-b62b0562f46ecdbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>yarn是比较难懂的一个地方，也是很重要的一个组件，不止hadoop使用yarn，spark，storm也可以使用yarn。因此yarn的理解是非常重要的。如果刚开始学习，其实还是挺难懂的。因为很多的概念比较抽象。<br>如果一时理解不了，也是正常的，这时候就需要我们不断的接触和思考，不断的找资料，强化，通过时间，慢慢就能熟记并且理解。下面是个人总结，希望对大家有所帮助。</p><p>相同点<br>hadoop2.x的发展是由于hadoop1.x的问题造成的。<br>那么是什么问题造成的。比较流行的说法是jobtracker的问题，比如单点故障，任务过重。我们知道了除了Jobtracker，同时还有一个TaskTracker。我们看下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/3451200-e01495480b3dd609.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>上图中，有一个JobTracker，多个TaskTracker。</p><p>Yarn比较<br>我们在来看yarn<br><img src="http://upload-images.jianshu.io/upload_images/3451200-15e09e70b83c5796.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>我们看到有一个ResourceManager，多个NodeManager。<br>也就是说hadoop1.x mapreduce框架与hadoop2.x yarn，他们的框架相同之处，都是分布式的。<br>再次总结相同处：<br>JobTracker一个，TaskTracker多个<br>resourceManager一个,NodeManager多个</p><p>不同点<br>既然他们框架结构是相同的，那么到底是什么原因，淘汰JobTracker机制。<br>这时候我们就需要看看JobTracker到底干了哪些事情。</p><p><img src="http://upload-images.jianshu.io/upload_images/3451200-3931425771663eb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>再看上图：JobTacker概述<br>JobTacker其承担的任务有：接受任务、计算资源、分配资源、与DataNode进行交流。<br>在hadoop中每个应用程序被表示成一个作业，每个作业又被分成多个任务，JobTracker的作业控制模块则负责作业的分解和状态监控。<br>*最重要的是状态监控：主要包括TaskTracker状态监控、作业状态监控和任务状态监控。主要作用：容错和为任务调度提供决策依据。<br>TaskTracker概述<br>TaskTracker是JobTracker和Task之间的桥梁：一方面，从JobTracker接收并执行各种命令：运行任务、提交任务、杀死任务等；另一方面，将本地节点上各个任务的状态通过心跳周期性汇报给JobTracker。TaskTracker与JobTracker和Task之间采用了RPC协议进行通信</p><p>TaskTracker的功能：<br>1.汇报心跳：Tracker周期性将所有节点上各种信息通过心跳机制汇报给JobTracker。这些信息包括两部分：<br>*机器级别信息：节点健康情况、资源使用情况等。<br>*任务级别信息：任务执行进度、任务运行状态等。<br>2.执行命令：JobTracker会给TaskTracker下达各种命令，主要包括：启动任务(LaunchTaskAction)、提交任务(CommitTaskAction)、杀死任务(KillTaskAction)、杀死作业(KillJobAction)和重新初始化(TaskTrackerReinitAction)。</p><p>资源slot概述<br>slot不是CPU的Core，也不是memory chip，它是一个逻辑概念，一个节点的slot的数量用来表示某个节点的资源的容量或者说是能力的大小，因而slot是 Hadoop的资源单位。</p><p>hadoop中什么是slots<br><a href="http://www.aboutyun.com/thread-7562-1-1.html">http://www.aboutyun.com/forum.php?mod=viewthread&tid=7562</a></p><p>yarn详解<br>Yarn的基本思想是拆分资源管理的功能，作业调度&#x2F;监控到单独的守护进程<br>这里面出现了很多名词：<br>ResourceManager，NodeManager，ApplicationMaster，Container,同样下面亦是yarn结构图。<br>ResourceManager是全局的，负责对于系统中的所有资源有最高的支配权。<br>ApplicationMaster 每一个job有一个ApplicationMaster 。<br>NodeManager，NodeManager是基本的计算框架。<br>NodeManager 是客户端框架负责 containers, 监控他们的资源使用 (cpu, 内存, 磁盘, 网络) 和上报给 ResourceManager&#x2F;Scheduler.<br>ApplicationMaster首先它是一个框架库，它的功能官网说的不够系统，大意，由于NodeManager 执行和监控任务需要资源，所以通过ApplicationMaster与ResourceManager沟通，获取资源。换句话说，ApplicationMaster起着中间人的作用。<br>转换为更专业的术语：AM负责向ResourceManager索要NodeManager执行任务所需要的资源容器，更具体来讲是ApplicationMaster负责从Scheduler申请资源，以及跟踪这些资源的使用情况以及任务进度的监控。</p><p>ResourceManager有两个组件：调度器和应用程序管理器。 <br>调度器（Scheduler）是可插拔的，比如有Fair Scheduler、Capacity Scheduler等，当然调度器也可以自定义。<br>更多相关内容：<br>Hadoop YARN配置参数剖析(4)—Fair Scheduler、Capacity Scheduler相关参数<br><a href="http://www.aboutyun.com/thread-5864-1-1.html">http://www.aboutyun.com/forum.php?mod=viewthread&tid=5864</a></p><p>应用程序管理器<br>负责接收提交的任务，指定ApplicationMaster申请资源（container） ，协调并提供在ApplicationMaster容器失败时的重启功能。</p><p>而下图也是官网提供内容，大家可以参考下。<br><img src="http://upload-images.jianshu.io/upload_images/3451200-a1be3818f9ef2cd4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>总结 为了更好的理解，我们就需要跟hadoop1.x比较：<br>为何要使用yarn。<br>我们看到JobTracker的功能被分散到各个进程中包括ResourceManager和NodeManager：<br>比如监控功能，分给了NodeManager，和Application Master。<br>ResourceManager里面又分为了两个组件：调度器及应用程序管理器。<br>也就是说Yarn重构后，JobTracker的功能，被分散到了各个进程中。同时由于这些进程可以被单独部署所以这样就大大减轻了单点故障，及压力。</p><p>同时我们还看到Yarn使用了Container，而hadoop1.x中使用了slot。slot存在的缺点比如只能map或则reduce用。Container则不存在这个问题。这也是Yarn的进步。</p><p>转载  http:&#x2F;&#x2F;</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储-bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb 常用脚步</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-mongodb-%E5%B8%B8%E7%94%A8%E8%84%9A%E6%AD%A5/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-mongodb-%E5%B8%B8%E7%94%A8%E8%84%9A%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">db.selectname.find(&#123;&#125;).count()</span><br><span class="line"></span><br><span class="line">db.shiXinPeople.find(&#123;&#125;).count()</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">*复合索引唯一</span><br><span class="line"></span><br><span class="line">*db.People.ensureIndex(&#123;&quot;Name&quot;:1,&quot;Age&quot;:1&#125;,&#123;&quot;unique&quot;:true,&quot;dropDups&quot;:true&#125;)</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">db.selectname.ensureIndex(&#123;&quot;selectName&quot;:1,&quot;city&quot;:1&#125;,&#123;&quot;unique&quot;:true,&quot;dropDups&quot;:true&#125;)</span><br><span class="line"></span><br><span class="line">db.shiXinPeople.ensureIndex(&#123;&quot;loc&quot;:1&#125;,&#123;&quot;unique&quot;:true,&quot;dropDups&quot;:true&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">*update 更新操作</span><br><span class="line"></span><br><span class="line">*db.classes.update(&#123;&quot;count&quot;:&#123;$gt:20&#125;&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;c4&quot;&#125;&#125;,false,true)</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">db.selectname.find(&#123;&quot;selectState&quot; : &quot;0&quot;&#125;).limit(2)</span><br><span class="line"></span><br><span class="line">db.selectname.update(&#123;&#125;,&#123;&quot;$set&quot;:&#123;&quot;start&quot;:0,&quot;selectState&quot;:&quot;0&quot;&#125;&#125;,false,true)</span><br><span class="line"></span><br><span class="line">db.selectname.update(&#123;&#125;,&#123;&quot;$unset&quot;:&#123;&quot;SelectState&quot;:&quot;&quot;&#125;&#125;,false,true)</span><br><span class="line"></span><br><span class="line">db.selectname.update(&#123;&#125;,&#123;$set:&#123;&quot;selectState&quot;:&quot;0&quot;&#125;&#125;,false,true)</span><br><span class="line"></span><br><span class="line">db.selectname.aggregate(&#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&#123;&quot;selectState&quot;:&quot;$selectState&quot;&#125;,&quot;count&quot;:&#123;$sum:1&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">db.selectname.find(&#123;&quot;selectState&quot;:&quot;1&quot;,&quot;start&quot;:&#123;$gte:1000&#125;&#125;)</span><br><span class="line"></span><br><span class="line">db.selectname.find(&#123;&quot;selectState&quot;:&quot;1&quot;&#125;)</span><br><span class="line"></span><br><span class="line">db.shiXinPeople.find(&#123;&#125;).count()</span><br><span class="line"></span><br><span class="line">db.shiXinPeople.distinct(&#x27;loc&#x27;)</span><br><span class="line"></span><br><span class="line">db.shiXinPeople.aggregate([&#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&#123;&quot;loc&quot;:&quot;$loc&quot;&#125;,&quot;count&quot;:&#123;$sum:1&#125;&#125;&#125;,&#123;&quot;$match&quot;:&#123;&quot;count&quot; : &#123;&quot;$gt&quot; : 1&#125;&#125;&#125;],&#123; allowDiskUse: true &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据存储-mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql mac安装</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-mysql-mac%E5%AE%89%E8%A3%85/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-mysql-mac%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>1.查询mysql安装，brew search mysql</p><p>2.安装mysql ，执行 brew install mysql</p><p> </p><p>3.设置密码，执行 mysql_secure_installation （google一下）</p><p> </p><p>4.连接到本机的mysql服务器，执行mysql.serve start</p><p> </p><p>5.登录</p><p>mysql  -uroot -p</p><p>输入密码</p><hr><p>此时注意，如果密码修改不成功，可以先用 </p><p>mysql -uroot   登录</p><p>然后修改密码</p><p>set password for ‘root‘@’localhost’ &#x3D; ‘Root_123’;</p><p> </p><p>注意：mysql8版本密码要求较高。</p><hr><p>如果其它机器无法连接这台mysql服务器，进行如下修改</p><p>vim  &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf</p><p>将里面的127.0.0.1改为0.0.0.0</p><p>重启mysql</p><p>brew services restart mysql</p><p>继续修改mysql.user表 实现远程登陆</p><p>select user,host from mysql.user;</p><p>update mysql.user set host&#x3D;’%’ where user&#x3D;’root’;</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储-mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql sql总结</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-mysql-sql%E6%80%BB%E7%BB%93/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-mysql-sql%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="1-两张表做积"><a href="#1-两张表做积" class="headerlink" title="1.两张表做积"></a>1.两张表做积</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from Students a, Teachers b</span><br></pre></td></tr></table></figure><h5 id="2-并列合并两张表"><a href="#2-并列合并两张表" class="headerlink" title="2.并列合并两张表"></a>2.并列合并两张表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># column数量相同</span><br><span class="line">select * from Scores union (select title,status from seed limit 2);</span><br></pre></td></tr></table></figure><h5 id="3-生成行标"><a href="#3-生成行标" class="headerlink" title="3.生成行标"></a>3.生成行标</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.Score,@num:=@num+1 from Scores a,(select @num := 0) b;</span><br></pre></td></tr></table></figure><h5 id="4-排名不跳，连续加1-但是有bug-如果score只有一个且为0"><a href="#4-排名不跳，连续加1-但是有bug-如果score只有一个且为0" class="headerlink" title="4.排名不跳，连续加1(但是有bug 如果score只有一个且为0)"></a>4.排名不跳，连续加1(但是有bug 如果score只有一个且为0)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.Score,if(@pre_score!=a.Score,@num:=@num+1,@num),@pre_score:=a.Score from Scores a,(select @pre_score:=0, @num := 0) b order by a.Score desc;</span><br></pre></td></tr></table></figure><h5 id="5-排名连续，不连跳"><a href="#5-排名连续，不连跳" class="headerlink" title="5.排名连续，不连跳"></a>5.排名连续，不连跳</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select d.Score,e.Rank from Scores d join (select b.*,@num:=@num+1 as &quot;Rank&quot; from (select * from (select Score from Scores group by Score) a order by a.Score desc) b,(select @num:=0) c) e on d.Score=e.Score order by d.Score desc;</span><br><span class="line">或者</span><br><span class="line">select d.Score,e.Rank from Scores d join (select b.*,@num:=@num+1 as &quot;Rank&quot; from (select distinct Score from Scores order by Score desc) b,(select @num:=0) c) e on d.Score=e.Score order by d.Score desc;</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">1. 去重排序子表</span><br><span class="line">select distinct Score from Scores order by Score desc</span><br><span class="line">2. 对子表添加排序</span><br><span class="line">select b.*,@num:=@num+1 as &quot;Rank&quot; from (select distinct Score from Scores order by Score desc) b,(select @num:=0) c</span><br><span class="line">3. join </span><br><span class="line">select d.Score,e.Rank from Scores d join (select b.*,@num:=@num+1 as &quot;Rank&quot; from (select distinct Score from Scores order by Score desc) b,(select @num:=0) c) e on d.Score=e.Score order by d.Score desc;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据存储-mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 参数优化</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-mysql-%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-mysql-%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-参数优化"><a href="#mysql-参数优化" class="headerlink" title="mysql 参数优化"></a>mysql 参数优化</h1><ol><li><p>最大连接数   优化：<a href="http://database.51cto.com/art/201010/229936.htm">http://database.51cto.com/art/201010/229936.htm</a></p><ul><li>max_connections&#x3D;1000</li></ul></li><li><p>表高速缓存区大小  优化地址 ： <a href="http://www.cnblogs.com/fjping0606/p/6531292.html">http://www.cnblogs.com/fjping0606/p/6531292.html</a></p><ul><li>table_open_cache&#x3D;256</li></ul></li><li><p>开启查询缓存  优化地址：<a href="http://www.jb51.net/article/58537.htm">http://www.jb51.net/article/58537.htm</a></p><ul><li>query_cache_type&#x3D;1</li></ul></li><li><p>查询缓存大小</p><ul><li>query_cache_size&#x3D;1M</li></ul></li><li><p>临时表大小  优化地址：<a href="http://www.jb51.net/article/85341.htm">http://www.jb51.net/article/85341.htm</a></p><ul><li>tmp_table_size&#x3D;32M</li></ul></li><li><p>线程缓存数    <a href="http://www.jb51.net/article/51828.htm">http://www.jb51.net/article/51828.htm</a></p><ul><li>thread_cache_size&#x3D;8</li></ul></li><li><p>关闭DNS做反向地址查询    <a href="http://blog.chinaunix.net/uid-9370128-id-1687475.html">http://blog.chinaunix.net/uid-9370128-id-1687475.html</a></p><ul><li>skip-name-resolve&#x3D;1</li></ul></li><li><p>忘记密码后进行密码重置</p><ul><li>skip-grant-tables&#x3D;1</li></ul></li><li><p>innodb_flush_log_at_trx_commit和sync_binlog 两个参数是控制MySQL 磁盘写入策略     <a href="http://blog.itpub.net/22664653/viewspace-1063134/">http://blog.itpub.net/22664653/viewspace-1063134/</a></p><ul><li>innodb_flush_log_at_trx_commit &#x3D;2</li><li>sync_binlog&#x3D;5000</li></ul></li><li><p>慢查询配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line"></span><br><span class="line">long_query_time=5</span><br><span class="line"></span><br><span class="line">slow_query_log_file=&quot;D:/MySQL/data/query-slow-file.log&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">innodb_log_buffer_size=128M</span><br><span class="line"></span><br><span class="line">innodb_buffer_pool_size=128M</span><br><span class="line"></span><br><span class="line">innodb_log_file_size=10M</span><br><span class="line"></span><br><span class="line">innodb_thread_concurrency=16</span><br><span class="line"></span><br><span class="line">innodb-autoextend-increment=1000</span><br><span class="line"></span><br><span class="line">join_buffer_size = 128M</span><br><span class="line"></span><br><span class="line">sort_buffer_size = 32M</span><br><span class="line"></span><br><span class="line">read_rnd_buffer_size = 32M</span><br><span class="line"></span><br><span class="line">max_allowed_packet = 32M</span><br></pre></td></tr></table></figure></li><li><p>关闭警告     <a href="http://www.jb51.net/article/71105.htm">http://www.jb51.net/article/71105.htm</a></p><ul><li>explicit_defaults_for_timestamp&#x3D;true</li></ul></li><li><p>sql模式       <a href="http://blog.csdn.net/zhaoxuejie/article/details/50844380">http://blog.csdn.net/zhaoxuejie/article/details/50844380</a></p><ul><li>sql-mode&#x3D;”STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据存储-mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 索引</title>
      <link href="/2025/05/18/%E6%95%B0%E6%8D%AE-mysql-%E7%B4%A2%E5%BC%95/"/>
      <url>/2025/05/18/%E6%95%B0%E6%8D%AE-mysql-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h3 id="从数据结构角度"><a href="#从数据结构角度" class="headerlink" title="从数据结构角度"></a>从数据结构角度</h3><p>1、B+树索引(O(log(n)))：关于B+树索引，可以参考MySQL索引背后的数据结构及算法原理 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><p>2、hash索引：</p><p>a 仅仅能满足”&#x3D;”,”IN”和”&lt;&#x3D;&gt;”查询，不能使用范围查询</p><p>b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引</p><p>c 只有Memory存储引擎显示支持hash索引</p><p>3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）</p><p>4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）</p><h3 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h3><p>1、聚集索引（clustered index）</p><p>2、非聚集索引（non-clustered index）</p><h3 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h3><p>1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值</p><p>2、普通索引或者单列索引</p><p>3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</p><p>4、唯一索引或者非唯一索引</p><p>5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。</p><p>MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</p><p>CREATE TABLE table_name[col_name data type][unique|fulltext|spatial][index|key]<a href="col_name%5Blength%5D">index_name</a>[asc|desc]</p><p>1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；</p><p>2、index和key为同义词，两者作用相同，用来指定创建索引</p><p>3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；</p><p>4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；</p><p>5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</p><p>6、asc或desc指定升序或降序的索引值存储</p><h3 id="MySQL里的索引类型主要有以下几种。"><a href="#MySQL里的索引类型主要有以下几种。" class="headerlink" title="MySQL里的索引类型主要有以下几种。"></a>MySQL里的索引类型主要有以下几种。</h3><ol><li>B-Tree索引</li></ol><p>最常见的索引类型，基于B-Tree数据结构。B-Tree的基本思想是，所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。</p><ol start="2"><li>Hash索引</li></ol><p>基于hash表。所以这种索引只支持精确查找，不支持范围查找，不支持排序。这意味着范围查找或ORDER BY都要依赖server层的额外工作。目前只有Memory引擎支持显式的hash索引（但是它的hash是nonunique的，冲突太多时也会影响查找性能）。Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引。</p><p>例子：</p><p>CREATETABLEtesthash (    fnameVARCHAR(50)NOTNULL,    lnameVARCHAR(50)NOTNULL,KEYUSINGHASH(fname))ENGINE&#x3D;MEMORY;</p><ol start="3"><li>Spatial (R-Tree)（空间）索引</li></ol><p>只有MyISAM引擎支持，并且支持的不好。可以忽略。</p><ol start="4"><li>Full-text索引</li></ol><p>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。Full-text索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的WHERE语句的参数匹配。你可以对某列分别进行full-text索引和B-Tree索引，两者互不冲突。Full-text索引配合MATCH AGAINST操作使用，而不是一般的WHERE语句加LIKE。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储-mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP—Word2vec词向量表达</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-NLP%E2%80%94Word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E8%A1%A8%E8%BE%BE/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-NLP%E2%80%94Word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E8%A1%A8%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<p>原理：<br><a href="http://www.cnblogs.com/pinard/p/7160330.html">word2vec原理(一) CBOW与Skip-Gram模型基础</a><br><a href="http://www.cnblogs.com/pinard/p/7243513.html">word2vec原理(二) 基于Hierarchical Softmax的模型</a><br><a href="http://www.cnblogs.com/pinard/p/7249903.html">word2vec原理(三) 基于Negative Sampling的模型</a></p><p>实验：<br>转载：<a href="https://www.zybuluo.com/hanxiaoyang/note/472184">https://www.zybuluo.com/hanxiaoyang/note/472184</a></p><p>个人理解：自然语言向量表达，用于比较词的相识度，位置词预测<br>过程： one hot 编码-》构建共现矩阵-》（巧妙采用Huffman编码树【离根节点近的节点出现概率越大】来做神经网络输出函数）-》调整theta 的值计算缺失的词（CBOW）或句子（Skip-Gram）<br>后期优化：负采样代替Huffman编码</p><p>问题：矩阵的svd分解意义</p>]]></content>
      
      
      <categories>
          
          <category> 算法-NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP—分词发展</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-NLP%E2%80%94%E5%88%86%E8%AF%8D%E5%8F%91%E5%B1%95/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-NLP%E2%80%94%E5%88%86%E8%AF%8D%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1基本信息"><a href="#1基本信息" class="headerlink" title="1基本信息"></a>1基本信息<a href="http://baike.baidu.com/link?url=Fwc_1d9MsKEzuRma0qlRtvp1ezxyeV3eYC2BD1Q_ggFphnL8SI3NcOKLPT6BitQC#" title="编辑本段"></a></h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>存在中文<a href="http://baike.baidu.com/view/2699566.htm">分词技术</a>，是由于中文在基本文法上有其特殊性，具体表现在：</p><p>1．以英文为代表的拉丁语系语言相比，英文以空格作为天然的分隔符，而中文由于继承自古代汉语的传统，词语之间没有分隔。　古代汉语中除了连绵词和人名地名等，词通常就是单个汉字，所以当时没有分词书写的必要。而现代汉语中双字或多字词居多，一个字不再等同于一个词。</p><p>2．在中文里，“词”和“词组”边界模糊</p><p>现代汉语的基本表达单元虽然为“词”，且以双字或者多字词居多，但由于人们认识水平的不同，对词和短语的边界很难去区分。</p><p>例如：“对随地吐痰者给予处罚”，“随地吐痰者”本身是一个词还是一个短语，不同的人会有不同的标准，同样的“海上”“酒厂”等等，即使是同一个人也可能做出不同判断，如果汉语真的要分词书写，必然会出现混乱，难度很大。</p><p>中文分词的方法其实不局限于中文应用，也被应用到英文处理，如手写识别，单词之间的空格就很清楚，中文分词方法可以帮助判别英文单词的边界。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>中文分词是文本挖掘的基础，对于输入的一段中文，成功的进行中文分词，可以达到电脑自动识别语句含义的效果。</p><p>中文<a href="http://baike.baidu.com/view/2699566.htm">分词技术</a>属于<a href="http://baike.baidu.com/view/18784.htm">自然语言处理</a>技术范畴，对于一句话，人可以通过自己的知识来明白哪些是词，哪些不是词，但如何让计算机也能理解？其处理过程就是分词算法。</p><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p><sup>[1]</sup>中文分词对于搜索引擎来说，最重要的并不是找到所有结果，因为在上百亿的网页中找到所有结果没有太多的意义，没有人能看得完，最重要的是把最相关的结果排在最前面，这也称为相关度排序。中文分词的准确与否，常常直接影响到对搜索结果的相关度排序。从定性分析来说，搜索引擎的分词算法不同，词库的不同都会影响页面的返回结果。</p><h2 id="2算法分类"><a href="#2算法分类" class="headerlink" title="2算法分类"></a>2算法分类<a href="http://baike.baidu.com/link?url=Fwc_1d9MsKEzuRma0qlRtvp1ezxyeV3eYC2BD1Q_ggFphnL8SI3NcOKLPT6BitQC#" title="编辑本段"></a></h2><p>现有的分词算法可分为三大类：基于<a href="http://baike.baidu.com/view/1436430.htm">字符串匹配</a>的分词方法、基于理解的分词方法和基于统计的分词方法。按照是否与词性标注过程相结合，又可以分为单纯分词方法和分词与标注相结合的一体化方法。</p><h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><p>这种方法又叫做机械分词方法，它是按照一定的策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行配，若在词典中找到某个字符串，则匹配成功（识别出一个词）。按照扫描方向的不同，串匹配分词方法可以分为正向匹配和逆向匹配；按照不同长度优先匹配的情况，可以分为最大（最长）匹配和最小（最短）匹配；常用的几种机械分词方法如下：</p><p>1）正向最大匹配法（由左到右的方向）；</p><p>2）逆向最大匹配法（由右到左的方向）；</p><p>3）最少切分（使每一句中切出的词数最小）；</p><p>4）双向最大匹配法（进行由左到右、由右到左两次扫描）</p><p>还可以将上述各种方法相互组合，例如，可以将正向最大匹配方法和逆向最大匹配方法结合起来构成双向匹配法。由于汉语单字成词的特点，正向最小匹配和逆向最小匹配一般很少使用。一般说来，逆向匹配的切分精度略高于正向匹配，遇到的歧义现象也较少。统计结果表明，单纯使用正向最大匹配的错误率为1&#x2F;169，单纯使用逆向最大匹配的错误率为1&#x2F;245。但这种精度还远远不能满足实际的需要。实际使用的分词系统，都是把机械分词作为一种初分手段，还需通过利用各种其它的语言信息来进一步提高切分的准确率。</p><p>一种方法是改进<a href="http://baike.baidu.com/view/115274.htm">扫描方式</a>，称为特征扫描或标志切分，优先在待分析字符串中识别和切分出一些带有明显特征的词，以这些词作为<a href="http://baike.baidu.com/view/278359.htm">断点</a>，可将原字符串分为较小的串再来进机械分词，从而减少匹配的错误率。另一种方法是将分词和词类标注结合起来，利用丰富的词类信息对分词决策提供帮助，并且在标注过程中又反过来对分词结果进行检验、调整，从而极大地提高切分的准确率。</p><p>对于机械分词方法，可以建立一个一般的模型，在这方面有专业的学术论文，这里不做详细论述。</p><h3 id="理解法"><a href="#理解法" class="headerlink" title="理解法"></a>理解法</h3><p>这种分词方法是通过让计算机模拟人对句子的理解，达到识别词的效果。其基本思想就是在分词的同时进行句法、<a href="http://baike.baidu.com/view/487035.htm">语义分析</a>，利用句法信息和语义信息来处理歧义现象。它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断，即它模拟了人对句子的理解过程。这种分词方法需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式，因此目前基于理解的分词系统还处在试验阶段。</p><h3 id="统计法"><a href="#统计法" class="headerlink" title="统计法"></a>统计法</h3><p>从形式上看，词是稳定的字的组合，因此在上下文中，相邻的字同时出现的次数越多，就越有可能构成一个词。因此字与字相邻共现的频率或概率能够较好的反映成词的可信度。可以对语料中相邻共现的各个字的组合的频度进行统计，计算它们的互现信息。定义两个字的互现信息，计算两个汉字X、Y的相邻共现概率。互现信息体现了汉字之间结合关系的紧密程度。当紧密程度高于某一个阈值时，便可认为此字组可能构成了一个词。这种方法只需对语料中的字组频度进行统计，不需要切分词典，因而又叫做无词典分词法或统计取词方法。但这种方法也有一定的局限性，会经常抽出一些共现频度高、但并不是词的常用字组，例如“这一”、“之一”、“有的”、“我的”、“许多的”等，并且对常用词的识别精度差，时空开销大。实际应用的统计分词系统都要使用一部基本的分词词典（常用词词典）进行串匹配分词，同时使用统计方法识别一些新的词，即将串频统计和串匹配结合起来，既发挥匹配分词切分速度快、效率高的特点，又利用了无词典分词结合上下文识别生词、自动消除歧义的优点。</p><p>另外一类是基于统计<a href="http://baike.baidu.com/view/7956.htm">机器学习</a>的方法。首先给出大量已经分词的文本，利用统计<a href="http://baike.baidu.com/view/7956.htm">机器学习</a>模型学习词语切分的规律（称为训练），从而实现对未知文本的切分。我们知道，汉语中各个字单独作词语的能力是不同的，此外有的字常常作为前缀出现，有的字缺常常作为后缀（“者”“性”），结合两个字相临时是否成词的信息，这样就得到了许多与分词有关的知识。这种方法就是充分利用汉语组词的规律来分词。这种方法的最大缺点是需要有大量预先分好词的语料作支撑，而且训练过程中时空开销极大。</p><p>到底哪种分词算法的准确度更高，目前并无定论。对于任何一个成熟的分词系统来说，不可能单独依靠某一种算法来实现，都需要综合不同的算法。例如，海量科技的分词算法就采用“复方分词法”，所谓复方，就是像中西医结合般综合运用机械方法和知识方法。对于成熟的中文分词系统，需要多种算法综合处理问题。</p><p>转载：<a href="https://blog.csdn.net/likika2012/article/details/17026935?locationNum=6&fps=1">https://blog.csdn.net/likika2012/article/details/17026935?locationNum=6&amp;fps=1</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法-NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP—博客推荐</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-NLP%E2%80%94%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-NLP%E2%80%94%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3451200-a99c4eb45daef408?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="http://upload-images.jianshu.io/upload_images/3451200-d8d9affb8da2ac7b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>NLP词法、句法、语义、语篇综合系列： <br><a href="http://blog.csdn.net/sinat_26917383/article/details/52275328">NLP+词法系列（一）︱中文分词技术小结、几大分词引擎的介绍与比较</a> <br><a href="http://blog.csdn.net/sinat_26917383/article/details/55682577">NLP+词法系列（二）︱中文分词技术及词性标注研究现状（CIPS2016）</a> <br><a href="http://blog.csdn.net/sinat_26917383/article/details/55682996">NLP+句法结构（三）︱中文句法结构研究现状（CIPS2016）</a> <br><a href="http://blog.csdn.net/sinat_26917383/article/details/55683599">NLP+语义分析（四）︱中文语义分析研究现状（CIPS2016）</a> <br><a href="http://blog.csdn.net/sinat_26917383/article/details/55683843">NLP+语篇分析（五）︱中文语篇分析研究现状（CIPS2016）</a></p><p>转载：<a href="https://blog.csdn.net/sinat_26917383/article/details/55682577">https://blog.csdn.net/sinat_26917383/article/details/55682577</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法-NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP—HMM</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-NlP%E2%80%94HMM/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-NlP%E2%80%94HMM/</url>
      
        <content type="html"><![CDATA[<p>经典的blog ：<a href="https://www.cnblogs.com/skyme/p/4651331.html">https://www.cnblogs.com/skyme/p/4651331.html</a><br>基本思想：根据观察序列找出最有可能的隐藏状态序列<br>个人理解<br>    1.什么是马尔科夫链？    具有马尔科夫行为过程<br>    2.什么是马尔科夫过程 ？ 未来取决于现在不取决于过去</p>]]></content>
      
      
      <categories>
          
          <category> 算法-NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hash相关题</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash/</url>
      
        <content type="html"><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        if len(nums)&lt;3: return []</span><br><span class="line">        nums.sort()</span><br><span class="line">        res=set()</span><br><span class="line">        for i , x in enumerate(nums[:-2]):</span><br><span class="line">            if i&gt;=1 and x==nums[i-1]:</span><br><span class="line">                continue</span><br><span class="line">            d=&#123;&#125;</span><br><span class="line">            for j in nums[i+1:]:</span><br><span class="line">                # 判断 -（x+j）=j</span><br><span class="line">                if j not in d:</span><br><span class="line">                    d[-x-j]=1</span><br><span class="line">                else:</span><br><span class="line">                    res.add((x,-j-x,j))</span><br><span class="line">        </span><br><span class="line">        return map(list,res)</span><br></pre></td></tr></table></figure><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Trie():</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.root=&#123;&#125;</span><br><span class="line">        self.end_word=&quot;#&quot;</span><br><span class="line"></span><br><span class="line">    def insert(self,word):</span><br><span class="line">        node=self.root</span><br><span class="line">        for char in word:</span><br><span class="line">            node=node.setdefault(char,&#123;&#125;)</span><br><span class="line">        node[self.end_word]=self.end_word</span><br><span class="line"></span><br><span class="line">    def find(self,word):</span><br><span class="line">        node=self.root</span><br><span class="line">        for char in word:</span><br><span class="line">            if char not in node:</span><br><span class="line">                return False</span><br><span class="line">            node=node[char]</span><br><span class="line">        return self.end_word in node</span><br><span class="line"></span><br><span class="line">    def startWith(self,word):</span><br><span class="line">        node = self.root</span><br><span class="line">        for char in word:</span><br><span class="line">            if char not in node:</span><br><span class="line">                return False</span><br><span class="line">            node = node[char]</span><br><span class="line">        return True</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-二分</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%88%86/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def search(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not nums: return -1</span><br><span class="line">        left = 0</span><br><span class="line">        right =len(nums)-1</span><br><span class="line">        while(left&lt;=right):</span><br><span class="line">            mid=(left+right)//2</span><br><span class="line">            if nums[mid]==target:</span><br><span class="line">                return mid</span><br><span class="line">            elif nums[mid]&gt; target:</span><br><span class="line">                right=mid-1</span><br><span class="line">            else:</span><br><span class="line">                left=mid+1</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure><h1 id="求平方根"><a href="#求平方根" class="headerlink" title="求平方根"></a>求平方根</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def mySqrt(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if x==0 or x==1: return x</span><br><span class="line">        left =0</span><br><span class="line">        right =x</span><br><span class="line">        # 控制精度</span><br><span class="line">        while(right-left&gt;0.001):</span><br><span class="line">            mid = (left + right) / 2</span><br><span class="line">            if mid == x/mid: return mid</span><br><span class="line">            if mid&lt;x/mid:</span><br><span class="line">                left=mid</span><br><span class="line">            else:</span><br><span class="line">                right=mid</span><br><span class="line">        return &quot;%.3f&quot;%left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">除此之外，可用用牛顿迭代法</span><br><span class="line">=&gt;  x2=x1-f(x)/f(x)`</span><br><span class="line">=&gt;  x2=(x+a/x)/2</span><br><span class="line">class Solution(object):</span><br><span class="line">    def mySqrt(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        a,x1,n=x,x,0</span><br><span class="line">        # 1e-9代表进度</span><br><span class="line">        while(abs(x1-n)&gt;1e-9):</span><br><span class="line">            n = x1</span><br><span class="line">            x1= (x1+a/x1)/2</span><br><span class="line">            print(n,x1,str(&quot;%.5f&quot;%(n-x1)))</span><br><span class="line">        return x1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-动态规划</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>动态规划&#x3D;回溯+贪心</p><h1 id="dp-由来"><a href="#dp-由来" class="headerlink" title="dp 由来"></a>dp 由来</h1><ol><li>暴力穷举</li><li>带备忘录的递归</li><li>非递归的动态规划 即：dp table</li></ol><h1 id="dp-解题思路"><a href="#dp-解题思路" class="headerlink" title="dp 解题思路"></a>dp 解题思路</h1><ol><li>递归+记忆化-&gt; 递推（倒推）</li><li>状态的定义： opt[n],dp[n],fib[n]</li><li>状态转移方程：opt[n]&#x3D;best_of(opt[n-1],opt(n-2))</li><li>最优子结构</li></ol><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>dp(n) 定义：第n层的解法<br>dp动态转移方程 &#x3D;&gt; dp(n)&#x3D;n (n&lt;2)<br>             &#x3D;&gt; dp(n)&#x3D;dp(n-1)+dp(n-2) (n&gt;&#x3D;2)</p><h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p>dp[n] 定义：够成面值n最小的硬笔数量<br>dp动态转移方程 &#x3D;&gt; dp(n)&#x3D;n (n&#x3D;0)<br>             &#x3D;&gt; dp(n)&#x3D;min(dp[n-coin[j]]+1])</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-回溯法</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>回溯（递归）-重复计算</p><h1 id="基本思想类同于："><a href="#基本思想类同于：" class="headerlink" title="基本思想类同于："></a>基本思想类同于：</h1><pre><code>图的深度优先搜索二叉树的后序遍历</code></pre><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><ol><li>装载问题</li><li>0-1背包问题</li><li>旅行售货员问题</li><li>八皇后问题</li><li>迷宫问题</li><li>图的m着色问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-堆</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆（二叉堆，斐波那契堆）"><a href="#堆（二叉堆，斐波那契堆）" class="headerlink" title="堆（二叉堆，斐波那契堆）"></a>堆（二叉堆，斐波那契堆）</h1><h1 id="流式数据第k大（或者第k小）的元素是多少-时间负责度nlog2-k"><a href="#流式数据第k大（或者第k小）的元素是多少-时间负责度nlog2-k" class="headerlink" title="流式数据第k大（或者第k小）的元素是多少 ;时间负责度nlog2(k)"></a>流式数据第k大（或者第k小）的元素是多少 ;时间负责度nlog2(k)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 第k个最大用小顶堆，第k个最小用大顶堆</span><br><span class="line">class KthLargest &#123;</span><br><span class="line">    private int k;</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; q;</span><br><span class="line"></span><br><span class="line">    public KthLargest(int k,int[] nums)&#123;</span><br><span class="line">        this.k=k;</span><br><span class="line">        this.q=new PriorityQueue&lt;&gt;(k);</span><br><span class="line">        for(int a:nums)&#123;</span><br><span class="line">            add(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer add(int val)&#123;</span><br><span class="line">        if(q.size()&lt;this.k)</span><br><span class="line">            q.offer(val);</span><br><span class="line">        else if(q.peek()&lt;val)&#123;</span><br><span class="line">            q.poll();</span><br><span class="line">            q.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        return q.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口题-每次求最大值"><a href="#滑动窗口题-每次求最大值" class="headerlink" title="滑动窗口题,每次求最大值"></a>滑动窗口题,每次求最大值</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def maxSlidingWindow(nums, k: int):</span><br><span class="line">    if not nums:return []</span><br><span class="line">    window,res=[],[]</span><br><span class="line">    for i,a in enumerate(nums):</span><br><span class="line">        if i&gt;=k and window[0]&lt;=i-k:</span><br><span class="line">            window.pop(0)</span><br><span class="line">        while window and nums[window[-1]]&lt;=a:</span><br><span class="line">            window.pop(-1)</span><br><span class="line">        window.append(i)</span><br><span class="line">        if i&gt;=k-1:</span><br><span class="line">            res.append(nums[window[0]])</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-并查集</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ol><li>优化一（将高的tree作为root,降低树的高度）</li><li>优化二 (递归路径压缩)</li><li>解题思路<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. find union 代码不变</span><br><span class="line">2. self.count 代表需要合并的节点（岛屿，朋友）对角矩阵问题节点只有一般</span><br><span class="line">3. self.parent 代表初始化节点树，若是二维数组非对角矩阵问题需降纬</span><br><span class="line">4. 寻找需要合并的条件</span><br></pre></td></tr></table></figure></li></ol><h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class UnionSet():</span><br><span class="line">    </span><br><span class="line">    def __init__(self,grid):</span><br><span class="line">        m, n = len(grid), len(grid[0])</span><br><span class="line">        # 代表需要合并的节点（岛屿，朋友）</span><br><span class="line">        self.count=0</span><br><span class="line">        self.parent=[]</span><br><span class="line">        # 将二维数组降纬</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if grid[i][j]==&#x27;1&#x27;:</span><br><span class="line">                    self.count+=1</span><br><span class="line">                self.parent.append(i*n+j)</span><br><span class="line">        # 树的秩，也就是高度。初始化数量与节点树相同</span><br><span class="line">        self.rank=[0 for i in range(m*n)]</span><br><span class="line">    </span><br><span class="line">    def find(self,x):</span><br><span class="line">        if self.parent[x]!=x:</span><br><span class="line">            self.parent[x]=self.find(self.parent[x])</span><br><span class="line">        return self.parent[x]</span><br><span class="line">    </span><br><span class="line">    def union(self,x,y):</span><br><span class="line">        rootx=self.find(x)</span><br><span class="line">        rooty=self.find(y)</span><br><span class="line">        </span><br><span class="line">        if rootx!=rooty:</span><br><span class="line">            if self.rank[rootx]&lt;self.rank[rooty]:</span><br><span class="line">                self.parent[rootx]=rooty</span><br><span class="line">                self.rank[rootx]+=1</span><br><span class="line">            elif self.rank[rootx]&gt;self.rank[rooty]:</span><br><span class="line">                self.parent[rooty]=rootx</span><br><span class="line">                self.rank[rooty]+=1</span><br><span class="line">            else:</span><br><span class="line">                self.parent[rooty]=rootx</span><br><span class="line">                self.rank[rooty]+=1</span><br><span class="line">            self.count-=1</span><br><span class="line"></span><br><span class="line">class Solution():</span><br><span class="line">    def numIslands(self,grid):</span><br><span class="line">        if not grid or not grid[0]:</span><br><span class="line">            return 0</span><br><span class="line">        m, n = len(grid), len(grid[0])</span><br><span class="line">        direction=[(1,0),(-1,0),(0,1),(0,-1)]</span><br><span class="line">        us=UnionSet(grid)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if grid[i][j]==&#x27;0&#x27;:</span><br><span class="line">                    continue</span><br><span class="line">                for d in direction:</span><br><span class="line">                    nc,nr=i+d[0],j+d[1]</span><br><span class="line">                    if nc&gt;=0 and nr&gt;=0 and nc &lt;m and nr &lt;n and grid[nc][nr]==&quot;1&quot;:</span><br><span class="line">                        us.union(i*n+j,nc*n+nr)                    </span><br><span class="line">        return us.count</span><br></pre></td></tr></table></figure><h1 id="朋友圈个数"><a href="#朋友圈个数" class="headerlink" title="朋友圈个数"></a>朋友圈个数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class UnionSet():</span><br><span class="line">    </span><br><span class="line">    def __init__(self,grid):</span><br><span class="line">        m, n = len(grid), len(grid[0])</span><br><span class="line">        self.count=m</span><br><span class="line">        self.parent=[]</span><br><span class="line">        for i in range(m):</span><br><span class="line">            self.parent.append(i)</span><br><span class="line">        self.rank=[0 for i in range(m)]</span><br><span class="line">    </span><br><span class="line">    def find(self,x):</span><br><span class="line">        if self.parent[x]!=x:</span><br><span class="line">            self.parent[x]=self.find(self.parent[x])</span><br><span class="line">        return self.parent[x]</span><br><span class="line">    </span><br><span class="line">    def union(self,x,y):</span><br><span class="line">        rootx=self.find(x)</span><br><span class="line">        rooty=self.find(y)</span><br><span class="line">        </span><br><span class="line">        if rootx!=rooty:</span><br><span class="line">            if self.rank[rootx]&lt;self.rank[rooty]:</span><br><span class="line">                self.parent[rootx]=rooty</span><br><span class="line">                self.rank[rootx]+=1</span><br><span class="line">            elif self.rank[rootx]&gt;self.rank[rooty]:</span><br><span class="line">                self.parent[rooty]=rootx</span><br><span class="line">                self.rank[rooty]+=1</span><br><span class="line">            else:</span><br><span class="line">                self.parent[rooty]=rootx</span><br><span class="line">                self.rank[rooty]+=1</span><br><span class="line">            self.count-=1</span><br><span class="line"></span><br><span class="line">class Solution():</span><br><span class="line">    def findCircleNum(self,grid):</span><br><span class="line">        if not grid or not grid[0]:</span><br><span class="line">            return 0</span><br><span class="line">        m, n = len(grid), len(grid[0])</span><br><span class="line">        us=UnionSet(grid)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if grid[i][j]==1:</span><br><span class="line">                    us.union(i,j)                    </span><br><span class="line">        return us.count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-栈与列表</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E5%88%97%E8%A1%A8/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1. 有效的括号"></a>1. 有效的括号</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isValid(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        stack=[]</span><br><span class="line">        kuo_hao=&#123;&quot;(&quot;:&quot;)&quot;,&quot;&#123;&quot;:&quot;&#125;&quot;,&quot;[&quot;:&quot;]&quot;&#125;</span><br><span class="line">        for a in s:</span><br><span class="line">            if a in kuo_hao:</span><br><span class="line">                stack.append(a)</span><br><span class="line">            else:</span><br><span class="line">                if not stack:</span><br><span class="line">                    return False</span><br><span class="line">                if stack and kuo_hao[stack.pop()]!=a:</span><br><span class="line">                    return False</span><br><span class="line">        return not stack</span><br></pre></td></tr></table></figure><h1 id="2-两个队列实现一个栈"><a href="#2-两个队列实现一个栈" class="headerlink" title="2. 两个队列实现一个栈"></a>2. 两个队列实现一个栈</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># 存使用l ,取也是l只不过是最后一个。</span><br><span class="line">class MyStack(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Initialize your data structure here.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.queue_l=[]</span><br><span class="line">        self.queue_r=[]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    def push(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Push element x onto stack.</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.queue_l.append(x)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Removes the element on top of the stack and returns that element.</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while len(self.queue_l)&gt;1:</span><br><span class="line">            self.queue_r.append(self.queue_l.pop(0))</span><br><span class="line">        value= self.queue_l.pop(0)</span><br><span class="line">        while self.queue_r:</span><br><span class="line">            self.queue_l.append(self.queue_r.pop(0))</span><br><span class="line">        return value</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def top(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Get the top element.</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while len(self.queue_l)&gt;1:</span><br><span class="line">            self.queue_r.append(self.queue_l.pop(0))</span><br><span class="line">        value= self.queue_l.pop(0)</span><br><span class="line">        if value is not None:</span><br><span class="line">            self.queue_r.append(value)</span><br><span class="line">        while self.queue_r:</span><br><span class="line">            self.queue_l.append(self.queue_r.pop(0))</span><br><span class="line">        return value</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def empty(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns whether the stack is empty.</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return not self.queue_l</span><br></pre></td></tr></table></figure><h1 id="3-两个栈实现一个队列"><a href="#3-两个栈实现一个队列" class="headerlink" title="3. 两个栈实现一个队列"></a>3. 两个栈实现一个队列</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 存放在l,取从r中取，再把r中值晴空写回l</span><br><span class="line">class MyQueue(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Initialize your data structure here.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.stack_l = []</span><br><span class="line">        self.stack_r = []</span><br><span class="line"></span><br><span class="line">    def push(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Push element x to the back of queue.</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.stack_l.append(x)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Removes the element from in front of queue and returns that element.</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while self.stack_l:</span><br><span class="line">            self.stack_r.append(self.stack_l.pop())</span><br><span class="line">        value= self.stack_r.pop()</span><br><span class="line">        while self.stack_r:</span><br><span class="line">            self.stack_l.append(self.stack_r.pop())</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    def peek(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Get the front element.</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while self.stack_l:</span><br><span class="line">            self.stack_r.append(self.stack_l.pop())</span><br><span class="line">        value= self.stack_r.pop()</span><br><span class="line">        self.stack_r.append(value)</span><br><span class="line">        while self.stack_r:</span><br><span class="line">            self.stack_l.append(self.stack_r.pop())</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    def empty(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns whether the queue is empty.</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while self.stack_l:</span><br><span class="line">            self.stack_r.append(self.stack_l.pop())</span><br><span class="line">        return (not self.stack_r)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-树</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="1-判断是否二叉搜索树"><a href="#1-判断是否二叉搜索树" class="headerlink" title="1. 判断是否二叉搜索树"></a>1. 判断是否二叉搜索树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line">class TreeNode:</span><br><span class="line">     def __init__(self, x):</span><br><span class="line">         self.val = x</span><br><span class="line">         self.left = None</span><br><span class="line">         self.right = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    node_list=[]</span><br><span class="line">    return_flag=True</span><br><span class="line">    def isValidBST(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        self.in_order(root)</span><br><span class="line">        return self.return_flag</span><br><span class="line"></span><br><span class="line">    def in_order(self,root):</span><br><span class="line">        if root is None: return</span><br><span class="line">        self.isValidBST(root.left)</span><br><span class="line">        if not self.node_list or self.node_list[-1]&lt;root.val:</span><br><span class="line">            self.node_list.append(root.val)</span><br><span class="line">        else:</span><br><span class="line">            self.node_list.append(root.val)</span><br><span class="line">            self.return_flag= False</span><br><span class="line">            return</span><br><span class="line">        self.isValidBST(root.right)</span><br></pre></td></tr></table></figure><h1 id="2-二叉树的最近公共祖先"><a href="#2-二叉树的最近公共祖先" class="headerlink" title="2. 二叉树的最近公共祖先"></a>2. 二叉树的最近公共祖先</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root == None or root.val ==q or root.val==p : return root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right= self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        if left is None:</span><br><span class="line">            return right</span><br><span class="line">        elif right is None:</span><br><span class="line">            return left</span><br><span class="line">        else:</span><br><span class="line">            return root.val</span><br></pre></td></tr></table></figure><h1 id="3-二叉树广度优先遍历-BFS"><a href="#3-二叉树广度优先遍历-BFS" class="headerlink" title="3. 二叉树广度优先遍历 BFS"></a>3. 二叉树广度优先遍历 BFS</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def BFS(root):</span><br><span class="line"></span><br><span class="line">    q=[]</span><br><span class="line">    q.append(root)</span><br><span class="line">    num=[]</span><br><span class="line"></span><br><span class="line">    while q:</span><br><span class="line">        size=len(q)</span><br><span class="line"></span><br><span class="line">        current_num=[]</span><br><span class="line">        for i in range(size):</span><br><span class="line">            root=q.pop(0)</span><br><span class="line">            current_num.append(root.data)</span><br><span class="line">            if root.left_child is not None: q.append(root.left_child)</span><br><span class="line">            if root.right_child is not None: q.append(root.right_child)</span><br><span class="line">        num.append(current_num)</span><br><span class="line"></span><br><span class="line">    return num</span><br></pre></td></tr></table></figure><h1 id="4-二叉树深度优先遍历-DFS"><a href="#4-二叉树深度优先遍历-DFS" class="headerlink" title="4. 二叉树深度优先遍历 DFS"></a>4. 二叉树深度优先遍历 DFS</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def DFS(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return</span><br><span class="line">    print(root.data)</span><br><span class="line">    if root.left_child is not None: DFS(root.left_child)</span><br><span class="line">    if root.right_child is not None: DFS(root.right_child)</span><br></pre></td></tr></table></figure><p>1.二叉树</p><ol><li>构建二叉查找树</li><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li><li>构建平衡二叉树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode():</span><br><span class="line">    </span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.left_child=None</span><br><span class="line">        self.right_child=None</span><br><span class="line">        self.data=x</span><br><span class="line"></span><br><span class="line">class Tree():</span><br><span class="line"></span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.tree_data=[]</span><br><span class="line">        self.root=None</span><br><span class="line"></span><br><span class="line">    def insert(self,root,x):</span><br><span class="line">        &quot;&quot;&quot; 构造二叉查找树 &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return TreeNode(x)</span><br><span class="line">        if root.data &gt; x:</span><br><span class="line">            root.left_child=self.insert(root.left_child,x)</span><br><span class="line">        else:</span><br><span class="line">            root.right_child=self.insert(root.right_child,x)</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preorder(slef,root):</span><br><span class="line">        “”“ 先序遍历 ”“”</span><br><span class="line">        if not root : return</span><br><span class="line">        self.tree_data.append(root.data)</span><br><span class="line">        self.preorder(root.left_child)</span><br><span class="line">        self.preorder(root.right_child)</span><br><span class="line"></span><br><span class="line">    def inorder(slef,root):</span><br><span class="line">        “”“ 中序遍历 ”“”</span><br><span class="line">        if not root : return</span><br><span class="line">        self.inorder(root.left_child)</span><br><span class="line">        self.tree_data.append(root.data)</span><br><span class="line">        self.inorder(root.right_child)</span><br><span class="line"></span><br><span class="line">    def postorder(slef,root):</span><br><span class="line">        “”“ 后序遍历 ”“”</span><br><span class="line">        if not root : return</span><br><span class="line">        self.postorder(root.left_child)</span><br><span class="line">        self.postorder(root.right_child)</span><br><span class="line">        self.tree_data.append(root.data)</span><br><span class="line"></span><br><span class="line">    def insert2(self,root,x):</span><br><span class="line">        &quot;&quot;&quot; 构建平衡二叉树 &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return TreeNode(x)</span><br><span class="line"></span><br><span class="line">        tree_node=[root]</span><br><span class="line">        wile True:</span><br><span class="line">            node=tree_node.pop(0)</span><br><span class="line">            if node.left_child is None:</span><br><span class="line">                node.left_child=TreeNode(x)</span><br><span class="line">                return root</span><br><span class="line">            elif node.right_child is None:</span><br><span class="line">                node.right_child=TreeNode(x)</span><br><span class="line">                return root</span><br><span class="line">            else:</span><br><span class="line">                tree_node.append(node.left_child)</span><br><span class="line">                tree_node.append(node.right_child)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-树的子节点-判断是不是一颗树的子树"><a href="#2-树的子节点-判断是不是一颗树的子树" class="headerlink" title="2.树的子节点(判断是不是一颗树的子树)"></a>2.树的子节点(判断是不是一颗树的子树)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def subTree(root,sub_root):</span><br><span class="line">    if root is None or sub_root is None:</span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">    return isSubTree(root,sub_root) || subTree(root.left,sub_root) || subTree(root.right,sub_root)</span><br><span class="line"></span><br><span class="line">def isSubTree(root,sub_root):</span><br><span class="line">    if sub_root is None:</span><br><span class="line">        return True</span><br><span class="line">    if root is None:</span><br><span class="line">        return False</span><br><span class="line">    if root.data!= sub_root.data:</span><br><span class="line">        return False</span><br><span class="line">    return isSubTree(root.left,sub_root.left) and isSubTree(root.right,sub_root.right)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="3-二叉树的镜像"><a href="#3-二叉树的镜像" class="headerlink" title="3.二叉树的镜像"></a>3.二叉树的镜像</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def mirror(root)</span><br><span class="line">    if root is None:</span><br><span class="line">        return</span><br><span class="line">    swap(root)</span><br><span class="line">    mirror(root.left)</span><br><span class="line">    mirror(root.right)</span><br><span class="line"></span><br><span class="line">def swap(root)</span><br><span class="line">    root.left,root.right=root.right,root.left</span><br></pre></td></tr></table></figure><h1 id="4-判处是否是对称二叉树"><a href="#4-判处是否是对称二叉树" class="headerlink" title="4.判处是否是对称二叉树"></a>4.判处是否是对称二叉树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def subTree(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return false</span><br><span class="line">    return isSubTree(root.eft,root.right)</span><br><span class="line"></span><br><span class="line">def isSubTree(root,sub_root):</span><br><span class="line">    if sub_root is None:</span><br><span class="line">        return True</span><br><span class="line">    if root is None:</span><br><span class="line">        return False</span><br><span class="line">    if root.data!= sub_root.data:</span><br><span class="line">        return False</span><br><span class="line">    return isSubTree(root.left,sub_root.left) and isSubTree(root.right,sub_root.right)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-递归</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%92%E5%BD%92/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="实现pow函数-分治递归"><a href="#实现pow函数-分治递归" class="headerlink" title="实现pow函数 (分治递归)"></a>实现pow函数 (分治递归)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def myPow(self, x, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: float</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: float</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        </span><br><span class="line">        if n&lt;0:</span><br><span class="line">            return 1/self.my_pow(x,-n)</span><br><span class="line">        else:</span><br><span class="line">            return self.my_pow(x,n)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    def my_pow(self,x,y):</span><br><span class="line">        if y==0: return 1</span><br><span class="line">        if y==1: return x</span><br><span class="line">        if y%2==0:</span><br><span class="line">            n=y/2</span><br><span class="line">            return self.my_pow(x, n)*self.my_pow(x, n)</span><br><span class="line">        else:</span><br><span class="line">            n=(y-1)/2</span><br><span class="line">            return self.my_pow(x, n) * self.my_pow(x, n)*x</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="括号生成-（递归，树的深度遍历，剪枝）"><a href="#括号生成-（递归，树的深度遍历，剪枝）" class="headerlink" title="括号生成 （递归，树的深度遍历，剪枝）"></a>括号生成 （递归，树的深度遍历，剪枝）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def generateParenthesis(self, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.res=[]</span><br><span class="line">        self._gen(&quot;&quot;,n,n)</span><br><span class="line">        return self.res</span><br><span class="line">    </span><br><span class="line">    def _gen(self,s_kuo,left,right):</span><br><span class="line">        if left==0 and right==0:</span><br><span class="line">            self.res.append(s_kuo)  </span><br><span class="line">        if left&gt;0:</span><br><span class="line">            self._gen(s_kuo+&quot;(&quot;,left-1,right)</span><br><span class="line">        if right&gt;left:</span><br><span class="line">            self._gen(s_kuo+&quot;)&quot;,left,right-1)</span><br></pre></td></tr></table></figure><h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def solveNQueens(self, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        坐标逆时针旋转90度理解p+q ,p-q</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        def DFS(cols,pie,na):</span><br><span class="line">            p=len(cols)</span><br><span class="line">            if p&gt;=n:</span><br><span class="line">                result.append(cols)</span><br><span class="line">                return None</span><br><span class="line">            for q in range(n):</span><br><span class="line">                if q not in cols and p-q not in pie and p+q not in na:</span><br><span class="line">                    DFS(cols+[q],pie+[p-q],na+[p+q])</span><br><span class="line">        result=[]</span><br><span class="line">        DFS([],[],[])</span><br><span class="line">        return [[ &#x27;.&#x27;*i+&#x27;Q&#x27;+&#x27;.&#x27;*(n-1-i) for i in cols] for cols in result]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数据结构-链表</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1.链表反转"></a>1.链表反转</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Node():</span><br><span class="line">    def __init__(slef,data):</span><br><span class="line">        self.next=None</span><br><span class="line">        self.data=data</span><br><span class="line"></span><br><span class="line"># 方法一</span><br><span class="line">def reverse(head):</span><br><span class="line">    if head.next is None:</span><br><span class="line">        return head</span><br><span class="line"></span><br><span class="line">    next=head.next</span><br><span class="line">    head.next=None</span><br><span class="line">    current_next=revers(next)</span><br><span class="line">    next.next=head</span><br><span class="line">    return current_next</span><br><span class="line"></span><br><span class="line"># 方法二</span><br><span class="line">def swap_reverse(head):</span><br><span class="line">    cur,prev=head,None</span><br><span class="line">    while cur:</span><br><span class="line">        cur.next,prev,cur=prev,cur,cur.next</span><br><span class="line">    return prev</span><br></pre></td></tr></table></figure><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># class ListNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def swapPairs(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">       if head is None or head.next is None : return head</span><br><span class="line">       next = head.next</span><br><span class="line">       head.next=self.swapPairs(next.next)</span><br><span class="line">       next.next=head</span><br><span class="line">       return next </span><br></pre></td></tr></table></figure><h1 id="3-判断链表是否有环"><a href="#3-判断链表是否有环" class="headerlink" title="3.判断链表是否有环"></a>3.判断链表是否有环</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 正常思维</span><br><span class="line">item = set()</span><br><span class="line">class Solution(object):</span><br><span class="line"></span><br><span class="line">    def hasCycle(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        global item</span><br><span class="line">        if head is None or head.next is None:</span><br><span class="line">            return False</span><br><span class="line">        a = item &amp; &#123;head&#125;</span><br><span class="line">        if len(a) != 0:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            item.update(&#123;head&#125;)</span><br><span class="line">            return self.hasCycle(head.next)</span><br><span class="line"># 龟兔赛跑</span><br><span class="line">class Solution(object):</span><br><span class="line"></span><br><span class="line">    def hasCycle(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        fast,slow=head,head</span><br><span class="line">        while fast and fast.next and fast.next.next:</span><br><span class="line">            slow,fast=slow.next,fast.next.next</span><br><span class="line">            if slow==fast:</span><br><span class="line">                return True     </span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h1 id="2-链表合并"><a href="#2-链表合并" class="headerlink" title="2.链表合并"></a>2.链表合并</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Node():</span><br><span class="line">    def __init__(slef,data):</span><br><span class="line">        self.next=None</span><br><span class="line">        self.data=data</span><br><span class="line"></span><br><span class="line">def merge(head1,head2):</span><br><span class="line">    if head1 is None:</span><br><span class="line">        return head2</span><br><span class="line">    if head2 is None:</span><br><span class="line">        return head1</span><br><span class="line">    if head1.data&lt;=head2.data:</span><br><span class="line">        head1.next=merge(head1.next,head2)</span><br><span class="line">        return head1</span><br><span class="line">    else:</span><br><span class="line">        head2.next=merger(head1,head2.next)</span><br><span class="line">        return head2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-机器学习-案例</title>
      <link href="/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A1%88%E4%BE%8B/"/>
      <url>/2025/05/18/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>1.泰坦尼克号预测<br> <a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143">https://blog.csdn.net/han_xiaoyang/article/details/49797143</a><br>2.房屋估计预测<br> <a href="https://github.com/xiaoyusmd/Bj_HousePricePredict/blob/master/%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E4%B8%8E%E5%88%86%E6%9E%90.ipynb">https://github.com/xiaoyusmd/Bj_HousePricePredict/blob/master/%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E4%B8%8E%E5%88%86%E6%9E%90.ipynb</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法-机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-hook-java</title>
      <link href="/2024/05/21/%E9%80%86%E5%90%91-hook-java/"/>
      <url>/2024/05/21/%E9%80%86%E5%90%91-hook-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搬砖</p></blockquote><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="ArtMethod-hook"><a href="#ArtMethod-hook" class="headerlink" title="ArtMethod hook"></a>ArtMethod hook</h2><h3 id="1-xposed"><a href="#1-xposed" class="headerlink" title="1. xposed"></a>1. xposed</h3><pre><code>步骤一：hookMethod-&gt;hookMethodNative-&gt;XposedBridge_hookMethodNative-&gt;EnableXposedHook  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 核心:传递参数，替换artmethod entrypoint</span><br><span class="line">SetEntryPointFromJniPtrSize(reinterpret_cast&lt;uint8_t*&gt;(hook_info), sizeof(void*));</span><br><span class="line">SetEntryPointFromQuickCompiledCode(GetQuickProxyInvokeHandler());</span><br></pre></td></tr></table></figure>步骤二：触发函数调用进入 artQuickProxyInvokeHandler  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 通过反射调用“handleHookedMethod”</span><br><span class="line">InvokeXposedHandleHookedMethod(soa, shorty, rcvr_jobj, proxy_methodid, args);</span><br><span class="line">// Call XposedBridge.handleHookedMethod</span><br><span class="line">jvalue invocation_args[5];</span><br><span class="line">invocation_args[0].l = hook_info-&gt;reflected_method;</span><br><span class="line">invocation_args[1].i = 1;</span><br><span class="line">invocation_args[2].l = hook_info-&gt;additional_info;</span><br><span class="line">invocation_args[3].l = rcvr_jobj;</span><br><span class="line">invocation_args[4].l = args_jobj;</span><br><span class="line">jobject result =</span><br><span class="line">soa.Env()-&gt;CallStaticObjectMethodA(ArtMethod::xposed_callback_class,</span><br><span class="line">                                   ArtMethod::xposed_callback_method,</span><br><span class="line">                                   invocation_args);</span><br></pre></td></tr></table></figure>步骤三：在XposedBridge的handleHookedMethod进行aop,完成hook  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before: ((XC_MethodHook) callbacksSnapshot[beforeIdx]).beforeHookedMethod(param);</span><br><span class="line">origin: param.setResult(invokeOriginalMethodNative(method, originalMethodId,</span><br><span class="line">additionalInfo.parameterTypes, additionalInfo.returnType, param.thisObject, param.args));</span><br><span class="line">after: ((XC_MethodHook) callbacksSnapshot[afterIdx]).afterHookedMethod(param);</span><br></pre></td></tr></table></figure></code></pre><h3 id="2-lsplant"><a href="#2-lsplant" class="headerlink" title="2. lsplant"></a>2. <a href="https://github.com/5ec1cff/my-notes/blob/master/lsplant.md">lsplant</a></h3><pre><code>步骤一: 将需要hook对象-target目标，和中间对象NativeHooker绑定到一起  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// new LSPosedBridge.NativeHooker.class</span><br><span class="line">auto init = env-&gt;GetMethodID(hooker, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/Executable;)V&quot;);</span><br><span class="line">// 中间方法</span><br><span class="line">auto callback_method = env-&gt;ToReflectedMethod(hooker, env-&gt;GetMethodID(hooker, &quot;callback&quot;,</span><br><span class="line">                                                                        &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;),</span><br><span class="line">                                              false);                   </span><br><span class="line">auto hooker_object = env-&gt;NewObject(hooker, init, hookMethod);</span><br><span class="line">hook_item-&gt;SetBackup(lsplant::Hook(env, hookMethod, hooker_object, callback_method));</span><br></pre></td></tr></table></figure>步骤二：通过BuildDex 生成一个与taget目标参数一样的hook bridge方法，然后多出第一个参数来存放this 指针,函数主要是调用NativeHooker 的callback方法步骤三：生成跳板，将原始函数的artmethod替换为动态生成的hook bridge的artmethod核心点：  1. 生成跳板并修改entry_point 完成hook  2. 在 Java 中，非静态方法（实例方法）的调用隐式地传递了一个 this 指针作为第一个参数。所以如果你要用一个静态方法去替换原来的实例方法，你需要显式地把这个 this 指针作为静态方法的第一个参数实际案例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    LSPlant : lsplant.cc:676#bool lsplant::(anonymous namespace)::DoHook(ArtMethod *, ArtMethod *, ArtMethod *): Hooking: target = java.lang.String org.lsposed.lsplant.LSPTest.manyParametersMethod(java.lang.String, boolean, byte, short, int, long, float, double, java.lang.Integer, java.lang.Long)(0x795d3ef120), hook = java.lang.Object LSPHooker_.manyParametersMethod(java.lang.Object, java.lang.Object, boolean, byte, short, int, long, float, double, java.lang.Object, java.lang.Object)(0x795d323050), backup = java.lang.Object LSPHooker_.backup(java.lang.Object, java.lang.Object, boolean, byte, short, int, long, float, double, java.lang.Object, java.lang.Object)(0x795d323030)</span><br><span class="line">LSPlant : lsplant.cc:657#void *lsplant::(anonymous namespace)::GenerateTrampolineFor(art::ArtMethod *): trampoline: count = 0, address = 7cafdbc000, target = 7cafdbc000</span><br><span class="line">LSPlant : lsplant.cc:683#bool lsplant::(anonymous namespace)::DoHook(ArtMethod *, ArtMethod *, ArtMethod *): Generated trampoline 0x7cafdbc000</span><br><span class="line">LSPlant : lsplant.cc:699#bool lsplant::(anonymous namespace)::DoHook(ArtMethod *, ArtMethod *, ArtMethod *): Done hook: target(0x795d3ef120:0x1a000000) -&gt; 0x7cafdbc000; backup(0x795d323030:0x1a000002) -&gt; 0x797e222320; hook(0x795d323050:0x12080009) -&gt; 0x797e222070 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，任何非静态方法隐式地接收 this 作为第一个参数。在 Android ART 环境里进行方法替换时，如果原始的非静态方法（org.lsposed.lsplant.LSPTest.manyParametersMethod）被替换为一个静态方法（LSPHooker_.manyParametersMethod），那么这个静态方法需要显式地声明一个额外的参数来接收原本隐式传递的 this 指针。</span><br><span class="line"></span><br><span class="line">因此，LSPHooker_.manyParametersMethod 的第一个参数类型是 java.lang.Object，它是为了通用性设计的，可以接收任意类型的 Java 对象。这个参数在运行时将接收原始方法的 this 指针，即实例对应的 org.lsposed.lsplant.LSPTest 对象实例。</span><br><span class="line"></span><br><span class="line">这样，在运行时，调用 LSPHooker_.manyParametersMethod 时，会将原始 target 方法被调用时的 this 指针和所有其他参数正确地传递给 hook 方法。因此，第一个参数总是用于 this 指针，而后续的参数将是 target 方法原来的参数，保持相同的顺序。 </span><br><span class="line"></span><br><span class="line">在 LSPHooker_.manyParametersMethod 方法内，你可以像处理其他参数一样处理 this 指针参数，如果你需要调用原始对象的其他非静态成员，可以将 java.lang.Object 类型的 this 指针参数转换回原始类的类型。</span><br><span class="line"></span><br><span class="line">简单地说：</span><br><span class="line"></span><br><span class="line">当原始方法（target）的 entry_point 被替换为 hook 方法的地址时，</span><br><span class="line">任何对原始 target 方法的调用都会被重定向到你的 hook 方法，</span><br><span class="line">由于 hook 方法是静态的，LSPHooker_.manyParametersMethod 需要一个额外的参数来接收 this 指针，</span><br><span class="line">在 hook 方法的第一个参数位置，你将得到原始实例的 this 指针，你可以把它看作是任何传递给 target 方法的常规参数。 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我猜是生成一个大致这样的类</span><br><span class="line">public class LSPHooker_ &#123;</span><br><span class="line">      static C1 hooker;</span><br><span class="line">      public static Object backup(Object obj) &#123;</span><br><span class="line">               return null;</span><br><span class="line">      &#125;</span><br><span class="line">      public static Object manyParametersMethod(Object arg0, int arg1, ... /* 其他参数 */)  &#123;</span><br><span class="line">        Object[] hook_params_array = new Object[parameter_types.size()];</span><br><span class="line">        hook_params_array[0] = arg0; // 假设arg0已经是Object类型</span><br><span class="line">        hook_params_array[1] = Integer.valueOf(arg1); // 对于原始类型进行装箱操作</span><br><span class="line">        // 对于更多参数的处理...</span><br><span class="line">        return hooker.callback(hook_params_array);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>        </code></pre><h3 id="3-dexposed-on-art"><a href="#3-dexposed-on-art" class="headerlink" title="3. dexposed-on-art"></a>3. <a href="https://weishu.me/2017/11/23/dexposed-on-art/">dexposed-on-art</a></h3><pre><code>source-&gt;原始函数,被hook函数target-&gt;hook函数,是一个entry步骤一：创建跳板    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private byte[] createTrampoline(ArtMethod source)&#123;</span><br><span class="line">  final Epic.MethodInfo methodInfo = Epic.getMethodInfo(source.getAddress());</span><br><span class="line">  final Class&lt;?&gt; returnType = methodInfo.returnType;</span><br><span class="line"></span><br><span class="line">  // 动态创建一个（Bridge｜class对象中method｜artmethod｜target）</span><br><span class="line">  Method bridgeMethod = Runtime.is64Bit() ? Entry64.getBridgeMethod(returnType)</span><br><span class="line">          : Entry.getBridgeMethod(returnType);</span><br><span class="line">  final ArtMethod target = ArtMethod.of(bridgeMethod);</span><br><span class="line">  long targetAddress = target.getAddress();</span><br><span class="line">  long targetEntry = target.getEntryPointFromQuickCompiledCode();</span><br><span class="line">  long sourceAddress = source.getAddress();</span><br><span class="line">  long structAddress = EpicNative.malloc(4);</span><br><span class="line"></span><br><span class="line">  Logger.d(TAG, &quot;targetAddress:&quot;+ Debug.longHex(targetAddress));</span><br><span class="line">  Logger.d(TAG, &quot;sourceAddress:&quot;+ Debug.longHex(sourceAddress));</span><br><span class="line">  Logger.d(TAG, &quot;targetEntry:&quot;+ Debug.longHex(targetEntry));</span><br><span class="line">  Logger.d(TAG, &quot;structAddress:&quot;+ Debug.longHex(structAddress));</span><br><span class="line">  // 生成跳板</span><br><span class="line">  return shellCode.createBridgeJump(targetAddress, targetEntry, sourceAddress, structAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//跳板逻辑</span><br><span class="line">byte[] instructions = new byte[]&#123;</span><br><span class="line">    0x1f, 0x20, 0x03, (byte) 0xd5,         // nop</span><br><span class="line">    0x69, 0x02, 0x00, 0x58,                // ldr x9, source_method</span><br><span class="line">    0x1f, 0x00, 0x09, (byte) 0xeb,         // cmp x0, x9</span><br><span class="line">    (byte) 0xa1, 0x02, 0x00, 0x54,         // bne 5f</span><br><span class="line">    (byte) 0x80, 0x01, 0x00, 0x58,         // ldr x0, target_method</span><br><span class="line"></span><br><span class="line">    0x29, 0x02, 0x00, 0x58,                // ldr x9, struct</span><br><span class="line">    (byte) 0xea, 0x03, 0x00, (byte) 0x91,  // mov x10, sp</span><br><span class="line"></span><br><span class="line">    0x2a, 0x01, 0x00, (byte) 0xf9,         // str x10, [x9, #0]</span><br><span class="line">    0x22, 0x05, 0x00, (byte) 0xf9,         // str x2, [x9, #8]</span><br><span class="line"></span><br><span class="line">    0x23, 0x09, 0x00, (byte) 0xf9,         // str x3, [x9, #16]</span><br><span class="line">    (byte) 0xe3, 0x03, 0x09, (byte) 0xaa,  // mov x3, x9</span><br><span class="line">    0x22, 0x01, 0x00, 0x58,                // ldr x2, source_method</span><br><span class="line">    0x22, 0x0d, 0x00, (byte) 0xf9,         // str x2, [x9, #24]</span><br><span class="line">    (byte) 0xe2, 0x03, 0x13, (byte) 0xaa,  // mov x2, x19</span><br><span class="line">    (byte) 0x89, 0x00, 0x00, 0x58,         // ldr x9, target_method_entry</span><br><span class="line">    0x20, 0x01, 0x1f, (byte) 0xd6,         // br x9</span><br><span class="line"></span><br><span class="line">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // target_method_address</span><br><span class="line">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // target_method_entry</span><br><span class="line">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // source_method</span><br><span class="line">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // struct</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>步骤二：修改原函数artmethod的entrypoint，直接加载指向跳板    步骤三：由跳板得知，当触发函数调用的时候会直接进入target_method_entry，原函数的参数通过申请的struct结构体填充到相关栈帧的地址上并传递进入到（Bridge｜class对象中method｜artmethod｜target）中。    步骤四：解析出原始artmethod，参数，对象。回调onHook，进入handleHookedArtMethod逻辑    步骤五：handleHookedArtMethod中通过aop方式（before-&gt;反射调用原函数-&gt;after）完成hook    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static Object handleHookedArtMethod(Object artMethodObject, Object thisObject, Object[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    XC_MethodHook.MethodHookParam param = new XC_MethodHook.MethodHookParam();</span><br><span class="line">    param.method  = (Member) (artmethod).getExecutable();</span><br><span class="line">    param.thisObject = thisObject;</span><br><span class="line">    param.args = args;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ((XC_MethodHook) callbacksSnapshot[beforeIdx]).beforeHookedMethod(param);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // call original method if not requested otherwise</span><br><span class="line">    if (!param.returnEarly) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        ArtMethod method = Epic.getBackMethod(artmethod);</span><br><span class="line">        Object result = method.invoke(thisObject, args);</span><br><span class="line">        param.setResult(result);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">        // log(e); origin throw exception is normal.</span><br><span class="line">        param.setThrowable(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ((XC_MethodHook) callbacksSnapshot[afterIdx]).afterHookedMethod(param);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="jvmti"><a href="#jvmti" class="headerlink" title="jvmti"></a>jvmti</h2>]]></content>
      
      
      <categories>
          
          <category> 逆向-hook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-内核-root方案</title>
      <link href="/2024/04/18/%E9%80%86%E5%90%91-android-root%E6%96%B9%E6%A1%88/"/>
      <url>/2024/04/18/%E9%80%86%E5%90%91-android-root%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搬砖</p></blockquote><h1 id="root方案"><a href="#root方案" class="headerlink" title="root方案"></a>root方案</h1><h2 id="1-magisk"><a href="#1-magisk" class="headerlink" title="1. magisk"></a>1. magisk</h2><h2 id="2-kernelSu"><a href="#2-kernelSu" class="headerlink" title="2. kernelSu"></a>2. kernelSu</h2><h3 id="2-1-gki-kmi-lkm-概念"><a href="#2-1-gki-kmi-lkm-概念" class="headerlink" title="2.1 gki kmi lkm 概念"></a>2.1 gki kmi lkm 概念</h3><pre><code>**LKM（Linux Kernel Module）**实际上是一种用于在运行时动态加载到 Linux 内核中的代码块，通常用于添加设备驱动程序、文件系统等扩展内核功能。LKM 不一定是基于 KMI 开发的；它们可以是基于任何 Linux 内核版本开发的，用于扩展或添加到那个特定内核版本的功能。在 Android 的 GKI（Generic Kernel Image） 系统中，**KMI（Kernel Module Interface）**是一系列稳定的 API 和 ABI（应用编程接口和应用二进制接口）的定义，这些接口被设计为在内核版本之间保持兼容性。因此，在 Android GKI 的上下文中，设备制造商和硬件供应商可以开发LKM，这些模块符合KMI的规范，以保证它们的内核模块与当前和未来的 GKI 版本兼容。也就是说，LKM 是模块本身，而 KMI 是确保这些模块与 GKI 兼容所需遵循的一系列接口规范。所以，可以这样理解：设备制造商和硬件供应商基于 KMI 开发他们自己的 LKM。这样开发的 LKM 可以在不同版本的 GKI 上加载而不会出现兼容性问题。简而言之，LKM 是根据 KMI 规范开发的内核模块，它们依靠 KMI 的稳定性，使得它们与 GKI 的不同版本兼容。</code></pre><h3 id="2-2-Android编译"><a href="#2-2-Android编译" class="headerlink" title="2.2 Android编译"></a>2.2 Android编译</h3><pre><code>#export REPO_URL=&#39;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#39;#export REPO_URL=&#39;https://gerrit.googlesource.com/git-repo&#39;mkdir aosp14 &amp;&amp; cd aosp14repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android14-releaserepo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-15.0.0_r8repo init -u https://android.googlesource.com/platform/manifest -b android-14.0.0_r2repo init -u https://android.googlesource.com/platform/manifest -b android-15.0.0_r8repo sync -j16source build/envsetup.shlunch XXXemulator</code></pre><p>  遇到问题:<br>    1. <a href="https://stackoverflow.com/questions/71073999/qemu-system-x86-64-address-resolution-failed-for-146189-name-or-service-no">ipv6导致的黑屏</a></p><h3 id="2-3-内核构建"><a href="#2-3-内核构建" class="headerlink" title="2.3 内核构建"></a>2.3 内核构建</h3><ol><li><p><a href="https://source.android.com/docs/setup/build/building-kernels?hl=zh-cn">官方文档</a></p></li><li><p><a href="https://kernelsu.org/guide/how-to-build.html">kernelSu</a></p></li><li><p><a href="https://clientinfra.com/android-kernel-build-and-debug/">Cuttlefish</a> 模拟器内核开发</p><ul><li><p>注意版本问题，通过 uname -a 查看内核版本<br>  “Linux localhost 6.1.23-android14-4-00257-g7e35917775b8-ab9964412 #1 SMP PREEMPT Mon Apr 17 20:50:58 UTC 2023 x86_64 Toybox”</p><p>  我当前编译分支<br>  aosp版本： repo init -u <a href="https://android.googlesource.com/platform/manifest">https://android.googlesource.com/platform/manifest</a> -b android-14.0.0_r2<br>  kenel版本：repo init -u <a href="https://android.googlesource.com/kernel/manifest">https://android.googlesource.com/kernel/manifest</a> -b common-android14-6.1</p></li><li><p>实战: <a href="https://clientinfra.com/android-kernel-build-and-debug/">参考链接0</a> <a href="https://juejin.cn/post/7343138429939269651">参考链接1</a> <a href="https://zhuanlan.zhihu.com/p/681425804">参考链接2</a></p><ol><li><p>安装cuttlefish前端<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grep -c -w &quot;vmx\|svm&quot; /proc/cpuinfo</span><br><span class="line"># 安装依赖</span><br><span class="line">sudo apt install -y git devscripts config-package-dev debhelper-compat curl</span><br><span class="line"># 下载代码</span><br><span class="line">git clone https://github.com/google/android-cuttlefish.git</span><br><span class="line">cd android-cuttlefish</span><br><span class="line"># 提起准备好go环境</span><br><span class="line">go version</span><br><span class="line"># 编译</span><br><span class="line">for dir in base frontend; do</span><br><span class="line">  cd $dir</span><br><span class="line">  debuild -i -us -uc -b -d</span><br><span class="line">  cd ..</span><br><span class="line">done</span><br><span class="line"># 安装</span><br><span class="line">sudo apt install ./cuttlefish-base_*.deb ./cuttlefish-user_*.deb</span><br></pre></td></tr></table></figure></p></li><li><p>aosp 编译 lunch aosp_cf_x86_64_phone-userdebuge<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-14.0.0_r2</span><br><span class="line">repo sync </span><br><span class="line">lunch aosp_cf_x86_64_phone-userdebuge</span><br><span class="line">m -jXX</span><br></pre></td></tr></table></figure></p></li><li><p>kenel 编译<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://android.googlesource.com/kernel/manifest -b common-android14-6.1</span><br><span class="line">repo sync </span><br><span class="line">tools/bazel run //common-modules/virtual-device:virtual_device_x86_64_dist</span><br><span class="line">// 注意两个编译产物，后面会用</span><br><span class="line">out/virtual_device_x86_64/dist/bzImage</span><br><span class="line">out/virtual_device_x86_64/dist/initramfs.img</span><br></pre></td></tr></table></figure></p></li><li><p>启动<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launch_cvd -kernel_path=/home/cozy/lang/media/lang/kernel_android14_6_1/out/virtual_device_x86_64/dist/bzImage -initramfs_path=/home/cozy/lang/media/lang/kernel_android14_6_1/out/virtual_device_x86_64/dist/initramfs.img </span><br></pre></td></tr></table></figure></p></li><li><p><a href="https://kernelsu.org/guide/how-to-build.html">接入kernelSu模块</a><br>tools&#x2F;bazel run &#x2F;&#x2F;common-modules&#x2F;virtual-device:virtual_device_x86_64_dist – –dist_dir&#x3D;$DIST_DIR<br>tools&#x2F;bazel build &#x2F;&#x2F;common:kernel_aarch64_dist<br>tools&#x2F;bazel run &#x2F;&#x2F;common:kernel_aarch64_dist – –dist_dir&#x3D;out</p></li></ol></li></ul></li><li><p>真机mi12-cupid内核开发<a href="https://github.com/xiaomi-sm8450-kernel/manifest">github</a></p><ol><li>第一阶段实践了下不行，放弃</li><li>第二阶段，直接通过<a href="https://clientinfra.com/android-kernel-build-and-debug">https://clientinfra.com/android-kernel-build-and-debug</a> 查找对应的gki 版本分支，通过替换被删掉分支后同步aosp,编译成功</li></ol></li></ol><h2 id="3-KernelSu-构建"><a href="#3-KernelSu-构建" class="headerlink" title="3 KernelSu 构建"></a>3 KernelSu 构建</h2><ol><li><p>gki编译 查找手机对应分支。找不到就放弃吧，一般直接到kernelsu github 找5.10.66（你的内核版本前缀）。没有就不要编译gki了，编译了内核版本还变了<br>   a. 查看内核版本 uname -r   比如：5.10.66-android12-9-gdc4677876dca<br>   b. 找分支。将“gdc4677876dca” 去掉 “g” 复制到链接。 如下<br> <a href="https://android.googlesource.com/kernel/common/+/dc4677876dca">https://android.googlesource.com/kernel/common/+/dc4677876dca</a></p></li><li><p>根据分支，拉取代码 参考：<a href="https://github.com/tiann/KernelSU/blob/main/.github/workflows/gki-kernel.yml">https://github.com/tiann/KernelSU/blob/main/.github/workflows/gki-kernel.yml</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repo init --depth=1 --u https://android.googlesource.com/kernel/manifest -b common-$&#123;&#123; inputs.tag &#125;&#125; --repo-rev=v2.16</span><br><span class="line">REMOTE_BRANCH=$(git ls-remote https://android.googlesource.com/kernel/common $&#123;&#123; inputs.tag &#125;&#125;)</span><br><span class="line">DEFAULT_MANIFEST_PATH=.repo/manifests/default.xml</span><br><span class="line">if grep -q deprecated &lt;&lt;&lt; $REMOTE_BRANCH; then</span><br><span class="line">  echo &quot;Found deprecated branch: $&#123;&#123; inputs.tag &#125;&#125;&quot;</span><br><span class="line">  sed -i &#x27;s/&quot;$&#123;&#123; inputs.tag &#125;&#125;&quot;/&quot;deprecated\/$&#123;&#123; inputs.tag &#125;&#125;&quot;/g&#x27; $DEFAULT_MANIFEST_PATH</span><br><span class="line">  cat $DEFAULT_MANIFEST_PATH</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p><a href="https://kernelsu.org/guide/how-to-build.html">https://kernelsu.org/guide/how-to-build.html</a> 编译并刷入<br> a. gki 编译Image。 替换到 boot<br> b. lkm 编译ko模块。使用 ksud patch<br>   ksud boot-patch -b init_boot.img -m android14-6.1_kernelsu.ko<br>   ksud boot-patch -b boot.img -m kernelsu.ko</p></li><li><p>编译ko 备份</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pip install ast-grep-cli</span><br><span class="line">sudo apt-get install llvm-15 -y</span><br><span class="line">ast-grep -U -p &#x27;$$$ check_exports($$$) &#123;$$$&#125;&#x27; -r &#x27;&#x27; common/scripts/mod/modpost.c</span><br><span class="line">ast-grep -U -p &#x27;check_exports($$$);&#x27; -r &#x27;&#x27; common/scripts/mod/modpost.c</span><br><span class="line">sed -i &#x27;/config KSU/,/help/&#123;s/default y/default m/&#125;&#x27; common/drivers/kernelsu/Kconfig</span><br><span class="line">echo &quot;drivers/kernelsu/kernelsu.ko&quot; &gt;&gt; common/android/gki_aarch64_modules</span><br><span class="line"></span><br><span class="line"># bazel build, android14-5.15, android14-6.1 use bazel</span><br><span class="line">if [ ! -e build/build.sh ]; then</span><br><span class="line">  sed -i &#x27;s/needs unknown symbol/Dont abort when unknown symbol/g&#x27; build/kernel/*.sh || echo &quot;No unknown symbol scripts found&quot;</span><br><span class="line">  if [ -e common/modules.bzl ]; then</span><br><span class="line">    sed -i &#x27;s/_COMMON_GKI_MODULES_LIST = \[/_COMMON_GKI_MODULES_LIST = \[ &quot;drivers\/kernelsu\/kernelsu.ko&quot;,/g&#x27; common/modules.bzl</span><br><span class="line">  fi</span><br><span class="line">else</span><br><span class="line">  TARGET_FILE=&quot;build/kernel/build.sh&quot;</span><br><span class="line">  if [ ! -e &quot;$TARGET_FILE&quot; ]; then</span><br><span class="line">    TARGET_FILE=&quot;build/build.sh&quot;</span><br><span class="line">  fi</span><br><span class="line">  sed -i &#x27;s/needs unknown symbol/Dont abort when unknown symbol/g&#x27; $TARGET_FILE || echo &quot;No unknown symbol in $TARGET_FILE&quot;</span><br><span class="line">  sed -i &#x27;s/if ! diff -u &quot;\$&#123;KERNEL_DIR&#125;\/\$&#123;MODULES_ORDER&#125;&quot; &quot;\$&#123;OUT_DIR&#125;\/modules\.order&quot;; then/if false; then/g&#x27; $TARGET_FILE</span><br><span class="line">  sed -i &#x27;s@$&#123;ROOT_DIR&#125;/build/abi/compare_to_symbol_list@echo@g&#x27; $TARGET_FILE</span><br><span class="line">  sed -i &#x27;s/needs unknown symbol/Dont abort when unknown symbol/g&#x27; build/kernel/*.sh || echo &quot;No unknown symbol scripts found&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-Apatch"><a href="#3-Apatch" class="headerlink" title="3. Apatch"></a>3. Apatch</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb install apatch_patched_10763_0.10.7_hycc.img</span><br><span class="line">adb shell &#x27;echo &quot;&#123;\&quot;serial\&quot;:\&quot;$(getprop  ro.serialno)\&quot;&#125;&quot; &gt; XXX</span><br><span class="line">adb push worker-release-unsigned.apk XXX</span><br><span class="line">adb push ROM.zip XXX</span><br><span class="line">adb push install.sh XXX</span><br><span class="line">adb shell su -c &quot;XXX&quot;</span><br><span class="line">adb reboot</span><br></pre></td></tr></table></figure><h3 id="rom定制"><a href="#rom定制" class="headerlink" title="rom定制"></a>rom定制</h3><ol><li>termux + ssh + ubuntu + clone TIK 项目</li><li>解包super.img system.img</li><li>cp ..&#x2F;gauguin_rom&#x2F;a_update&#x2F;c8750f0d.0 system&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;</li><li>cp ..&#x2F;gauguin_rom&#x2F;a_update&#x2F;com.android.adbd.apex system&#x2F;system&#x2F;apex&#x2F;com.android.adbd.apex</li><li>&#x2F;system&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;c8750f0d.0 u:object_r:system_security_cacerts_file:s0</li><li>打包system.img super.img</li><li>flash super</li></ol><h3 id="定制-adbd-runtime"><a href="#定制-adbd-runtime" class="headerlink" title="定制 adbd runtime"></a>定制 adbd runtime</h3><ol><li>bionic&#x2F;linker&#x2F;linker_main.cpp   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void solist_add_soinfo(soinfo* si) &#123;</span><br><span class="line">if(si !=nullptr &amp;&amp; strstr(si-&gt;get_realpath(),&quot;libxxx.so&quot;))&#123;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">sonext-&gt;next = si;</span><br><span class="line">sonext = si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>  adbd 这个apex是直接复制替换（TIK）<br>  <a href="https://github.com/ColdWindScholar/TIK">https://github.com/ColdWindScholar/TIK</a></p><ol start="2"><li><p>packages&#x2F;modules&#x2F;adb&#x2F;daemon&#x2F;main.cpp</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int port = xxx;</span><br><span class="line">addrs.push_back(android::base::StringPrintf(&quot;tcp:%d&quot;, port));</span><br><span class="line">addrs.push_back(android::base::StringPrintf(&quot;vsock:%d&quot;, port));</span><br><span class="line">setup_adb(addrs);</span><br></pre></td></tr></table></figure></li><li><p>packages&#x2F;modules&#x2F;adb&#x2F;daemon&#x2F;auth.cpp</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool authorized = false;</span><br><span class="line">// remove auth</span><br><span class="line">if(authorized == false)&#123;return true;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>  先对runtime 解包，替换 linker 在打包回apex<br>  <a href="https://github.com/wcedla/AndroidApexTools">https://github.com/wcedla/AndroidApexTools</a></p><h3 id="替换组建，打包img"><a href="#替换组建，打包img" class="headerlink" title="替换组建，打包img"></a>替换组建，打包img</h3><ol><li>解包 小米直接下载线刷包，oplus只有卡刷包（7z 解压出playload.bin 在TIK 解压）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向-内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> root方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-hook-plt</title>
      <link href="/2024/03/31/%E9%80%86%E5%90%91-hook-plt/"/>
      <url>/2024/03/31/%E9%80%86%E5%90%91-hook-plt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搬砖</p></blockquote><h1 id="PLT-hook"><a href="#PLT-hook" class="headerlink" title="PLT hook"></a>PLT hook</h1><pre><code>原理: 了解了 ELF 格式和 linker 的 relocation 过程之后，PLT hook 的过程就不言自明了。它做了和 relocation 类似的事情。即：通过符号名，先在 hash table 中找到对应的符号信息（在 .dynsym 中）;再找到对应的 PLT 信息（在 .rel.plt 或 .rela.plt 或 .rel.dyn 或 .rela.dyn 或 .rel.dyn.aps2 或 .rela.dyn.aps2 中）;最后找到绝对地址信息（在 .got.plt 或 .data 或 .data.rel.ro 中）。最后要做的就是修改这个绝对地址的值，改为我们需要的自己的“代理函数”的地址。要注意的是，在修改这个绝对地址之前，需要先用 mprotect 设置当前地址位置所在内存页为“可写”的,因为 linker 在做完 relocation 后会把 .got.plt 和 .data.rel.ro 设置为只读的;修改完之后，需要用 __builtin___clear_cache 来清除该内存位置的 CPU cache，以使修改能立刻生效。</code></pre><h2 id="xhook"><a href="#xhook" class="headerlink" title="xhook"></a>xhook</h2><h3 id="1-动态链接过程"><a href="#1-动态链接过程" class="headerlink" title="1.动态链接过程"></a>1.动态链接过程</h3><pre><code>动态链接是一种将程序的可执行文件与动态链接库（Shared Libraries，在 Linux 和 Android 上通常以 .so 文件存在）关联起来的技术。当你使用 dlopen 调用一个共享库时，动态链接器（在 Android 上就是 linker 或者 ld-linux.so）会按照特定的步骤加载和准备库以供使用。以下是动态链接的大致步骤：1. 检查已加载的 ELF 列表：动态链接器首先检查要加载的共享库是否已经加载过了。如果已经加载，它只会增加共享库的引用计数，并返回一个指向库的指针。2. 解析依赖并建立加载列表：动态链接器从 .dynamic section 读取共享库的依赖项。它会构建一个包括目标库及其所有未加载依赖库的加载列表。3. 加载 ELF 到内存：对每个还没有加载的库，动态链接器使用 mmap 预留一块内存。然后读取库的程序头表（Program Header Table, PHT），并将所有 PT_LOAD 类型的段(segment)映射到内存中。4. 处理 ELF 的 .dynamic section：通过 .dynamic section 中的条目找到例如符号表、字符串表以及重定位表的虚拟地址，并保存它们的实际内存地址供后续步骤使用。5. 执行重定位：针对这些 .rel* 或者 .rela* sections进行重定位操作。对每个重定位条目，动态链接器需要根据条目的类型和信息，找到正确的符号地址，并更新引用位置的地址。例如，某个函数调用的 GOT （Global Offset Table）条目在初次加载时是空的，重定位会填上正确的函数实现地址。6. 更新引用计数：为刚刚加载的库增加引用计数。7. 调用构造函数：一旦库加载到内存并重定位完毕，动态链接器会调用库的构造函数。构造函数在 .dynamic section 中被标记为 DT_INIT 和 DT_INIT_ARRAY 类型。通常这些构造函数会初始化库的静态数据或进行其他的库初始化操作。</code></pre><h3 id="2-xhook源码分析"><a href="#2-xhook源码分析" class="headerlink" title="2. xhook源码分析"></a>2. <a href="https://blog.yorek.xyz/android/3rd-library/xhook/#42-hook">xhook源码分析</a></h3><h2 id="bhook"><a href="#bhook" class="headerlink" title="bhook"></a>bhook</h2><h3 id="bhook分析"><a href="#bhook分析" class="headerlink" title="bhook分析"></a><a href="https://juejin.cn/post/6998085562573783076">bhook分析</a></h3><h2 id="lsplt"><a href="#lsplt" class="headerlink" title="lsplt"></a>lsplt</h2><h2 id="jvmti"><a href="#jvmti" class="headerlink" title="jvmti"></a>jvmti</h2>]]></content>
      
      
      <categories>
          
          <category> 逆向-hook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-爬虫-抓包</title>
      <link href="/2024/03/31/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E6%8A%93%E5%8C%85/"/>
      <url>/2024/03/31/%E9%80%86%E5%90%91-%E7%88%AC%E8%99%AB-%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搬砖</p></blockquote><h1 id="ebpf-in-android"><a href="#ebpf-in-android" class="headerlink" title="ebpf in android"></a>ebpf in android</h1><h2 id="1-osi七层协议-ssl-tls-所在位置"><a href="#1-osi七层协议-ssl-tls-所在位置" class="headerlink" title="1.osi七层协议(ssl&#x2F;tls 所在位置)"></a>1.osi七层协议(ssl&#x2F;tls 所在位置)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层tcp     (第7层)        &lt;-- 应用数据（HTTP、FTP、IMAP等）</span><br><span class="line">表示层tcp     (第6层)   </span><br><span class="line">会话层tcp     (第5层)        &lt;-- SSL/TLS 握手，密钥交换，记录协议</span><br><span class="line">传输层tcp     (第4层)        &lt;-- SSL/TLS 记录协议（安全的传输）</span><br><span class="line">网络层        (第3层)        &lt;-- IP协议等，进行路由选择</span><br><span class="line">数据链路层     (第2层)        &lt;-- 在物理网络中传输数据帧</span><br><span class="line">物理层        (第1层)        &lt;-- 物理传输介质</span><br></pre></td></tr></table></figure><h3 id="ssl-tls"><a href="#ssl-tls" class="headerlink" title="ssl&#x2F;tls"></a>ssl&#x2F;tls</h3><p>tcp 是网络编程的抽象，ssl&#x2F;tls 对tcp加密，同时处理握手，密钥交换</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ol><li><p>TCP 三次握手：<br>TCP 连接开始时，客户端发出一个 SYN（同步序列编号） 数据包。<br>服务器回应一个带有 SYN&#x2F;ACK 标志的数据包。<br>客户端发送一个 ACK（确认）数据包，完成三次握手。</p></li><li><p>TLS 握手 —— 客户端发送 “Client Hello”：<br>握手开始后，客户端发送 “Client Hello” 消息，包含其支持的 TLS 版本、加密套件、压缩方法和一个客户端随机数。</p></li><li><p>TLS 握手 —— 服务器响应 “Server Hello”：<br>服务器选择双方共同支持的协议和密码套件，并发送 “Server Hello” 消息给客户端。它也包含一个服务器随机数。</p></li><li><p>服务器发送证书链：<br>这包括服务器的公共证书及任何必需的中间CA证书。根CA证书通常不会发送，因为它应该已经预先安装在客户端系统中。</p></li><li><p>客户端验证证书，并使用CA的公钥进行加密的密钥交换：<br>客户端验证服务器证书和证书链的有效性。如果验证通过，客户端使用服务器证书中包含的公钥来加密生成的预备主秘钥（pre-master secret）并发送给服务器。</p></li><li><p>密钥交换和加密套件的确定：<br>服务器利用其私钥解密并得到预备主秘钥，并基于这个秘钥以及双方共享的随机数生成主秘钥。双方会使用主秘钥派生出会话秘钥，用于此后的会话加密。<br>双方会各自发送“Change Cipher Spec”消息，之后即使用选定的对称加密算法（如 AES）、特定模式（如 GCM）和会话秘钥来加密通信。</p></li><li><p>握手完成，开始加密通信：<br>双方分别发送包含握手消息哈希的”Finished”消息。一旦 “Finished” 消息被验证，加密会话开始，传输的数据使用会话秘钥加密。</p></li></ol><h3 id="3-2-https单向认证和双向认证"><a href="#3-2-https单向认证和双向认证" class="headerlink" title="3.2. https单向认证和双向认证"></a>3.2. https单向认证和双向认证</h3><ol><li><p>单向认证 sslping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">单向认证信任所有证书</span><br><span class="line">public class HttpsUtils &#123;</span><br><span class="line"></span><br><span class="line">private MyTrustManager mMyTrustManager;</span><br><span class="line"></span><br><span class="line">    private SSLSocketFactory createSSLSocketFactory() &#123;</span><br><span class="line">        SSLSocketFactory ssfFactory = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            mMyTrustManager = new MyTrustManager();</span><br><span class="line">            SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            sc.init(null, new TrustManager[]&#123;mMyTrustManager&#125;, new SecureRandom());</span><br><span class="line">            ssfFactory = sc.getSocketFactory();</span><br><span class="line">        &#125; catch (Exception ignored) &#123;</span><br><span class="line">            ignored.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ssfFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现X509TrustManager接口</span><br><span class="line">    public class MyTrustManager implements X509TrustManager &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            return new X509Certificate[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现HostnameVerifier接口</span><br><span class="line">    private class TrustAllHostnameVerifier implements HostnameVerifier &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean verify(String hostname, SSLSession session) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public OkHttpClient getTrustAllClient() &#123;</span><br><span class="line">        OkHttpClient.Builder mBuilder = new OkHttpClient.Builder();</span><br><span class="line">        mBuilder.sslSocketFactory(createSSLSocketFactory(), mMyTrustManager)</span><br><span class="line">                .hostnameVerifier(new TrustAllHostnameVerifier());</span><br><span class="line">        return mBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单向认证 验证服务器端证书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static SSLSocketFactory getSSLSocketFactory_Certificate(Context context, String str) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        CertificateFactory instance = CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">        KeyStore instance2 = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">        instance2.load((KeyStore.LoadStoreParameter) null);</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (Certificate certificateEntry : instance.generateCertificates(context.getAssets().open(str))) &#123;</span><br><span class="line">            instance2.setCertificateEntry(Integer.toString(i), certificateEntry);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        TrustManagerFactory instance3 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">        instance3.init(instance2);</span><br><span class="line">        SSLContext instance4 = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">        instance4.init((KeyManager[]) null, instance3.getTrustManagers(), new SecureRandom());</span><br><span class="line">        return instance4.getSocketFactory();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双向认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static SSLSocketFactory getSSLSocketFactory_Certificate(Context context, String str) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">        //通过证书工厂得到自签证书对象集合</span><br><span class="line">        Collection&lt;? extends Certificate&gt; certificates = certificateFactory.generateCertificates(in);</span><br><span class="line">        if (certificates.isEmpty()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;expected non-empty set of trusted certificates&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //为证书设置一个keyStore</span><br><span class="line">        char[] password = &quot;password&quot;.toCharArray(); // Any password will work.</span><br><span class="line">        KeyStore keyStore = newEmptyKeyStore(password);</span><br><span class="line">        int index = 0;</span><br><span class="line">        //将证书放入keystore中</span><br><span class="line">        for (Certificate certificate : certificates) &#123;</span><br><span class="line">            String certificateAlias = Integer.toString(index++);</span><br><span class="line">            keyStore.setCertificateEntry(certificateAlias, certificate);</span><br><span class="line">        &#125;</span><br><span class="line">        // Use it to build an X509 trust manager.</span><br><span class="line">        //使用包含自签证书信息的keyStore去构建一个X509TrustManager</span><br><span class="line">        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(</span><br><span class="line">                KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">        keyManagerFactory.init(keyStore, password);</span><br><span class="line">        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(</span><br><span class="line">                TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">        trustManagerFactory.init(keyStore);</span><br><span class="line">        SSLContext instance4 = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">        instance4.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());</span><br><span class="line">        return instance4.getSocketFactory();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-常用抓包工具及原理"><a href="#2-常用抓包工具及原理" class="headerlink" title="2.常用抓包工具及原理"></a>2.常用抓包工具及原理</h2><p>中间人劫持</p><p>旁观者观察</p><h2 id="3-抓包脚步及原理"><a href="#3-抓包脚步及原理" class="headerlink" title="3.抓包脚步及原理"></a>3.抓包脚步及原理</h2><h2 id="4-工作中的抓包方案"><a href="#4-工作中的抓包方案" class="headerlink" title="4.工作中的抓包方案"></a>4.工作中的抓包方案</h2><ul><li>要阻止来自特定IP地址的所有入站流量：<br>iptables -A INPUT -s <IP_ADDRESS> -j DROP</li><li>iptables -L INPUT -v -n</li><li>iptables -D INPUT 3</li></ul>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-内核-ebpf</title>
      <link href="/2024/03/25/%E9%80%86%E5%90%91-%E5%86%85%E6%A0%B8-ebpf/"/>
      <url>/2024/03/25/%E9%80%86%E5%90%91-%E5%86%85%E6%A0%B8-ebpf/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搬砖</p></blockquote><h1 id="ebpf-in-android"><a href="#ebpf-in-android" class="headerlink" title="ebpf in android"></a>ebpf in android</h1><h2 id="1-ebpf原理"><a href="#1-ebpf原理" class="headerlink" title="1.ebpf原理"></a>1.ebpf原理</h2><p>收集资料<br><a href="https://www.ebpf.top/post/ebpf-overview-part-3/">https://www.ebpf.top/post/ebpf-overview-part-3/</a></p><p>我当前阶段理解的重点是: 前端，后端，加载器， 数据结构</p><h2 id="2-ebpf学习经历"><a href="#2-ebpf学习经历" class="headerlink" title="2.ebpf学习经历"></a>2.ebpf学习经历</h2><blockquote><p>收集资料</p></blockquote><ul><li><a href="https://blog.seeflower.dev/archives/176/">https://blog.seeflower.dev/archives/176/</a></li></ul><p>ebpf是linux内核提供的hook api<br>看了很多大佬博客，前期在Android上运行bpf程序遇到问题很多，重点是内核版本，Android api变化， 编译环境方面问题很多<br>总结了下bpf快速上手路线,我的手机小米12，应使用kenelSu root了</p><ol><li><p>多看理解早期基本用法 <a href="https://blog.seeflower.dev/archives/89/">bpf on Android</a> </p></li><li><p>Android上体验bcc脚本</p><ul><li><p><a href="https://blog.seeflower.dev/archives/140/">环境准备</a><br>安装magiskSSH模块,它会帮我创建好linux在安卓上的环境,还会准备好ssh, 注意这里用的frp内网穿透提供ssh登录能力,如果不需要做内网穿透，直接ssh链接内网手机就可以了。当然我是用frp内网穿透链接云手机，只需要将我自己电脑上的公钥上传到跳板机器和内网手机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host jumpserver2</span><br><span class="line">User root</span><br><span class="line">HostName *****</span><br><span class="line">Port 22</span><br><span class="line"></span><br><span class="line">Host phone</span><br><span class="line">User root</span><br><span class="line">Port 22900</span><br><span class="line">HostName localhost</span><br><span class="line">ProxyJump jumpserver2</span><br></pre></td></tr></table></figure><p>发现没有，不需要额外配置 IdentityFile，直接ssh phone</p><p>本来打算用 vscode ssh 开发的，折腾了半天vscode无法打开Android目录，因为在ssh链接时候用了bash 命令，然而Android上没有bash命令，报解析错误，后改为在手机端启动<a href="https://www.cnblogs.com/minskiter/p/16986874.html">code tunnel</a> 来远程开发</p></li><li><p><a href="https://blog.seeflower.dev/archives/111/">体验ebpf</a><br>没体验赶紧体验，不懂就问chatgpt,比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF Maps</span><br><span class="line">BPF_PERCPU_ARRAY(ssl_data, struct probe_SSL_data_t, 1); 声明了一个 per-CPU 数组来存储追踪事件的数据。// 也就是初始化1个数据结构probe_SSL_data_t 放在 ssl_data</span><br><span class="line">BPF_PERF_OUTPUT(perf_SSL_rw); 和 BPF_PERF_OUTPUT(perf_SSL_do_handshake); 创建了用于将追踪数据发送到用户空间的性能输出数组。// 也就是创建的输出管道，内核里不断perf_submit 提交数据到管道，python前端注册好管道监听就能获取到相关数据</span><br><span class="line">BPF_HASH(start_ns, u32); 和 BPF_HASH(bufs, u32, u64); 声明了哈希表来存储事件开始的时间戳和缓冲区地址。// 这个就不用解释了，hash</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>eCapture 编译</p><ul><li><p>复习下osi七层协议，重点是ssl&#x2F;tls</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">应用层          (第7层) | ← 应用程序（如 Web 浏览器、电子邮件客户端）</span><br><span class="line">表示层          (第6层) | ← 数据格式化、数据加密、数据压缩</span><br><span class="line">会话层          (第5层) | ← 会话管理、身份验证</span><br><span class="line">-------------------------| ← SSL/TLS 加密层 (对tcp加密；提供了身份验证、密钥交换、加密和解密)</span><br><span class="line">传输层          (第4层) | ← 可靠的数据传输（如 TCP 协议）</span><br><span class="line">网络层          (第3层) | ← 路由、IP 数据报传输、地址解析</span><br><span class="line">数据链路层       (第2层) | ← 物理寻址、错误检测和修正</span><br><span class="line">物理层          (第1层) | ← 物理介质传输（如电缆、光纤）</span><br><span class="line"></span><br><span class="line">socket是抽象概念，跨越了多个层次。</span><br><span class="line">应用层协议（如 HTTP、FTP、SMTP）使用 Socket API 来实现网络通信功能。（应用层）</span><br><span class="line">Socket定义了端口和传输协议（如 TCP 或 UDP）（传输层）</span><br><span class="line">Socket本身不包含会话层和表示层的全部功能</span><br></pre></td></tr></table></figure><p>在 Android 系统中，绝大多数与 TLS 相关的操作都是通过位于 &#x2F;apex&#x2F;com.android.conscrypt&#x2F;lib64&#x2F;libssl.so（对于 64 位系统）这一路径下的库来执行的。这个库是一个由 BoringSSL 提供支持的 Conscrypt 库的一部分，BoringSSL 本身是 Google 维护的 OpenSSL 的分支版本。</p><p>Conscrypt 作为 Android 平台上的一个安全提供者，为高级应用程序编程接口（API）实现了底层的加密协议。应用程序和开发者通常使用 Android SDK 中提供的更高级别的 API，例如 javax.net.ssl.SSLContext 和 HttpsURLConnection，以及流行的网络库如 OkHttp，它们在内部都沟通与 Conscrypt 提供的功能以建立和维护安全的网络连接。</p><p>除非开发者在 Android 应用中明确地引入了自定义的 TLS 库（例如使用一个独立的 OpenSSL 版本或其他的 SSL&#x2F;TLS 实现），否则默认情况下，安全通信都是通过系统提供的 Conscrypt 实现的 TLS 功能来处理的。通过 Security 类和 Provider 类的 API，Conscrypt 被集成和注册到 Java 安全框架中。这意味着不仅系统本身的网络通信依赖 Conscrypt，第三方应用程序除非另外指定，都会默认使用它来处理相关的 SSL&#x2F;TLS 连接。</p><p>因此，如果你正在处理安全连接、证书验证或其他与 TLS 相关的安全特性，只要不是使用的自定义的加密库，你可以认为所有的操作最终都是通过 Android 系统提供的 Conscrypt 实现，进而调用 &#x2F;apex&#x2F;com.android.conscrypt&#x2F;lib64&#x2F;libssl.so 库的函数来完成的。</p></li><li><p><a href="https://blog.seeflower.dev/archives/172/">编译eCapture</a><br>我的编译过程</p><ol><li>使用gnirehtet将手机网络请求转发到电脑，电脑可翻墙加速下载</li><li>配置go,按照上面文章就能可以搞定，最后缺什么环境变量补什么</li><li>编译 make</li></ol></li><li><p>eCapture使用</p><ol><li><p>先看下<a href="https://www.cnxct.com/archives/">eCapture项目博客</a>的相关介绍 </p><ul><li><a href="https://www.cnxct.com/ecapture-for-android/">重点博客</a></li></ul></li><li><p>复习下<a href="https://github.com/iovisor/bcc">bcc项目</a> 只看“Network and Sockets Tools”</p><ul><li>[x]tools&#x2F;gethostlatency </li><li>[x]tools&#x2F;bindsnoop</li><li>[x]tools&#x2F;netqtop tools&#x2F;netqtop.c</li><li>[x]tools&#x2F;sofdsnoop</li><li>[x]tools&#x2F;solisten</li><li>[x]tools&#x2F;sslsniff “推荐 python sslsniff.py -p pid -l –handshake -g -n”</li><li>[x]tools&#x2F;tcpaccept</li><li>[x]tools&#x2F;tcpconnect</li><li>[x]tools&#x2F;tcpconnlat</li><li>[x]tools&#x2F;tcpdrop</li><li>[x]tools&#x2F;tcplife</li><li>[x]tools&#x2F;tcpretrans</li><li>[x]tools&#x2F;tcprtt</li><li>[x]tools&#x2F;tcpstates</li><li>[x]tools&#x2F;tcpsubnet</li><li>[x]tools&#x2F;tcpsynbl</li><li>[x]tools&#x2F;tcptop</li><li>[x]tools&#x2F;tcptracer</li><li>[x]tools&#x2F;tcpcong</li></ul></li><li><p><a href="https://blog.seeflower.dev/archives/172/">ecapture编译</a><br> 我的手机需要引入header文件<br> ANDROID&#x3D;1 make nocore</p></li><li><p>使用 .&#x2F;ecapture tls -h</p></li><li><p>vscode remote 远程调试ecapture</p><ul><li>在手机端启动 .&#x2F;code tunnel （我这里用的是vscode 隧道）</li><li>vscode 安装Golang插件，<a href="https://maiyang.me/post/2018-09-14-tips-vscode/">自动补全go代码</a></li><li>插件装好后配置launch.json这个代码运行配置文件,重点是args 这个参数  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Launch ecapture&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;go&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;mode&quot;: &quot;debug&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 确保这里的路径指向正确的可执行文件或包</span><br><span class="line">            &quot;args&quot;: [&quot;tls&quot;], // 替换为你的实际参数</span><br><span class="line">            &quot;logOutput&quot;: &quot;dap&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>debug</li><li>这时你会遇到 libpcap 没有安装问题，找到&#x2F;lib&#x2F;libpcap目录，.&#x2F;configure &amp;&amp; make &amp;&amp; make install</li></ul></li><li><p>代码分析</p><blockquote><p>对比分析下<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 来自ecapture</span><br><span class="line">struct &#123;</span><br><span class="line">    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line">    __uint(key_size, sizeof(u32));</span><br><span class="line">    __uint(value_size, sizeof(u32));</span><br><span class="line">    __uint(max_entries, 1024);</span><br><span class="line">&#125; tls_events SEC(&quot;.maps&quot;);</span><br><span class="line"></span><br><span class="line">// 来自bcc sslsniff.py</span><br><span class="line">struct bpf_map_def SEC(&quot;maps&quot;) ssl_data = &#123;</span><br><span class="line">    .type = BPF_MAP_TYPE_PERCPU_ARRAY,</span><br><span class="line">    .key_size = sizeof(u32),</span><br><span class="line">    .value_size = sizeof(struct probe_SSL_data_t),</span><br><span class="line">    .max_entries = 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">映射类型：</span><br><span class="line">tls_events 是一个 BPF_MAP_TYPE_PERF_EVENT_ARRAY 类型，用于发送事件数据到用户空间。</span><br><span class="line">ssl_data 是一个 BPF_MAP_TYPE_PERCPU_ARRAY 类型，用于每个 CPU 存储特定的数据。</span><br><span class="line"></span><br><span class="line">使用场景：</span><br><span class="line">tls_events 用于与用户空间通信，如监控或跟踪 SSL/TLS 事件。</span><br><span class="line">ssl_data 用于存储每个 CPU 相关数据，例如用于性能监控或者调试目的。</span><br><span class="line">             </span><br><span class="line">映射大小：</span><br><span class="line">tls_events 可以根据系统上的 CPU 数量进行扩展，最多支持 1024 个 CPU。</span><br><span class="line">ssl_data 为每个 CPU 提供了一个数组元素。</span><br></pre></td></tr></table></figure><blockquote><p>tls_events  ssl_data  可以理解为不通作用的管道么?<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">可以这样理解，tls_events 和 ssl_data 在 eBPF 程序中的确类似于不同作用的“管道”，其中每个管道都有不同的用途和行为。这里的“管道”是指它们各自如何在内核和用户空间之间传输数据的方式。</span><br><span class="line"></span><br><span class="line">tls_events 映射（管道）</span><br><span class="line">tls_events 映射是一个 BPF_MAP_TYPE_PERF_EVENT_ARRAY 类型的 eBPF 映射。它的主要作用是作为一个通道将数据从内核空间（eBPF 程序）发送到用户空间（分析工具或者监听程序）。这种映射允许 eBPF 程序通过 perf event 基础设施高效地传输数据，该数据通常与监控或跟踪事件有关。</span><br><span class="line"></span><br><span class="line">当 eBPF 程序用 bpf_perf_event_output 函数把数据发送到 tls_events 映射时，用户空间监听程序可以从关联的 perf event 文件描述符读取这些事件数据。</span><br><span class="line"></span><br><span class="line">ssl_data 映射（管道）</span><br><span class="line">ssl_data 映射是一个 BPF_MAP_TYPE_PERCPU_ARRAY 类型的 eBPF 映射。这个映射像是为每个 CPU 专门创建的一个本地存储区域，使得 eBPF 程序可以避免跨 CPU 的数据共享和潜在的竞争状态。它通常用于存储每个 CPU 核心特定的上下文信息或用于临时存储计算数据。</span><br><span class="line"></span><br><span class="line">由于是 per-CPU 映射，ssl_data 并不直接涉及到用户空间的数据传输。它更像是内核空间内部的一个局部存储区，用于 eBPF 程序的内部数据管理。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">tls_events 和 ssl_data 虽然都是 eBPF 程序中的数据结构，但它们的“管道”作用是不同的：</span><br><span class="line"></span><br><span class="line">tls_events 类似于一个将数据从 eBPF 程序发送到用户空间的出口管道。</span><br><span class="line">ssl_data 类似于一个在内核中为每个 CPU 提供数据存储的内部管道。</span><br><span class="line">根据需要传输数据的方向（内核到用户空间，还是内核内部）和用途（事件传输，还是数据存储），你会选择合适的映射类型来实现你的目标。</span><br></pre></td></tr></table></figure></p></blockquote></li><li><p><a href="http://blog.silence.pink/p/trace-openssl-with-ebpf/">参数ssl读取</a></p><ul><li>ecapature&#x2F;utils&#x2F; 下介绍了如何读取ssl结构体相关的参数信息</li></ul></li></ol></li></ul></li><li><p><a href="https://bbs.kanxue.com/thread-274546.htm">定制bcc&#x2F;ebpf在android平台上实现基于dwarf的用户态栈回溯</a></p><ol><li><p><a href="https://github.com/SeeFlowerX/unwinddaemon">unwinddaemon</a></p><ul><li>[x]直接ndk交叉编译 .&#x2F;build.sh<br>  编译问题: <a href="https://github.com/SeeFlowerX/unwinddaemon/issues/2">https://github.com/SeeFlowerX/unwinddaemon/issues/2</a></li><li>[x]<a href="https://blog.csdn.net/qq_33350950/article/details/134752123">基于aosp编译</a><br>  编译问题: <a href="https://blog.csdn.net/Chris_1994/article/details/135017508">https://blog.csdn.net/Chris_1994/article/details/135017508</a><br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 直接拉取对应分支</span><br><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android14-release</span><br><span class="line">repo sync -j8</span><br><span class="line"></span><br><span class="line">2. 交换内存不够的处理办法</span><br><span class="line">sudo dd if=/dev/zero of=/swapfile bs=1M count=20480</span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br></pre></td></tr></table></figure><br>  unwinddaemon编译问题：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system/extras/unwinddaemon/lib.cpp:454:85: error: unused parameter &#x27;stack_buf&#x27; [-Werror,-Wunused-parameter]</span><br><span class="line">const char* UnwindCallChainV2(int pid, UnwindOption* opt, uint64_t* regs_buf, void* stack_buf)</span><br><span class="line">注: 对于警告问题直接注释，(void)stack_buf; // 显式声明 stack_buf 为未使用</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://github.com/SeeFlowerX/unwindbcc">unwindbcc</a> 主要是在注册事件前，事件回调后修改相关代码。实现跨进程通讯打印</p><ol><li>open_perf_buffer(BPF.cc)-&gt;open_all_cpu-&gt;open_on_cpu-&gt;bpf_open_perf_buffer_opts(libbpf.c)-&gt;__NR_perf_event_open</li><li>perf_reader_poll(perf_reader.c)-&gt;perf_reader_event_read-&gt;parse_sw-&gt;print_frame_info</li></ol></li></ol></li><li><p><a href="https://github.com/SeeFlowerX/stackplz">stackplz</a><br>   注:go环境和ndk交叉编译, android端debian没有对于的cpu架构ndk</p></li></ol><h2 id="3-uprobe检测"><a href="#3-uprobe检测" class="headerlink" title="3.uprobe检测"></a>3.uprobe检测</h2><p><a href="https://www.cnxct.com/defeating-ebpf-uprobe-monitoring/">https://www.cnxct.com/defeating-ebpf-uprobe-monitoring/</a>     </p>]]></content>
      
      
      <categories>
          
          <category> 逆向-ebpf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-hook-inline(frida)</title>
      <link href="/2024/03/21/%E9%80%86%E5%90%91-hook-inline(frida)/"/>
      <url>/2024/03/21/%E9%80%86%E5%90%91-hook-inline(frida)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搬砖</p></blockquote><h1 id="frida编译"><a href="#frida编译" class="headerlink" title="frida编译"></a>frida编译</h1><h2 id="1-原始frida编译"><a href="#1-原始frida编译" class="headerlink" title="1.原始frida编译"></a>1.原始frida编译</h2><p>  编译先看：<a href="https://frida.re/docs/building/">https://frida.re/docs/building/</a></p><ul><li>git clone –recurse-submodules <a href="https://github.com/frida/frida.git">https://github.com/frida/frida.git</a></li><li>git checkout 16.2.1</li><li>git submodule update</li><li>cd frida</li><li>make</li><li>make core-android-arm64</li></ul><p><strong>编译环境补充</strong></p><ul><li>sudo apt-get install build-essential curl git lib32stdc++-9-dev <br>  libc6-dev-i386 nodejs npm python3-dev python3-pip</li></ul><p>不出意外的话应该会报错</p><blockquote><p>问题一：没有ANDROID_NDK_ROOT</p></blockquote><pre><code>解决办法：我是从Android studio中Android sdk选项卡中安装指定报错版本的ndk，然后配置ANDROID_NDK_ROOT环境变量* export ANDROID_NDK_ROOT=/home/cozy/Android/Sdk/ndk/25.2.9519653* export PATH=$ANDROID_NDK_ROOT:$PATH</code></pre><blockquote><p>问题二：没有node环境</p></blockquote><pre><code>虽然安装了nodejs，但是可能版本不对也会提示编译失败1. npm doctor  #查看项目使用的nodejs版本2. curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash  #使用nvm来安装nodejs3. nvm install v20.11.1 #我这里用的是v20.11.1</code></pre><h2 id="2-定制库hluwa"><a href="#2-定制库hluwa" class="headerlink" title="2.定制库hluwa"></a>2.定制库hluwa</h2><p>在frida源码同级目录下，clone hluwa代码.当然这里只适配到frida 15.0.4</p><ol><li>git clone <a href="https://github.com/hluwa/Patchs.git">https://github.com/hluwa/Patchs.git</a></li><li>git checkout 15.0.4  </li><li>git submodule update –recursive</li><li>git am ..&#x2F;..&#x2F;Patchs&#x2F;strongR-frida&#x2F;frida-core&#x2F;*.patch</li><li>make core-android-arm64</li></ol><p>我本人应为下载 frida&#x3D;&#x3D;16.2.1, Patchs脚本只支持到15.0.4，所以就手动复制，顺便熟悉下魔改点</p><h2 id="3-frida检测点"><a href="#3-frida检测点" class="headerlink" title="3. frida检测点"></a>3. frida检测点</h2><p>简单检测</p><ul><li><a href="https://www.52pojie.cn/thread-1783400-1-1.html">https://www.52pojie.cn/thread-1783400-1-1.html</a></li><li><a href="https://bbs.kanxue.com/thread-278145.htm">https://bbs.kanxue.com/thread-278145.htm</a></li></ul><p>一般检查主要是通过frida关键词特征</p><ol><li><input checked="" disabled="" type="checkbox"> 查看&#x2F;proc&#x2F;pid&#x2F;maps，查看这个文件中frida关键词</li><li><input checked="" disabled="" type="checkbox"> 读取&#x2F;proc&#x2F;pid&#x2F;maps映射内存，从内存中检测“frida:rpc”类似关键词，不过内存中之只搜索到frida-agent</li><li><input checked="" disabled="" type="checkbox"> 查看&#x2F;proc&#x2F;self&#x2F;task&#x2F;pid&#x2F;status, 从对现场描述文件中查找frida相关进程，如 gmain gum-js-loop pool-frida 线程名称</li><li><input checked="" disabled="" type="checkbox"> 读取readlink &#x2F;proc&#x2F;self&#x2F;fd&#x2F;XXX，从frida通过管道建立双向通信角度检测frida</li><li><input checked="" disabled="" type="checkbox"> 检查端口和tmp目录</li></ol><p>高级检查</p><ul><li><a href="https://bbs.kanxue.com/thread-268586-1.htm">https://bbs.kanxue.com/thread-268586-1.htm</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNDcwOTcwOQ==&mid=2247492981&idx=2&sn=1337a0dd0259195efe078be55d1d4a55&chksm=97a1c1d7a0d648c14f09d0fd9a43e150f53ce79c82ab5098b7dca6cffc663ce7d32eb5a27b2e&scene=126&sessionid=1653073641&key=0a9f15bc7a0b11091058c506225c7aacc781814ef557c1c6195dacd423a4d7507afa9035592752f9405e452a884945d59fe8a303e08a2720f63543e053d51f5610aa3b9c39f4022a941e44e6a95a4e7f94a498dbe19a9910e426a2efb448776eb27f191dff8d34dd848894604e6cda8798d3d39de7b44611a7a06cc8fdf43826&ascene=1&uin=MTA3Mzc3OTIzNQ==&devicetype=Windows+Server+2016+x64&version=6305002e&lang=zh_CN&session_us=gh_86e8b32f4148&exportkey=AScNPRbXZl0lSD8Me34jl4w=&acctmode=0&pass_ticket=CLipu1oc3Xo23kKaFPk9VMmJWr0KzXLDKmtoNd6o2PRzCklLCrUb3XxUITQ9X3B0&wx_header=0&fontgear=2">https://mp.weixin.qq.com/s?__biz=MzIxNDcwOTcwOQ==&amp;mid=2247492981&amp;idx=2&amp;sn=1337a0dd0259195efe078be55d1d4a55&amp;chksm=97a1c1d7a0d648c14f09d0fd9a43e150f53ce79c82ab5098b7dca6cffc663ce7d32eb5a27b2e&amp;scene=126&amp;sessionid=1653073641&amp;key=0a9f15bc7a0b11091058c506225c7aacc781814ef557c1c6195dacd423a4d7507afa9035592752f9405e452a884945d59fe8a303e08a2720f63543e053d51f5610aa3b9c39f4022a941e44e6a95a4e7f94a498dbe19a9910e426a2efb448776eb27f191dff8d34dd848894604e6cda8798d3d39de7b44611a7a06cc8fdf43826&amp;ascene=1&amp;uin=MTA3Mzc3OTIzNQ%3D%3D&amp;devicetype=Windows+Server+2016+x64&amp;version=6305002e&amp;lang=zh_CN&amp;session_us=gh_86e8b32f4148&amp;exportkey=AScNPRbXZl0lSD8Me34jl4w%3D&amp;acctmode=0&amp;pass_ticket=CLipu1oc3Xo23kKaFPk9VMmJWr0KzXLDKmtoNd6o2PRzCklLCrUb3XxUITQ9X3B0&amp;wx_header=0&amp;fontgear=2</a></li><li><a href="https://bbs.kanxue.com/thread-278423.htm">https://bbs.kanxue.com/thread-278423.htm</a></li></ul><p>我个人认为高级点检查点如下：</p><ol><li><input checked="" disabled="" type="checkbox"> 对核心native文件checksum检查，主要是对与maps文件中存在 r*xp 权限的so文件做checksum检查（注入文件前后checksum大小不一样）</li><li>[] 从内核角度对linehook检测，可先看第四点</li></ol><h2 id="4-frida-gum内核学习"><a href="#4-frida-gum内核学习" class="headerlink" title="4. frida-gum内核学习"></a>4. frida-gum内核学习</h2><p><img src="https://cdn.jsdelivr.net/gh/langgithub/image-repo/imgblog/%E9%80%86%E5%90%91-frida-%E7%BC%96%E8%AF%91%E4%B8%8E%E7%89%B9%E5%BE%811.png" alt="Frida inline hook 的执行流程"></p><h2 id="5-anti-frida"><a href="#5-anti-frida" class="headerlink" title="5. anti-frida"></a>5. anti-frida</h2><ul><li>[x]直接干掉检测线程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 先找到__pthread_start，再patch </span><br><span class="line">// arm64-android14</span><br><span class="line">function hook_pthread_create() &#123;</span><br><span class="line">  var libc = Process.findModuleByName(&quot;libc.so&quot;);</span><br><span class="line">  var addr_pthread_create = libc.base.add(0xCB5D8); // __pthread_start</span><br><span class="line">  Interceptor.attach(addr_pthread_create, &#123;</span><br><span class="line">    onEnter: function (args) &#123;</span><br><span class="line">      var enter = args[0].add(12 * 8).readPointer() console.log(&quot;thread start:&quot; + addr2nice(enter))</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function patch_func_nop(addr) &#123; // C0 03 5F D6</span><br><span class="line">  Memory.patchCode(addr, 4, function (code) &#123; code.writeByteArray([0xC0, 0x03, 0x5F, 0xD6]);</span><br><span class="line">&#125;); &#125;</span><br><span class="line">patch_func_nop(base.add(0x44dd4));</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>[x]直接干掉检测线程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function hook_pthread_create() &#123;</span><br><span class="line">    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)</span><br><span class="line">    Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;), &#123;</span><br><span class="line">        onEnter(args) &#123;</span><br><span class="line">            let func_addr = args[2]</span><br><span class="line">            console.log(&quot;The thread function address is &quot; + func_addr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function nop(addr) &#123;</span><br><span class="line">    Memory.patchCode(ptr(addr), 4, code =&gt; &#123;</span><br><span class="line">        const cw = new ThumbWriter(code, &#123; pc: ptr(addr) &#125;);</span><br><span class="line">        cw.putNop();</span><br><span class="line">        cw.putNop();</span><br><span class="line">        cw.flush();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function bypass()&#123;</span><br><span class="line">    let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)</span><br><span class="line">    nop(module.base.add(0x10AE4))</span><br><span class="line">    nop(module.base.add(0x113F8))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="6-内核中-anti-frida"><a href="#6-内核中-anti-frida" class="headerlink" title="6. 内核中 anti-frida"></a>6. 内核中 anti-frida</h2><ol><li>修改&#x2F;proc&#x2F;self&#x2F;task&#x2F;pid&#x2F;status 生成函数隐藏 __get_task_comm</li><li>修改&#x2F;proc&#x2F;self&#x2F;maps 生成函数过滤 show_maps_vma</li><li>修改do_readlinkat </li><li>对于inline hook检测还是只能kill 检测线程</li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向-hook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-android-rom刷机</title>
      <link href="/2018/01/01/%E9%80%86%E5%90%91-android-rom%E5%88%B7%E6%9C%BA/"/>
      <url>/2018/01/01/%E9%80%86%E5%90%91-android-rom%E5%88%B7%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>逆向-android-rom刷机</del></p></blockquote><h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><h3 id="1-刷机总结"><a href="#1-刷机总结" class="headerlink" title="1. 刷机总结"></a>1. 刷机总结</h3><h4 id="1-1-刷机前的准备"><a href="#1-1-刷机前的准备" class="headerlink" title="1.1 刷机前的准备"></a>1.1 刷机前的准备</h4><ul><li>一般手机需要解锁，解除屏幕锁</li><li>解除fastboot使用权限（比如小米）</li><li>需要正版的twrp,官网上下载 <a href="https://twrp.me/">https://twrp.me</a> 。这一点很重要，后期的刷机，刷magisk,刷xposed.都需要借助twrp上下载的recovery镜像</li><li>下载Rom刷机包，这里提供两个好用的.注意选择手机版本<br>  1.<a href="https://download.mokeedev.com/whyred/nightly/file/MK90.0-whyred-201904151652-NIGHTLY">https://download.mokeedev.com/whyred/nightly/file/MK90.0-whyred-201904151652-NIGHTLY</a><br>  2.<a href="https://downloads.aospextended.com/whyred/">https://downloads.aospextended.com/whyred/</a></li></ul><h4 id="1-2-刷机方式"><a href="#1-2-刷机方式" class="headerlink" title="1.2 刷机方式"></a>1.2 刷机方式</h4><ol><li><p>线刷 使用刷机精灵等软件。(bootloader)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader (进入bootloader模式)</span><br><span class="line">fastboot -w flashall</span><br><span class="line">fastboot update XXX.zip</span><br><span class="line"></span><br><span class="line">注意重点：</span><br><span class="line">去除校验</span><br><span class="line"># fastboot $* flash crclist `dirname $0`/images/crclist.txt</span><br><span class="line"># if [ $? -ne 0 ] ; then echo &quot;Flash crclist error&quot;; exit 1; fi</span><br><span class="line"># fastboot $* flash sparsecrclist `dirname $0`/images/sparsecrclist.txt</span><br><span class="line"># if [ $? -ne 0 ] ; then echo &quot;Flash sparsecrclist error&quot;; exit 1; fi</span><br><span class="line"></span><br><span class="line">去除校验</span><br><span class="line">fastboot --disable-verity --disable-verification flash vbmeta_a images/vbmeta.img</span><br><span class="line">fastboot --disable-verity --disable-verification flash vbmeta_b images/vbmeta.img</span><br><span class="line">fastboot --disable-verity --disable-verification flash vbmeta_system_a images/vbmeta_system.img</span><br><span class="line">fastboot --disable-verity --disable-verification flash vbmeta_system_b images/vbmeta_system.img</span><br></pre></td></tr></table></figure></li><li><p>卡刷(recovery)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 先刷机前准备</span><br><span class="line"># fastboot flash recovery twrp.img (刷入启动刷机包的镜像)</span><br><span class="line"># fastboot boot &lt;twrp.img&gt;</span><br><span class="line"># adb push rom(rom包) /sdcard/</span><br><span class="line"># 进入recovery模式后刷入镜像（twrp.img）,刷入rom刷机包</span><br></pre></td></tr></table></figure></li></ol><h2 id="recovery模式下的rom"><a href="#recovery模式下的rom" class="headerlink" title="recovery模式下的rom"></a>recovery模式下的rom</h2><h2 id="pc端rom制作"><a href="#pc端rom制作" class="headerlink" title="pc端rom制作"></a>pc端rom制作</h2><pre><code>1. https://github.com/ColdWindScholar/TIK 2. 准备termux     - ssh (adb forward tcp:8022 tcp:8022)(ssh 127.0.0.1 -p 8022)    - pkg install binutils    - 安装依赖 （pkg install openssh libxml2 libxslt libiconv ldd e2fsprogs）    - pkg update upgrade    - [安装内置ubuntu](https://blog.csdn.net/weixin_49966522/article/details/123602528)3. 解包，替换，打包，刷机4. 注意清除data分区数据，才能使用 adb 网络调试（原因不明）5. adb -s 192.168.141.202:7777 shell mkdir -p /sdcard/Download/files6. adb -s 192.168.141.202:7777 push ~/.../worker-release-unsigned.apk /sdcard/Download/files/worker_hot.jar7. adb -s 192.168.141.202:7777 reboot8. adb -s 192.168.141.202:7777 install ~/Work/Document/android_system/z_apk/termux-app_v0.118.0+github-debug_arm64-v8a.apk9. adb install /Users/eleme/Work/Android/project/frpc_android/app/release/frpc_adnroid-v0.39.1.1.apk10. https://github.com/wcedla/AndroidApexTools.git apex 工具</code></pre><h2 id="termux抓包方案"><a href="#termux抓包方案" class="headerlink" title="termux抓包方案"></a>termux抓包方案</h2><pre><code>1. 安装ssh    pkg install openssl    pkg install openssh    ssh-keygen -A     passwd2. 安装python</code></pre><p>pkg install python<br>pkg install libexpat<br>pkg install libc++<br>pkg intall rust<br>pkg install binutils<br>pkg install wget<br>pkg install android-tools<br>pip install requests</p><h1 id="缺少依赖-https-www-bilibili-com-read-cv24517186"><a href="#缺少依赖-https-www-bilibili-com-read-cv24517186" class="headerlink" title="缺少依赖 https://www.bilibili.com/read/cv24517186/"></a>缺少依赖 <a href="https://www.bilibili.com/read/cv24517186/">https://www.bilibili.com/read/cv24517186/</a></h1><p>wget <a href="https://cdn.jsdelivr.net/gh/liuxsdev/Python-Wheels-for-Termux/Wheels/ruamel.yaml.clib-0.2.7-cp311-cp311-linux_aarch64.whl">https://cdn.jsdelivr.net/gh/liuxsdev/Python-Wheels-for-Termux/Wheels/ruamel.yaml.clib-0.2.7-cp311-cp311-linux_aarch64.whl</a><br>pip install ruamel.yaml.clib-0.2.7-cp311-cp311-linux_aarch64.whl</p><h1 id="下载-https-mitmproxy-org-downloads-10-3-1"><a href="#下载-https-mitmproxy-org-downloads-10-3-1" class="headerlink" title="下载 https://mitmproxy.org/downloads/#10.3.1/"></a>下载 <a href="https://mitmproxy.org/downloads/#10.3.1/">https://mitmproxy.org/downloads/#10.3.1/</a></h1><p>wget <a href="https://downloads.mitmproxy.org/10.3.1/mitmproxy-10.3.1-py3-none-any.whl">https://downloads.mitmproxy.org/10.3.1/mitmproxy-10.3.1-py3-none-any.whl</a><br>python -m pip install mitmproxy-10.3.1-py3-none-any.whl<br>        # openssl x509 -inform PEM -subject_hash_old -in mitmproxy-ca-cert.cer<br>    3. 上传脚本<br>        scp -r -P 8022 &#x2F;Users&#x2F;eleme&#x2F;Work&#x2F;Python&#x2F;project&#x2F;mitm_rom&#x2F;mitm.sh 127.0.0.1:~<br>        scp -r -P 8022 &#x2F;Users&#x2F;eleme&#x2F;Work&#x2F;Python&#x2F;project&#x2F;mitm_rom&#x2F;push.sh 127.0.0.1:~<br>        scp -r -P 8022 &#x2F;Users&#x2F;eleme&#x2F;Work&#x2F;Python&#x2F;project&#x2F;mitm_rom&#x2F;update_script.py 127.0.0.1:~<br>        scp -r -P 8022 &#x2F;Users&#x2F;eleme&#x2F;Work&#x2F;Python&#x2F;project&#x2F;mitm_rom 127.0.0.1:~<br>        scp -r -P 8022 <del>&#x2F;.mitmproxy 127.0.0.1:</del><br>        settings put global http_proxy 127.0.0.1:29999<br>        cp mitm_rom&#x2F;mitm.sh mitm.sh<br>        cp mitm_rom&#x2F;push.sh push.sh<br>        cp mitm_rom&#x2F;update_script.py .<br>        chmod +x mitm.sh push.sh<br>        nano .bashrc<br>        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python update_script.py</span><br><span class="line">clear</span><br><span class="line">rm -rf ~/http</span><br><span class="line">mkdir -p ~/http</span><br><span class="line">sshd</span><br><span class="line">nohup ~/mitm.sh &amp;</span><br><span class="line">~/push.sh</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 逆向-android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向-android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向-android-实战</title>
      <link href="/2018/01/01/%E9%80%86%E5%90%91-android-%E5%AE%9E%E6%88%98/"/>
      <url>/2018/01/01/%E9%80%86%E5%90%91-android-%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>逆向-android-实战</del></p></blockquote><h4 id="1-逆向基础"><a href="#1-逆向基础" class="headerlink" title="1. 逆向基础"></a>1. 逆向基础</h4><p>1.1 各种文件转换</p><ul><li><p>整体来看<br><img src="https://wx3.sinaimg.cn/mw690/005EpKr8ly1g12gboqg9qj30j60bfdgm.jpg" alt="image"></p></li><li><p>局部（反编译部分）<br><img src="https://wx4.sinaimg.cn/mw690/005EpKr8ly1g1mzbaoztaj30u01hcn3v.jpg" alt="image"></p></li><li><p>局部（生成apk)<br><img src="https://wx4.sinaimg.cn/mw690/005EpKr8ly1g1mzbex1c0j30ha0b9acr.jpg" alt="image"></p></li></ul><p>1.2 AS环境搭建</p><ul><li>目前Android studio 已升级到3.x 。本人用3.0版本。3.0版本以上兼容较差，坑较多。</li><li>本人jdk版本1.8.0_101。尽量选这个jdk版本左右的版本。不然monitor启动不了，全是因为eclipse插件原因</li><li>安装好AS后让其自己下载Android sdk 。不然又是各种坑</li><li>Android sdk模拟器貌似只支持Intel。amd处理好像无法启动sdk中的模拟器</li></ul><p>1.3 window逆向工具</p><ul><li>Android killer，一款集打包，编译，逆向的工具。只有window版本</li></ul><p>1.4 Mac逆向工具</p><ul><li>AndroidCrackTool mac 打包，编译，签名，dex2jar（不好用）</li></ul><p>1.5 window，Mac通用逆向工具</p><ul><li>JEB(很强大)</li><li>jadx (免费，定时有更新)</li></ul><p>1.6 Android虚拟机调试器原理与实现 </p><ul><li><a href="https://www.freebuf.com/articles/terminal/114869.html">https://www.freebuf.com/articles/terminal/114869.html</a></li></ul><p>1.7 apk调试设置方式</p><ol><li>修改xml的android:debuggable&#x3D;”true”属性，重新打包。</li><li>利用xposed安装BuildProp Enhancer pak,修改ro.debuggable&#x3D;1</li><li>使用工具mprop修改</li></ol><ul><li>我们使用的工具是mprop，这里所有的条件是手机必须root</li><li>adb push “你下载好的mprop目录的mprop文件” &#x2F;data&#x2F;local&#x2F;tmp&#x2F;</li><li>执行shell  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">$ data/local/tmp/mprop  </span><br><span class="line"># 设置</span><br><span class="line">$ setprop ro.debuggable 1</span><br><span class="line"># 恢复init默认逻辑，之后就无法再修改ro属性了</span><br><span class="line">$ /data/local/tmp/mprop -r</span><br></pre></td></tr></table></figure></li></ul><p>1.8 逆向相关脚步</p><ol><li>java -jar ..&#x2F;..&#x2F;baksmali-2.2.6.jar d blackfish&#x2F;classes7.dex -o xiaohei&#x2F;src （提取smail代码）</li><li>java -jar smali.jar a out -o modify.dex 将smali合并成dex</li></ol><h4 id="2-调试"><a href="#2-调试" class="headerlink" title="2. 调试"></a>2. 调试</h4><p>2.1 smali调试</p><ol><li>smailidea.jar 下载并添加到idea</li><li>java -jar baksmali-2.0.3.jar disassemble XX.apk -o .&#x2F;XX</li><li>adb shell am start -D -n 应用包名&#x2F;Activity具体类名</li><li>adb forward tcp:8700 jdwp:18896</li><li>加入断点，run remote debug 8700（这里的端口查看monitor）</li></ol><p>2.2 IDA调试</p><ol><li><p>开启android_server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./android_server</span><br></pre></td></tr></table></figure></li><li><p>端口转发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 接通adb,端口转发</span><br><span class="line">adb forward tcp:23946 tcp:23946</span><br><span class="line"># 注意：so反调试会检查文件名或端口。尽量改到名称和端口</span><br></pre></td></tr></table></figure></li><li><p>启动app</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell am start -D -n XXXX/XXX</span><br></pre></td></tr></table></figure></li><li><p>开启ida,debugger option选项,附加进程</p></li><li><p>运行jdb调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=xxx</span><br><span class="line"># 注意：其中xxx为monitor中处于debug状态的端口</span><br></pre></td></tr></table></figure></li><li><p>导入结构体jni.h，动态识别函数名称.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向-android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向-android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机-常识-操作系统</title>
      <link href="/2017/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%B8%B8%E8%AF%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%B8%B8%E8%AF%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>计算机-常识-操作系统</del></p></blockquote><h3 id="1-操作系统四大特点"><a href="#1-操作系统四大特点" class="headerlink" title="1.操作系统四大特点"></a>1.操作系统四大特点</h3><pre><code>1. 并发2. 共享3. 虚拟4. 异步</code></pre><h3 id="2-操作系统基本功能"><a href="#2-操作系统基本功能" class="headerlink" title="2.操作系统基本功能"></a>2.操作系统基本功能</h3><pre><code>1. 进程管理    1.1 进程：cpu资源分配的基本单位。主要构成进程控制快（PCB），创建撤销进程都是对PCB的操作    1.2 线程：cpu调度的基本单位。一个进程包含多个线程    1.3 进程状态切换 就绪 运行 阻塞    1.4 进程调度算法        批处理系统（先来先服务，短作业有限，最短剩余时间优先）        交互式系统 （时间片轮转，优先级调度，多级反馈）        实时系统    1.5 进程同步        临界区        同步与互斥        信号量        管程    1.6 生产者与消费者    1.7 哲学家就餐（死锁） 预分配        互斥        占有且申请        不可抢占        循环等待2. 文件管理    文件读写，保护3. 内存管理 （内存分配，映射）    3.1 页面置换算法    3.2 分段    3.3 分页4. 设备管理    完成用户io请求，方便用户使用设备</code></pre><h3 id="3-生产者与消费者"><a href="#3-生产者与消费者" class="headerlink" title="3.生产者与消费者"></a>3.生产者与消费者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#no1. 协程方式</span><br><span class="line">def product():</span><br><span class="line">    shop=0</span><br><span class="line">    while shop&lt;5:</span><br><span class="line">        shop=shop+1</span><br><span class="line">        print(&quot;生产了一个商品shop:&quot;+str(shop))</span><br><span class="line">        yield shop</span><br><span class="line"></span><br><span class="line">def constorm(t):</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            shop=t.send(None)</span><br><span class="line">            print(&quot;消费了一个商品:&quot;+str(shop))</span><br><span class="line">    except StopIteration as e:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">#no2. 多线程</span><br><span class="line">import threading</span><br><span class="line">from queue import Queue</span><br><span class="line">def product(que: Queue):</span><br><span class="line">    while True:</span><br><span class="line">        shop=&quot;new shop&quot;</span><br><span class="line">        que.put(shop)</span><br><span class="line">        print(&quot;procuce :&quot;+shop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def constorm(que: Queue): </span><br><span class="line">    while True:</span><br><span class="line">        shop=que.get()</span><br><span class="line">        print(&quot;消费了一个商品:&quot;+shop)</span><br><span class="line"></span><br><span class="line">que=Queue(maxsize=5)</span><br><span class="line">t1=threading.Thread(target=product,args=(que,))</span><br><span class="line">t2=threading.Thread(target=product,args=(que,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t3=threading.Thread(target=constorm,args=(que,))</span><br><span class="line">t4=threading.Thread(target=constorm,args=(que,))</span><br><span class="line">t3.start()</span><br><span class="line">t4.start()</span><br></pre></td></tr></table></figure><h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">lock1=threading.Lock()</span><br><span class="line">lock2=threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def people1():</span><br><span class="line">    while True:</span><br><span class="line">        lock1.acquire()</span><br><span class="line">        print(&quot;people1 拿到左边筷子&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">        lock2.acquire()</span><br><span class="line">        print(&quot;people1 拿到右边筷子&quot;)</span><br><span class="line"></span><br><span class="line">        lock2.release()</span><br><span class="line">        lock1.release()</span><br><span class="line">        print(&quot;people 吃完了放筷子&quot;)</span><br><span class="line"></span><br><span class="line">def people2():</span><br><span class="line">    while True:</span><br><span class="line">        lock2.acquire()</span><br><span class="line">        print(&quot;people2 拿到右边筷子&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">        lock1.acquire()</span><br><span class="line">        print(&quot;people2 拿到左边筷子&quot;)</span><br><span class="line"></span><br><span class="line">        lock1.release()</span><br><span class="line">        lock2.release()</span><br><span class="line">        print(&quot;people 吃完了放筷子&quot;)</span><br><span class="line"></span><br><span class="line">t1=threading.Thread(target=people1)</span><br><span class="line">t2=threading.Thread(target=people2)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机-常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机-常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机-常识-数据库</title>
      <link href="/2017/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%B8%B8%E8%AF%86-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2017/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%B8%B8%E8%AF%86-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>计算机-常识-数据库</del></p></blockquote><h3 id="1-事务的ACID特征"><a href="#1-事务的ACID特征" class="headerlink" title="1. 事务的ACID特征"></a>1. 事务的ACID特征</h3><pre><code>1. 原子性2. 一致性3. 隔离性4. 持久性</code></pre><h3 id="2-数据库三范式"><a href="#2-数据库三范式" class="headerlink" title="2. 数据库三范式"></a>2. 数据库三范式</h3><pre><code>1. 1NF 列是原子性，不能再分2. 在1NF基础上，一个表一个主键，其他属性必须完全依赖主键3. 在2NF基础上，非主键列不存在依赖情况</code></pre><h3 id="3-乐观锁和悲观锁"><a href="#3-乐观锁和悲观锁" class="headerlink" title="3. 乐观锁和悲观锁"></a>3. 乐观锁和悲观锁</h3><pre><code>1. 乐观锁 版本号控制 version字段2. 悲观锁 for update</code></pre><h3 id="4-mysql-一次性添加几十万大数据"><a href="#4-mysql-一次性添加几十万大数据" class="headerlink" title="4. mysql 一次性添加几十万大数据"></a>4. mysql 一次性添加几十万大数据</h3><pre><code>1. insert 批量操作2. 开启事务，设置 innodb_log_buffer_size 尽可能大3. 主键顺序插入</code></pre><h3 id="5-mysql-数据优化方案"><a href="#5-mysql-数据优化方案" class="headerlink" title="5. mysql 数据优化方案"></a>5. mysql 数据优化方案</h3><pre><code>1. 根据业务类型特点选择存储引擎，innodb 事务类型；myisam 支持全文检索2. 分库分表3. 对查询进行优化，where 和 order by 字段添加索引4. where 字段避免null, 避免使用！= or &lt;&gt;,避免使用or来连接条件5. json大表可以采用分页  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机-常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机-常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机-常识-网络原理</title>
      <link href="/2017/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%B8%B8%E8%AF%86-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2017/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%B8%B8%E8%AF%86-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>计算机-常识-网络原理</del></p></blockquote><h3 id="1-计算机网络原理"><a href="#1-计算机网络原理" class="headerlink" title="1.计算机网络原理"></a>1.计算机网络原理</h3><pre><code>1. 物理层（比特传输）集线器    1.1 通讯方式        单工，半双工，全双工2. 数据链路层（交换机）    2.1 解决问题            封装成帧            透明传输            差错检测    2.2 信道分类            广播信道 （CSMA/CD协议）&#123;多点接入，载波监听，碰撞检测&#125; =》2T            点对点信道 （ppp协议）PPP 协议是用户计算机和 ISP进行通信时所使用的数据链路层协议。    2.3 信道复用技术            频分复用            时分复用            统计时分复用            波分复用            码分复用</code></pre><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><p><img src="https://wx1.sinaimg.cn/mw690/005EpKr8ly1g3y5qbaxcwj30u00minbw.jpg" alt="网络分类"></p><pre><code>3.1 如图3.2 相关协议    ARP （mac地址解析协议 ip-mac）    ICMP    IGMP    IP3.3 路由分组转发</code></pre><h3 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h3><pre><code>4.1 UDP与TCP4.2 TCP三次握手</code></pre><p><img src="https://wx2.sinaimg.cn/mw690/005EpKr8ly1g3y8b6fqmzj30i40bd750.jpg" alt="TCP三次握手"><br>    4.3 TCP四次挥手<br><img src="https://wx2.sinaimg.cn/mw690/005EpKr8ly1g3y8b6g2zmj30ik0cvab9.jpg" alt="TCP四次挥手"><br>    4.4 TCP滑动窗口</p><h3 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5. 应用层"></a>5. 应用层</h3><pre><code>DNS 53FTP 20 21smtp 25 发送    pop3 imap 读取telnet 23http 80</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机-常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机-常识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
